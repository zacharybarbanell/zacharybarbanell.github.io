<!doctype html>
<html lang="en-US">
<head>
<meta charset="UTF-8">
<meta name="description" content="Chroma Key">
<meta name="twitter:player" content="https://zacharybarbanell.github.io/Enigmarch-2022/1/Chroma-Key-Embed">
<meta name="twitter:player:width" content="1024">
<meta name="twitter:player:height" content="1024">
<meta property="og:image" content="https://zacharybarbanell.github.io/Enigmarch-2022/1/Chroma-Key.png">
<title>Chroma Key</title>
<style>

body {
	background-color:black; /*don't modify this line at all, needs text to be the same*/
	font-family:"Courier New", Courier, monospace
}
#gameCanvas {
  position:absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  bottom: 0px;
  right:0px;
  border: 0px;
  background-color: black; /*don't modify this line at all, needs text to be the same*/
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
} 

h1 {
	color:lightblue;/*don't modify this line at all, needs text to be the same*/
	font-weight:normal;
}
a {
	color:lightblue;/*don't modify this line at all, needs text to be the same*/
}
.title {	
	background-color:none;
	text-align:center;
	font-size:100%;
	float:center;
	color:gray;
	position:absolute;
	left:10%;
	right:10%;
	top:0%;
	height:10%;
}

.footer {	
	background-color:none;
	text-align:center;
	float:center;
	color:white;
	position:absolute;
	margin-top:10px;
	left:10%;
	right:10%;
	top:90%;
	bottom:10%;
}
.gameContainer {
	background-color:none;
	position:absolute;
	left:10%;
	right:10%;
	top:70px;
	bottom:70px; touch-action: none;
}

  .mobile-menu {
      position: relative;
      top: 4em;
      margin-left: auto;
      margin-right: auto;
      font-weight: bold;
      border-radius: 0.25em;
  }

  .mobile-menu.item-count-3 {
      width: 30em;
  }
  .mobile-menu.item-count-3 .button {
      width: 28.3333%;
      /* scale the height of the button relative to the width of .mobile-menu */
      padding: 7.5% 0%;
  }

  .mobile-menu.item-count-2 {
      width: 20em;
  }
  .mobile-menu.item-count-2 .button {
      width: 46%;
      /* scale the height of the button relative to the width of .mobile-menu */
      padding: 12.1765% 0%;
  }

  .mobile-menu.item-count-1 {
      width: 10em;
  }
  .mobile-menu.item-count-1 .button {
      width: 98%;
      /* scale the height of the button relative to the width of .mobile-menu */
      padding: 26.5% 0%;
  }

  .mobile-menu,
  .tab-icon,
  .mobile-menu .close {
      background: rgba(0,0,0,0.4);
      border: 2px solid rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 1);
  }

  .mobile-menu .button {
      margin: 2%;
      border-radius: 0.25em;
      text-align: center;
      float: left;
  }
  .mobile-menu .clear {
      clear: both;
  }

  .tab-affordance,
  .close-affordance {
      width: 6em;
      height: 6em;
      position: absolute;
      z-index: 1000;
  }

  .tab-affordance {
      left: -2em;
      top: 55px;
  }

  .close-affordance {
      left: -4em;
      top: -1em;
  }

  .tab-icon,
  .mobile-menu .close {
      height: 48px;
      position: absolute;
      border-radius: 6px;
  }

  .tab-icon {
      left: -0.5em;
      top: 70px;
      width: 18px;
      border-radius: 0 6px 6px 0;
      border-left: 0;
  }

  .mobile-menu .close {
      left: -18px;
      width: 18px;
      top: 0px;
      border-radius: 6px 0 0 6px;
      border-right: 0;
  }

  .tab-icon .slice,
  .mobile-menu .close .slice {
      margin: 4.5px 1px;
      width: 2px;
      height: 80%;
      background: rgba(255, 255, 255, 0.4);
  }

  .tab-icon .slice {
      float: right;
  }

  .tab-icon .slice:first-child {
       margin-right: 4.5px;
  }

  .mobile-menu .close .slice {
      float: left;
  }
  .mobile-menu .close .slice:first-child {
       margin-left: 4.5px;
  }

  @media screen and (max-width: 32em) {
      .mobile-menu {
          font-size: 0.8em;
          width: 90%;
      }
  }
  @media screen and (max-width: 24em) {
      .mobile-menu {
          font-size: 0.65em;
          width: 90%;
      }
  }

 .disable-select {
     -webkit-touch-callout: none;
     -webkit-user-select: none;
     -khtml-user-select: none;
     -moz-user-select: none;
     -ms-user-select: none;
     user-select: none;
 }

</style>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
</head>
<body>
<div class="title"><h1>Chroma Key</h1></div>
<div class="gameContainer">
<canvas 
    id="gameCanvas" 
    onmousemove="mouseMove(event)" 
    onmouseout="mouseOut()"
    onkeydown="keyDown()"
></canvas>
</div> 
<div class="footer">
<span id="errormessage" style="color:red;"></span>
<a href="http://www.puzzlescript.net">www.puzzlescript.net</a>
</div>

<div style = "z-index: 2; background: transparent; position: absolute; top: 0.5em; right: 1em;">
    <img alt="mute" id="muteButton" width=32px height=32px onClick="muteAudio()" style="display:none"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABl0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC4xOdTWsmQAAAIGSURBVFhH3ZchcsJAGIURiApEBbIH6BEqOQASWYHoESoQFcwgOAaiEsEBKip6BERlBQJRwQEqtu/tvj+TLMnAJpntTL+ZP/De7p/9k102YUCcc0tEbpbx4MHIAMcKQ2LM4ktmOCYH9gXIawXzQasLYGKnAphryErC53VJLiPvhNgjtog54tZ3bgDt7QpgTkyD/42Y+aQa2CG5APYvMdGnFTBC3COeEG8IY4M4uxtsSCqAfQ1ZhSdZATangdNCvhCVImheVQC6FFdKZHtkeQ8fB8QOsUCM5N0hPhBkQ8+gEQ5BXLUb+swSsu0cZXjFE/kswu7ElB6hCAeJS/isCDXZOcaIKeKdHvhBPKiN00F4l+zu1BaQtKkop1Ic5BCx8g3OfSJu5Fthj9LnBfB7Ckqzc/Dq1oihtA34LP0SpHuV7r0AYyXN6SC7SO+ley9gFpQ7SHNNkFifpP9fAcZaOvsUNC3ChbQtwq30eQGg88+QwLKNjRuS/e6toLl0bQGNsF+MmuwcdRuR7Ya2EfEJ6Z8JFOEQRK6tuHg8U4TDBdClr4eRn3uDRjhcCfsasgpPsgLs8uP4iBiryUMzqQDC/iXiFxJbA1zttg4IX9EqgxM2JBdAmBPT4Pf/SmYwr4y8PC+lBnMNWUn4vLbJBvNBtz8m4E//mtkGlK0IjhWG1Jj8EnRWMPhg8AvjeqPLyfe3igAAAABJRU5ErkJggg==" />
    <img alt="unmute" id="unMuteButton" width=32px height=32px onClick="unMuteAudio()" style="display:none" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTnU1rJkAAABqElEQVRYR72XW3LDMAwDc7QerTdPRWjBoW1aedXZGUYUAIlqP9LpLbjf77+jvs3vfvgUvkDMmiPHzGxg9HTXEjNjsB6A0Nar+MxYg+UPFoH5ccLCauE+3Wmqvke+Pk5YWAl3sJuXGiSx3wfSOsMsrKRm4i6DJJAEktB+L1YW1oG4xyAJJIGUSOsMs7A2xB0GSSAJpA3Sz8xgYYnh/8R5g+ZKFG6Q9yAQ9dS3JEcEkkBqkb8K2X8EcYEkkE5RxkH6rkz7VT10uu3wwcbrcOipB+hEg62ZmlR9hbL1wEkJndgRMpVgif1+j3yH6LsSOtGALZAE0rUPwBJICfJ1D0A2ylamfDxXke8QfVfCGdak6pXpNkZBvkP0XeUl3hvkFiKfP8CwT5BPIfavD0iQBNJhEPJnDzCjr6Q31sMfI4P0/gPM6BP20ivTnSClxrZFvkP0WQ4YCQuImfzNYLfId4i+VqL0ExDfgNUi3yF6V6LkC3AsQW6R7xB9rZeHmzhrkFrkO0R/qHcZZ4Plv3sROARHv1mvImbG4GxixbucmDVHMjOauf8qY/jt9gdOODPsYZA1BAAAAABJRU5ErkJggg==" />
</div>

<script type="text/javascript">
var unitTesting=false;
var curlevel=0;
var muted=0;

const storage_get = (key) => localStorage.getItem(key)
const storage_has = (key) => (localStorage.getItem(key) !== null)
const storage_set = (key, value) => localStorage.setItem(key, value)
const storage_remove = (key) => localStorage.removeItem(key)

var debug = false
var verbose_logging=false;
var throttle_movement=false;
var cache_console_messages=false;
const deltatime = 17
var timer=0;
var repeatinterval=150;
var autotick=0;
var autotickinterval=0;
var winning=false;
var againing=false;
var againinterval=150;
var norepeat_action=false;
var oldflickscreendat=[];//used for buffering old flickscreen/scrollscreen positions, in case player vanishes
var keybuffer = []

var level

var sprite_width = 5
var sprite_height = 5

function clamp(min, value, max)
{
    return (value < max) ? ( (value < min) ? min : value ) : max
}

// from console.js

function addErrorMessage(str)
{
	var errorText = document.getElementById("errormessage")

	var div = document.createElement("div");
	div.innerHTML = str;
	str = div.textContent || div.innerText || "";

	errorText.innerHTML += str + "<br>"
}

function consolePrint(str, urgent) { /* addErrorMessage(str) */ }

function consolePrintFromRule(str, rule, urgent) { /* addErrorMessage(str) */ }

function consoleCacheDump(str) { }

function consoleError(str, lineNumber) { addErrorMessage(str) }



// from debug.js

var canSetHTMLColors=true;
var canDump=false;
var canYoutube=true;
var IDE=false;

function clearInputHistory() { }
function pushInput(inp) { }

const font_width = 5
const font_height = 12

const chars_in_font = '0123456789abcdefghijklmnopqrstuvwx×yzABCDEFGHIJKLMNOPQRSTUVWXYZ.·•…†‡ƒ‚„,;:?¿!¡@£$%‰^&*()+÷±-–—_= {}[]\'‘’“”"/\\|¦<‹«>›»~˜`#' +
 'ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßẞàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿĀāĂăĄąĆćĈĉĊċČčĎďĐđĒēĔĕĖėĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪīĬĭĮįİıĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŃńŅņŇňŉŊŋŌōŎŏŐőŒœŔŕŖŗŘř' + 
 'ŚśŜŝŞşŠšŢţŤťŦŧŨũŪūŬŭŮůŰűŲųŴŵŶŷŸŹźŻżŽž€™¢¤¥§¨©®ªº¬¯°'

var font = new Image()
font.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABl4AAAAMCAYAAAADIcDRAAAAAXNSR0IArs4c6QAADyJJREFUeF7tXduOLDcO2/n/jz7BnKACLUFKlG/d0+N9ynTJtkRJFF2VYL/+d/93EbgIXAQuAheBi8BF4CLwMgT+/Pnz5+vr64s5gM+qv7MgsnNG1434MxOvm6R4xvPPM+ey/VxfOnajOeqccW0vAu+OgNOzIzE4/eXYuGe7cbh27rmu3U8418nHyTicmef4XM17jGlkz5O4uDVXxT2zT3ftCKbdM659jYBbp7t02Ko6cON4EHHOdWxqhP+16PpX7btrv+hr5YNzd3Ew7No49o7v7j6unTpzdj3W7Kr9HIw+xYZe8j8luBvHReAicBHYjQAbPHcY7Ub97n8R+DwEHC5RL2Kq31dcuEb8y85dvV+siIjH9+/xo9bIuWq/7NLpviBgdtVvP7X672z8qZlb5/d3DTy7qY/NnZdSHc+c+uu8SHL267xAcvdzYt6B80r/XFxemQ+GM2LA/Ov4XM0ttdeO/Dp15ebN3WuFNnHPUrlz17+L3ao+HK3TDg4r69TVVB3/dtZz5YeTxx05cs6tfGe81VmTcetTM5k+WFlXLgftqD83v7N2bs5X22GdYN4rDThbU931qq5cXKrz7oeXCqH7/CJwEbgIJAgwMl5F0Bf4i8BF4CLgIuDwjmPjnnftNALuXJjJx8pLYOZH9bLK9cO9OGYXcueZg+lMvFndKyyc2FfhPNuXDn6zZ4yud3Ac2duJ2bFxz35lHI6Pu/yrzu6c6+Sjs1/l2+xz5osTw+y5GWe+6nwnptW+rd7PiWGHjYpjND41d0b3Wxmz27+uBun6tgoDN47HP+dcx8aNt+ufu++33Qo/V+dXxct8dfxf7V8HN8c/V7N28oq2nRoa8Vnx1IzPLi6d2Ko7yt8PL98bPobfX57wb7T5/hvt4m/49Srul53j2jGfq0A7iXEK4vGVfanL1ldNnQ3UB+NOLCdtHdxO+hPPymo84spqMO7D6l7FpGzx37xl6ztrnX7D2okkonpS4aJ6n/FEhs3zjPVS/A19Zfi5mK6uv4orVW5OfeFn/qmBXnHTauzcgTdy7g4RNOLH6jXYK2oOdeycGkU8UQM8nPDshSLlnWfD6hyN7udyyU47pe1GYzq1julWJdJ34hfrH+eqO7dm7FCr4ExW/sVZzPiA/ddCrMdRMyAvqNnj1okzo9CveKaqCdSKWbzVfkovfup/ccXwZniyGZJpTFW7rIaUzsG6Qn2P8wo1KethFQer/Ww/jEP5xuot03VZLymexDUMF3Y36tphXTjnYh3EGcV0h+LA7I7QrQPld/TVvZfFGmOxqrpS+cDaWJG3rOajf4pHlR7Hu13Wb4y71dms79W7mqxvsX9VveNcjX3mnMs4jdVSNr+yO4/S36P7KQ5W99oZzeXwfVZfjA8yHlJzOuPnkf0Ur1XxjvAf64eKJ1fyBtsr4zWlgZ99Ml3J+C/Lacb98Rylc6JPMXeO1mT2eE52bsc/Z9auzLnqCYV35FrFIwpfxS+ZPsjuQu5+iCn2NMb65PLvRxanKJ1BhgWYAakGAUuWasIqUc4ZCjgn8WytGqDK1sG1itPde7fdKN6n/WJ16taua6fqYKbf2KBimDPifjBmAjHWVzwjkojTg7gWe7m63GTDVglZlUt26cl6eqYGsxwoDGbOc9e6g38Xv1R8UAmWan2Hf0f3crE+ZTdTa6NrVZ5QBD39z8TxSvxX7nUqb9U5rFdXcnE18+L5o3XizryKE0fPxxheMfNU7Z/M5cg83zUbq7r/xOfvwk+jfdTJScUbbC9Xl+y26+gHJ47V+zFsUdszzmU2WU7der12/N/cdmY3amynb3463k6Mnb7K+qHirAxL109lp3iKaa5M+6i+ZbrGeXkZNYeKH33M7NSHRMcX9Y7RwQNz250LVR9196vuy6P7rZ4fs/tlcc5oi2rtKH5u7Y7YZRwxsh+r+2pur8Sl6omqxquerO54zl0xi9fl7Ipf2L2MfcyK/rrYZRj934cXl4QRtLhONVV0Ir5EfX7PXpQ++z8gVYNOEQ77whX3zHxkPqu1eH7nZbdbbKoQEKvHLuIcbXA4O3nC9RXe0YeVL9dZ03R8YbFWL+zd2LO6zupDvQBRPZYNsUjk2DvY606OIhlnhMVirwaXymX2RZ/tWQ11VR+MJFUOM0KNGCm+wVhdn7rnKnuW+8gncR3jI8Sl4hzsM8VJ1cfurOYqYe/WhWs3mrPZda5/M3azPrL6ycRp1g9uHKp+q1hGRZTaN3JudiFFO9VnIx+8R7g942fs1wpT57mDTcZDLN8Yw1NXbA5Gns5mz4zdznOzuch8ZvoB64TpwtO/uRqd2Y3+trrHYj1Vs3HU5+4Zp/gFZ717bna/Qk2FNZnpAuQipjGq/bCfmJ5BrlpxbsUfyKFYayqun2j3LnlTeqSaed0+V/ONaSWnx16xH9MUbOaoO7eyzbSKq32Utsj0YKWRkKci5o6OZb5j3pRuZD2tNMLjZ3W3jnZKU3TOyHg87rPaTvUH6sNdcwZ5HPFHnCvNNaORYszOuaz+1Gxj+pvNysqOzfPf8Bub91m/Vz3DniMnZTpF1W1Hbzk6SOkr1IQjM5TxvNNfTLezGVrNffX8vw8vmOBsULPh/9jHZ2qIqeHILuOOqHCHrTPYWBxq+GUYqReB1QCuRAUT27FAV18ilShiBVX5zmqjQyzKFgcmG6AjuLj5VQ1Z5TqrK8S3QwQMJ8Qeh25W92rosaHKiK6Ks+pfh5s6OahqN2KhuE7FqWpxJWmPkr3iP9dnxsU43OMZTGBlYkHFpeZIJ+dOL46cP5qLiDnuwV4yqP7M+rbD3bNxjKzP5kVWk07/Ku52NEbGV9WMq8Qucovi0IoTsX5G5lvWq07tuD11on9xPiJ+2fxU820Vpjty6dTxjnNfgZXq5RlfGH7uHGR2jBd2312q/EbdNIPVp67doR9mODGrF6alnrwwrnPmUKUpKv5z+/KT7dzYsrur0hQra+kVte7EVcWo7hAZBztcHHWXo0MzTYh6tLuf0iZM42U8oDShq30yu+yeh5q24o1qbu3QtqizcTaq51gnK+1Y3eCsRZuMs3ftV/VoRzdVNdbh00/TJUyv4dyoeKjiHpZLhTl7D8E0SmWX1Y87F7O4uz65OLPeW/Xbf/9/LtVFTiUsI6bnGbvEs6apfIjgxwZm57jknjU6guz658bGCCsbwpmgcOOdscOB2IkznlvF4V6Ks4ZTAgUHZzbk3SHA7BhRqDrN4mX+ueTKCCaLV/UUwznLvaprFWdVk4qcK8J1OEsRadaHTOCMvqhcReTZPqr3unFgPSl+fGq/qnfG59lHB/zAzERJtxe7+Ecfnh7AvkEbNQe7Zzuxsd7LfhvxYcWaTIzF/R27ro1jz/g78lfMvXrJVfVkXMe4dwXOo3uM8pmLbbdOnX3ZzH/lS4DR+ev4PKNF2ex+9W/VjFrdH67GdOs007SO5nJy3s3Rzvrr+oIYMF5iGKy2281rDk+5czzriYzrlC5CXRaxVXd0xP/VdkqX4x3ihJ17Bupc9hLb4XO3bt7FjnFipqsY11a8ynKgfqvuFgq3yi/sERV3ZpflLHIt8gvWfezxlTOF1ezsDFjpX+aLqiHU8NmcZvlh2HfsVD0oXsE6PGW3cqZl+HTycaruT9Y402tslmf84j6Ltcc4pfqYknEl0ybPeXjnVe90VJ2w9y+oayqex7sE8wl7U/1d9aBaZ/9/vLDmGxkk2WBwxIcigdEGGSHKqriZL+5Fr9ob92HNmg2QGcJiReSIq6wxkFjU3zFPjIzYcxxUXVw6teEMJ4V9VhvKZ4WBwmlFf1S1ll1qnbp2asHtLYevXHKt7NjgioNG1WE2XPCZU1+Vn9V5nf6OtgrrLJ+ID+sNhpuTVxcrZy+GmYOza4MiAOsb95mJzY3X9X3ULvOD9dKql2XurMp6z8U/w4blfJSfZ+Z5XJvxs+oBF4tOvmfOwhjeBdNVOar4UM2hUy84uvrqk+qP9c+r81HptVf3x0y9rFg7wzUn1qr+YPMp5hJ1V6XVZnj8FWt38OmJXlAveEZ1CZsH7/SbE1dVP9UeFe9mvVDN00x7u5rGtcvuGZk2O9ULn/jhRb13YZiy/Mza7b7bVb3lcsWqfUbPO1XjJ2ZAdgbTa4y/Kj5w3qOrXCi+YlrW+Tij+gZn4YOL0swMt+oDS9Vfqq7UvtWdvrPu6wHm2RS/KGWH4TP1guQJMJ7Bzs2KwVnLzom/xYKMvrOY1Ze1jIBxT4yH+YL7qQLHtdiQWRGxtcxXxA+LHXOWPVd1lDWrEklubFmtspcPLgZVrWBtRvsKU/Y8khD2ZRUHs3fxQ3Gl4mB2TpzKd/yd/Z3Vhho0ip8yMaxqiPWb+zG14jXkpdg7+M9xL9V/1Ytqh4cqn1mNKuwc0V7NGSVyq3wxvlaxMS5WNVT5y55XPeLsiTgoXFw758yVNk7vZcKym8/Kd8efao+R5xmfPDFifyseX2FXaYSRGE+uYXrN1VIR74hlpR2Znjz5W8VX1eVGccSTN0cXqzmwe+1JnEfr4J3rb0fe1Kys5l7kwmzeztrtrslZTCv8Kv3scLjiSXb26f3cnp7FeXUduPMX+di9t7B4s/v16bxl/qm7TFzDavKpx0wLdvXQO9S4wgo1SIVpxMetvxk75w7Xec/wCs2leMPBBbVW9N+9bzO7WJOreWl2P9aD0V+mHzFGhpO6c8X9Ks0120duv520Yz2Gv2V1+OSmM1eQE1f/zWY64/5snlV1qLiExVLVFavf1Zj8jX/Hpr95z86LHHz5cgo3x0fH5pS/7jk/0Wc3tnewu/iOZ+E3YteJmYn2cbTvyovARWAWgU7/zp71ietP48fOO+3Dyjz+ZN9X4jC610n83Pm926dP64HR3L/LulP5cOtqtd274Lzaj1fnLXs3csq31Zi+Yr+TWJ086xVYZi+AXV454feOPLxTfCcwXHmGwm4Hpjv2XIlFtddP97+K73l+P7y4SCV2z6Xj26T7xewVheac6dgsgG5qi4j7CPZTh9/FF4GLwDIE3Bc3yw68G10ELgISgZ8w/985fRe/uexc/N4bP6a91QufGEn3fjSCwo4XTyN+3DX/IrArH+69e8buN+vSXXl7+qLiePf8ap+RPnTPHtn71JqTMZw86xR+7JyfGOdsf+D638yJo7W36+PLJ70Dna3T0dy8Yt0/OxBaVmYPNVgAAAAASUVORK5CYII="
font.addEventListener('load', function()
{
	var canvas = document.createElement('canvas')
	canvas.width = font.width
	canvas.height = font.height
	var fctx = canvas.getContext('2d')
	fctx.drawImage(font, 0, 0)
	font.pixels = fctx.getImageData(0, 0, canvas.width, canvas.height).data

	redraw()
})

font.colored_fonts = { '1-#FFFFFFFF': font }

font.colored_font = function(css_color)
{
	const key = css_color
	if (key in this.colored_fonts)
		return this.colored_fonts[key]

	if (font.pixels === undefined) // image is not loaded yet
		return null

	const color = Array.from( [1,3,5], i => parseInt(css_color.substr(i,2), 16) )
	const f_alpha = parseInt(css_color.substr(7,2), 16) || 255

	var canvas = document.createElement('canvas')
	canvas.width = this.width
	canvas.height = this.height
	var fctx = canvas.getContext('2d')

	for (var i = 0; i < this.pixels.length; i += 4)
	{
		const alpha = this.pixels[i+3]/255 // alpha channel. 0=transparent, 255=opaque
		if (alpha === 0)
			continue
		fctx.fillStyle = 'rgba(' + color.map(x => Math.round(x*alpha)).join() + ',' + f_alpha + ')'
		fctx.fillRect( ((i/4) % this.width), Math.floor((i/4) / this.width), 1, 1)
	}
	this.colored_fonts[key] = canvas
	return canvas
}

function draw_char(ctx, colored_font_image, ch, x, y, w, h) // draws char ch at position (x,y) in the canvas ctx with width w and height h
{
	const ch_index = chars_in_font.indexOf(ch)
	if (ch_index < 0)
		return
	ctx.drawImage(colored_font_image, ch_index*w, 0, w, h, x, y, w, h)
}


/**
 * Seedable random number generator functions.
 * @version 1.0.0
 * @license Public Domain
 *
 * @example
 * var rng = new RNG('Example');
 * rng.random(40, 50);  // =>  42
 * rng.uniform();       // =>  0.7972798995050903
 */

/**
 * Get the underlying bytes of this string.
 * @return {Array} An array of bytes
 */
String.prototype.getBytes = function() {
    var output = [];
    for (var i = 0; i < this.length; i++) {
        var c = this.charCodeAt(i);
        var bytes = [];
        do {
            bytes.push(c & 0xFF);
            c = c >> 8;
        } while (c > 0);
        output = output.concat(bytes.reverse());
    }
    return output;
}

/**
 * @param {String} seed A string to seed the generator.
 * @constructor
 */
function RC4(seed) {
    this.s = new Array(256);
    this.i = 0;
    this.j = 0;
    for (var i = 0; i < 256; i++) {
        this.s[i] = i;
    }
    if (seed) {
        this.mix(seed);
    }
}

RC4.prototype._swap = function(i, j) {
    var tmp = this.s[i];
    this.s[i] = this.s[j];
    this.s[j] = tmp;
}

/**
 * Mix additional entropy into this generator.
 * @param {String} seed
 */
RC4.prototype.mix = function(seed)
{
	const input = seed.getBytes()
    var j = 0;
    for (var i = 0; i < this.s.length; i++) {
        j += this.s[i] + input[i % input.length];
        j %= 256;
        this._swap(i, j);
    }
}

/**
 * @return {number} The next byte of output from the generator.
 */
RC4.prototype.next = function() {
    this.i = (this.i + 1) % 256;
    this.j = (this.j + this.s[this.i]) % 256;
    this._swap(this.i, this.j);
    return this.s[(this.s[this.i] + this.s[this.j]) % 256];
}

/**
 * Create a new random number generator with optional seed. If the
 * provided seed is a function (i.e. Math.random) it will be used as
 * the uniform number generator.
 * @param seed An arbitrary object used to seed the generator.
 * @constructor
 */
function RNG(seed)
{
	if (seed == null) {
		seed = (Math.random() + Date.now()).toString()
	}
	else if (Object.prototype.toString.call(seed) !== '[object String]') {
	    seed = JSON.stringify(seed);
	}
	this.seed = seed
	this._state = seed ? new RC4(seed) : null
}

/**
 * @return {number} Uniform random number between 0 and 255.
 */
RNG.prototype.nextByte = function() {
    return this._state.next();
}

/**
 * @return {number} Uniform random number between 0 and 1.
 */
RNG.prototype.uniform = function() {
    const BYTES = 7; // 56 bits to make a 53-bit double
    var output = 0;
    for (var i = 0; i < BYTES; i++) {
        output *= 256;
        output += this.nextByte();
    }
    return output / (Math.pow(2, BYTES * 8) - 1);
}

// Returns an integer in [0,max[
RNG.prototype.integer = function(max) { return Math.floor(max*this.uniform()) }

// Returns a random element of an array
RNG.prototype.pickInArray = function(arr) { return arr[this.integer(arr.length)] }


/*
 * RIFFWAVE.js v0.02 - Audio encoder for HTML5 <audio> elements.
 * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * The full license is available at http://www.gnu.org/licenses/gpl.html
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 *
 * Changelog:
 *
 * 0.01 - First release
 * 0.02 - New faster base64 encoding
 *
 */

var FastBase64_chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var FastBase64_encLookup = [];

function FastBase64_Init() {
  for (var i = 0; i < 4096; i++) {
    FastBase64_encLookup[i] = FastBase64_chars[i >> 6] + FastBase64_chars[i & 0x3F];
  }
}

function FastBase64_Encode(src) {
  var len = src.length;
  var dst = '';
  var i = 0;
  while (len > 2) {
    n = (src[i] << 16) | (src[i + 1] << 8) | src[i + 2];
    dst += FastBase64_encLookup[n >> 12] + FastBase64_encLookup[n & 0xFFF];
    len -= 3;
    i += 3;
  }
  if (len > 0) {
    var n1 = (src[i] & 0xFC) >> 2;
    var n2 = (src[i] & 0x03) << 4;
    if (len > 1) n2 |= (src[++i] & 0xF0) >> 4;
    dst += FastBase64_chars[n1];
    dst += FastBase64_chars[n2];
    if (len == 2) {
      var n3 = (src[i++] & 0x0F) << 2;
      n3 |= (src[i] & 0xC0) >> 6;
      dst += FastBase64_chars[n3];
    }
    if (len == 1) dst += '=';
    dst += '=';
  }
  return dst;
} // end Encode

FastBase64_Init();

function u32ToArray(i) { return [i & 0xFF, (i >> 8) & 0xFF, (i >> 16) & 0xFF, (i >> 24) & 0xFF]; }

function u16ToArray(i) { return [i & 0xFF, (i >> 8) & 0xFF]; }

function MakeRiff ( sampleRate, bitsPerSample,data) {
  var dat = [];
  var wav=[];
  var dataURI=[];

  var header = {                         // OFFS SIZE NOTES
    chunkId: [0x52, 0x49, 0x46, 0x46], // 0    4    "RIFF" = 0x52494646
    chunkSize: 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)
    format: [0x57, 0x41, 0x56, 0x45], // 8    4    "WAVE" = 0x57415645
    subChunk1Id: [0x66, 0x6d, 0x74, 0x20], // 12   4    "fmt " = 0x666d7420
    subChunk1Size: 16,                    // 16   4    16 for PCM
    audioFormat: 1,                     // 20   2    PCM = 1
    numChannels: 1,                     // 22   2    Mono = 1, Stereo = 2, etc.
    sampleRate: sampleRate,                  // 24   4    8000, 44100, etc
    byteRate: 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8
    blockAlign: 0,                     // 32   2    NumChannels*BitsPerSample/8
    bitsPerSample: bitsPerSample,                     // 34   2    8 bits = 8, 16 bits = 16, etc...
    subChunk2Id: [0x64, 0x61, 0x74, 0x61], // 36   4    "data" = 0x64617461
    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8
  };

  header.byteRate = (header.sampleRate * header.numChannels * header.bitsPerSample) >> 3;
  header.blockAlign = (header.numChannels * header.bitsPerSample) >> 3;
  header.subChunk2Size = data.length;
  header.chunkSize = 36 + header.subChunk2Size;

  wav = header.chunkId.concat(
      u32ToArray(header.chunkSize),
      header.format,
      header.subChunk1Id,
      u32ToArray(header.subChunk1Size),
      u16ToArray(header.audioFormat),
      u16ToArray(header.numChannels),
      u32ToArray(header.sampleRate),
      u32ToArray(header.byteRate),
      u16ToArray(header.blockAlign),
      u16ToArray(header.bitsPerSample),
      header.subChunk2Id,
      u32ToArray(header.subChunk2Size),
      data
    );
    
    dataURI = 'data:audio/wav;base64,' + FastBase64_Encode(wav);

    var result = {
      dat:dat,
      wav:wav,
      header:header,
      dataURI:dataURI
    };

    return result;
}


if (typeof exports != 'undefined')  // For node.js
  exports.RIFFWAVE = RIFFWAVE;



// ===== RANDOM SOUND GENERATORS =====

// These functions are used by the shound toolbar to generate the sound parameters from a seed,
// but they are also used in the engine by the function that plays the sound from its seed.
// It would be much better if the engine used the sound parameters generated from the seed, and avoided using the functions below.
// Indeed, they take a lot of place in the final game's code but are only useful from the point of view of the game's editor.

// Sound generation parameters are on [0,1] unless noted SIGNED, & thus [-1,1]
function Params()
{
	return {
		// Wave shape
		wave_type: SQUARE,

		// Envelope
		p_env_attack: 0.0,   // Attack time
		p_env_sustain: 0.3,  // Sustain time
		p_env_punch: 0.0,    // Sustain punch
		p_env_decay: 0.4,    // Decay time

		// Tone
		p_base_freq: 0.3,    // Start frequency
		p_freq_limit: 0.0,   // Min frequency cutoff
		p_freq_ramp: 0.0,    // Slide (SIGNED)
		p_freq_dramp: 0.0,   // Delta slide (SIGNED)
		// Vibrato
		p_vib_strength: 0.0, // Vibrato depth
		p_vib_speed: 0.0,    // Vibrato speed

		// Tonal change
		p_arp_mod: 0.0,      // Change amount (SIGNED)
		p_arp_speed: 0.0,    // Change speed

		// Duty (for square waves only, the value of the phase at which the waves goes back to zero)
		p_duty: 0.0,         // Square duty
		p_duty_ramp: 0.0,    // Duty sweep (SIGNED)

		// Repeat
		p_repeat_speed: 0.0, // Repeat speed

		// Phaser
		p_pha_offset: 0.0,   // Phaser offset (SIGNED)
		p_pha_ramp: 0.0,     // Phaser sweep (SIGNED)

		// Low-pass filter
		p_lpf_freq: 1.0,     // Low-pass filter cutoff
		p_lpf_ramp: 0.0,     // Low-pass filter cutoff sweep (SIGNED)
		p_lpf_resonance: 0.0,// Low-pass filter resonance
		// High-pass filter
		p_hpf_freq: 0.0,     // High-pass filter cutoff
		p_hpf_ramp: 0.0,     // High-pass filter cutoff sweep (SIGNED)

		// Sample parameters
		sound_vol: 0.5,
		sample_rate: 44100,
		bit_depth: 8,
	};
}

// This var is only used in this file
var rng

// These functions are only used in the generators bellow
function frnd(range)
{
	return range * rng.uniform()
}

function rnd(max)
{
	return rng.integer(max + 1)
}


pickupCoin = function()
{
	var result = Params();
	result.wave_type = Math.floor(frnd(SHAPES.length));
	if (result.wave_type === 3)
	{
		result.wave_type = 0;
	}
	result.p_base_freq = 0.4 + frnd(0.5);
	result.p_env_attack = 0.0;
	result.p_env_sustain = frnd(0.1);
	result.p_env_decay = 0.1 + frnd(0.4);
	result.p_env_punch = 0.3 + frnd(0.3);
	if (rnd(1))
	{
		result.p_arp_speed = 0.5 + frnd(0.2);
		var num = (frnd(7) | 1) + 1;
		var den = num + (frnd(7) | 1) + 2;
		result.p_arp_mod = (+num) / (+den); //0.2 + frnd(0.4);
	}
	return result;
};


laserShoot = function() {
	var result=Params();
	result.wave_type = rnd(2);
	if (result.wave_type === SINE && rnd(1))
		result.wave_type = rnd(1);
	result.wave_type = Math.floor(frnd(SHAPES.length));

	if (result.wave_type === 3) {
		result.wave_type = SQUARE;
	}

	result.p_base_freq = 0.5 + frnd(0.5);
	result.p_freq_limit = result.p_base_freq - 0.2 - frnd(0.6);
	if (result.p_freq_limit < 0.2) result.p_freq_limit = 0.2;
	result.p_freq_ramp = -0.15 - frnd(0.2);
	if (rnd(2) === 0)
	{
		result.p_base_freq = 0.3 + frnd(0.6);
		result.p_freq_limit = frnd(0.1);
		result.p_freq_ramp = -0.35 - frnd(0.3);
	}
	if (rnd(1))
	{
		result.p_duty = frnd(0.5);
		result.p_duty_ramp = frnd(0.2);
	}
	else
	{
		result.p_duty = 0.4 + frnd(0.5);
		result.p_duty_ramp = -frnd(0.7);
	}
	result.p_env_attack = 0.0;
	result.p_env_sustain = 0.1 + frnd(0.2);
	result.p_env_decay = frnd(0.4);
	if (rnd(1))
		result.p_env_punch = frnd(0.3);
	if (rnd(2) === 0)
	{
		result.p_pha_offset = frnd(0.2);
		result.p_pha_ramp = -frnd(0.2);
	}
	if (rnd(1))
		result.p_hpf_freq = frnd(0.3);

	return result;
};

explosion = function() {
	var result=Params();

	if (rnd(1)) {
		result.p_base_freq = 0.1 + frnd(0.4);
		result.p_freq_ramp = -0.1 + frnd(0.4);
	} else {
		result.p_base_freq = 0.2 + frnd(0.7);
		result.p_freq_ramp = -0.2 - frnd(0.2);
	}
	result.p_base_freq *= result.p_base_freq;
	if (rnd(4) === 0)
		result.p_freq_ramp = 0.0;
	if (rnd(2) === 0)
		result.p_repeat_speed = 0.3 + frnd(0.5);
	result.p_env_attack = 0.0;
	result.p_env_sustain = 0.1 + frnd(0.3);
	result.p_env_decay = frnd(0.5);
	if (rnd(1) === 0) {
		result.p_pha_offset = -0.3 + frnd(0.9);
		result.p_pha_ramp = -frnd(0.3);
	}
	result.p_env_punch = 0.2 + frnd(0.6);
	if (rnd(1)) {
		result.p_vib_strength = frnd(0.7);
		result.p_vib_speed = frnd(0.6);
	}
	if (rnd(2) === 0) {
		result.p_arp_speed = 0.6 + frnd(0.3);
		result.p_arp_mod = 0.8 - frnd(1.6);
	}

	return result;
};

birdSound = function()
{
	var result = Params();

	if (frnd(10) < 1)
	{
		result.wave_type = Math.floor(frnd(SHAPES.length));
		if (result.wave_type === 3)
		{
			result.wave_type = SQUARE;
		}
		result.p_env_attack = 0.4304400932967592 + frnd(0.2) - 0.1;
		result.p_env_sustain = 0.15739346034252394 + frnd(0.2) - 0.1;
		result.p_env_punch = 0.004488201744871758 + frnd(0.2) - 0.1;
		result.p_env_decay = 0.07478075528212291 + frnd(0.2) - 0.1;
		result.p_base_freq = 0.9865265720147687 + frnd(0.2) - 0.1;
		result.p_freq_limit = 0 + frnd(0.2) - 0.1;
		result.p_freq_ramp = -0.2995018224359539 + frnd(0.2) - 0.1;
		if (frnd(1.0) < 0.5)
		{
			result.p_freq_ramp = 0.1 + frnd(0.15);
		}
		result.p_freq_dramp = 0.004598608156964473 + frnd(0.1) - 0.05;
		result.p_vib_strength = -0.2202799497929496 + frnd(0.2) - 0.1;
		result.p_vib_speed = 0.8084998703158364 + frnd(0.2) - 0.1;
		result.p_arp_mod = 0;//-0.46410459213693644+frnd(0.2)-0.1;
		result.p_arp_speed = 0;//-0.10955361249587248+frnd(0.2)-0.1;
		result.p_duty = -0.9031808754347107 + frnd(0.2) - 0.1;
		result.p_duty_ramp = -0.8128699999808343 + frnd(0.2) - 0.1;
		result.p_repeat_speed = 0.6014860189319991 + frnd(0.2) - 0.1;
		result.p_pha_offset = -0.9424902314367765 + frnd(0.2) - 0.1;
		result.p_pha_ramp = -0.1055482222272056 + frnd(0.2) - 0.1;
		result.p_lpf_freq = 0.9989765717851521 + frnd(0.2) - 0.1;
		result.p_lpf_ramp = -0.25051720626043017 + frnd(0.2) - 0.1;
		result.p_lpf_resonance = 0.32777871505494693 + frnd(0.2) - 0.1;
		result.p_hpf_freq = 0.0023548750981756753 + frnd(0.2) - 0.1;
		result.p_hpf_ramp = -0.002375673204842568 + frnd(0.2) - 0.1;
		return result;
	}

	if (frnd(10) < 1)
	{
		result.wave_type = Math.floor(frnd(SHAPES.length));
		if (result.wave_type === 3)
		{
			result.wave_type = SQUARE;
		}
		result.p_env_attack = 0.5277795946672003 + frnd(0.2) - 0.1;
		result.p_env_sustain = 0.18243733568468432 + frnd(0.2) - 0.1;
		result.p_env_punch = -0.020159754546840117 + frnd(0.2) - 0.1;
		result.p_env_decay = 0.1561353422051903 + frnd(0.2) - 0.1;
		result.p_base_freq = 0.9028855606533718 + frnd(0.2) - 0.1;
		result.p_freq_limit = -0.008842787837148716;
		result.p_freq_ramp = -0.1;
		result.p_freq_dramp = -0.012891241489551925;
		result.p_vib_strength = -0.17923136138403065 + frnd(0.2) - 0.1;
		result.p_vib_speed = 0.908263385610142 + frnd(0.2) - 0.1;
		result.p_arp_mod = 0.41690153355414894 + frnd(0.2) - 0.1;
		result.p_arp_speed = 0.0010766233195860703 + frnd(0.2) - 0.1;
		result.p_duty = -0.8735363011184684 + frnd(0.2) - 0.1;
		result.p_duty_ramp = -0.7397985366747507 + frnd(0.2) - 0.1;
		result.p_repeat_speed = 0.0591789344172107 + frnd(0.2) - 0.1;
		result.p_pha_offset = -0.9961184222777699 + frnd(0.2) - 0.1;
		result.p_pha_ramp = -0.08234769395850523 + frnd(0.2) - 0.1;
		result.p_lpf_freq = 0.9412475115697335 + frnd(0.2) - 0.1;
		result.p_lpf_ramp = -0.18261358925834958 + frnd(0.2) - 0.1;
		result.p_lpf_resonance = 0.24541438107389477 + frnd(0.2) - 0.1;
		result.p_hpf_freq = -0.01831940280978611 + frnd(0.2) - 0.1;
		result.p_hpf_ramp = -0.03857383633171346 + frnd(0.2) - 0.1;
		return result;
	}
	
	if (frnd(10) < 1)
	{
		//result.wave_type = 4;
		result.wave_type = Math.floor(frnd(SHAPES.length));

		if (result.wave_type === 3)
		{
			result.wave_type = SQUARE;
		}
		result.p_env_attack = 0.4304400932967592 + frnd(0.2) - 0.1;
		result.p_env_sustain = 0.15739346034252394 + frnd(0.2) - 0.1;
		result.p_env_punch = 0.004488201744871758 + frnd(0.2) - 0.1;
		result.p_env_decay = 0.07478075528212291 + frnd(0.2) - 0.1;
		result.p_base_freq = 0.9865265720147687 + frnd(0.2) - 0.1;
		result.p_freq_limit = 0 + frnd(0.2) - 0.1;
		result.p_freq_ramp = -0.2995018224359539 + frnd(0.2) - 0.1;
		result.p_freq_dramp = 0.004598608156964473 + frnd(0.2) - 0.1;
		result.p_vib_strength = -0.2202799497929496 + frnd(0.2) - 0.1;
		result.p_vib_speed = 0.8084998703158364 + frnd(0.2) - 0.1;
		result.p_arp_mod = -0.46410459213693644 + frnd(0.2) - 0.1;
		result.p_arp_speed = -0.10955361249587248 + frnd(0.2) - 0.1;
		result.p_duty = -0.9031808754347107 + frnd(0.2) - 0.1;
		result.p_duty_ramp = -0.8128699999808343 + frnd(0.2) - 0.1;
		result.p_repeat_speed = 0.7014860189319991 + frnd(0.2) - 0.1;
		result.p_pha_offset = -0.9424902314367765 + frnd(0.2) - 0.1;
		result.p_pha_ramp = -0.1055482222272056 + frnd(0.2) - 0.1;
		result.p_lpf_freq = 0.9989765717851521 + frnd(0.2) - 0.1;
		result.p_lpf_ramp = -0.25051720626043017 + frnd(0.2) - 0.1;
		result.p_lpf_resonance = 0.32777871505494693 + frnd(0.2) - 0.1;
		result.p_hpf_freq = 0.0023548750981756753 + frnd(0.2) - 0.1;
		result.p_hpf_ramp = -0.002375673204842568 + frnd(0.2) - 0.1;
		return result;
	}

	if (frnd(5) > 1)
	{
		result.wave_type = Math.floor(frnd(SHAPES.length));

		if (result.wave_type === 3)
		{
			result.wave_type = SQUARE;
		}
		if (rnd(1))
		{
			result.p_arp_mod = 0.2697849293151393 + frnd(0.2) - 0.1;
			result.p_arp_speed = -0.3131172257760948 + frnd(0.2) - 0.1;
			result.p_base_freq = 0.8090588299313949 + frnd(0.2) - 0.1;
			result.p_duty = -0.6210022920964955 + frnd(0.2) - 0.1;
			result.p_duty_ramp = -0.00043441813553182567 + frnd(0.2) - 0.1;
			result.p_env_attack = 0.004321877246874195 + frnd(0.2) - 0.1;
			result.p_env_decay = 0.1 + frnd(0.2) - 0.1;
			result.p_env_punch = 0.061737781504416146 + frnd(0.2) - 0.1;
			result.p_env_sustain = 0.4987252564798832 + frnd(0.2) - 0.1;
			result.p_freq_dramp = 0.31700340314222614 + frnd(0.2) - 0.1;
			result.p_freq_limit = 0 + frnd(0.2) - 0.1;
			result.p_freq_ramp = -0.163380391341416 + frnd(0.2) - 0.1;
			result.p_hpf_freq = 0.4709005021145149 + frnd(0.2) - 0.1;
			result.p_hpf_ramp = 0.6924667290539194 + frnd(0.2) - 0.1;
			result.p_lpf_freq = 0.8351398631384511 + frnd(0.2) - 0.1;
			result.p_lpf_ramp = 0.36616557192873134 + frnd(0.2) - 0.1;
			result.p_lpf_resonance = -0.08685777111664439 + frnd(0.2) - 0.1;
			result.p_pha_offset = -0.036084571580025544 + frnd(0.2) - 0.1;
			result.p_pha_ramp = -0.014806445085568108 + frnd(0.2) - 0.1;
			result.p_repeat_speed = -0.8094368475518489 + frnd(0.2) - 0.1;
			result.p_vib_speed = 0.4496665457171294 + frnd(0.2) - 0.1;
			result.p_vib_strength = 0.23413762515532424 + frnd(0.2) - 0.1;
		}
		else
		{
			result.p_arp_mod = -0.35697118026766184 + frnd(0.2) - 0.1;
			result.p_arp_speed = 0.3581140690559588 + frnd(0.2) - 0.1;
			result.p_base_freq = 1.3260897696157528 + frnd(0.2) - 0.1;
			result.p_duty = -0.30984900436710694 + frnd(0.2) - 0.1;
			result.p_duty_ramp = -0.0014374759133411626 + frnd(0.2) - 0.1;
			result.p_env_attack = 0.3160357835682254 + frnd(0.2) - 0.1;
			result.p_env_decay = 0.1 + frnd(0.2) - 0.1;
			result.p_env_punch = 0.24323114016870148 + frnd(0.2) - 0.1;
			result.p_env_sustain = 0.4 + frnd(0.2) - 0.1;
			result.p_freq_dramp = 0.2866475886237244 + frnd(0.2) - 0.1;
			result.p_freq_limit = 0 + frnd(0.2) - 0.1;
			result.p_freq_ramp = -0.10956352368742976 + frnd(0.2) - 0.1;
			result.p_hpf_freq = 0.20772718017889846 + frnd(0.2) - 0.1;
			result.p_hpf_ramp = 0.1564090637378835 + frnd(0.2) - 0.1;
			result.p_lpf_freq = 0.6021372770637031 + frnd(0.2) - 0.1;
			result.p_lpf_ramp = 0.24016227139979027 + frnd(0.2) - 0.1;
			result.p_lpf_resonance = -0.08787383821160144 + frnd(0.2) - 0.1;
			result.p_pha_offset = -0.381597686151701 + frnd(0.2) - 0.1;
			result.p_pha_ramp = -0.0002481687661373495 + frnd(0.2) - 0.1;
			result.p_repeat_speed = 0.07812112809425686 + frnd(0.2) - 0.1;
			result.p_vib_speed = -0.13648848579133943 + frnd(0.2) - 0.1;
			result.p_vib_strength = 0.0018874158972302657 + frnd(0.2) - 0.1;
		}
		return result;
	}

	result.wave_type = Math.floor(frnd(SHAPES.length));//TRIANGLE;
	if (result.wave_type === 1 || result.wave_type === 3)
	{
		result.wave_type = 2;
	}
	result.p_base_freq = 0.85 + frnd(0.15);
	result.p_freq_ramp = 0.3 + frnd(0.15);
	//  result.p_freq_dramp = 0.3+frnd(2.0);

	result.p_env_attack = 0 + frnd(0.09);
	result.p_env_sustain = 0.2 + frnd(0.3);
	result.p_env_decay = 0 + frnd(0.1);

	result.p_duty = frnd(2.0) - 1.0;
	result.p_duty_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);

	result.p_repeat_speed = 0.5 + frnd(0.1);

	result.p_pha_offset = -0.3 + frnd(0.9);
	result.p_pha_ramp = -frnd(0.3);

	result.p_arp_speed = 0.4 + frnd(0.6);
	result.p_arp_mod = 0.8 + frnd(0.1);

	result.p_lpf_resonance = frnd(2.0) - 1.0;
	result.p_lpf_freq = 1.0 - Math.pow(frnd(1.0), 3.0);
	result.p_lpf_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
	if (result.p_lpf_freq < 0.1 && result.p_lpf_ramp < -0.05)
	{
		result.p_lpf_ramp = -result.p_lpf_ramp;
	}
	result.p_hpf_freq = Math.pow(frnd(1.0), 5.0);
	result.p_hpf_ramp = Math.pow(frnd(2.0) - 1.0, 5.0);

	return result;
}


pushSound = function() {
	var result=Params();
	result.wave_type = Math.floor(frnd(SHAPES.length));//TRIANGLE;
	if (result.wave_type === 2) {
		result.wave_type++;
	}
	if (result.wave_type === 0) {
		result.wave_type = NOISE;
	}
	//new
	result.p_base_freq = 0.1 + frnd(0.4);
	result.p_freq_ramp = 0.05 + frnd(0.2);

	result.p_env_attack = 0.01 + frnd(0.09);
	result.p_env_sustain = 0.01 + frnd(0.09);
	result.p_env_decay = 0.01 + frnd(0.09);

	result.p_repeat_speed = 0.3 + frnd(0.5);
	result.p_pha_offset = -0.3 + frnd(0.9);
	result.p_pha_ramp = -frnd(0.3);
	result.p_arp_speed = 0.6 + frnd(0.3);
	result.p_arp_mod = 0.8 - frnd(1.6);

	return result;
};



powerUp = function() {
	var result=Params();
	if (rnd(1))
		result.wave_type = SAWTOOTH;
	else
		result.p_duty = frnd(0.6);
	result.wave_type = Math.floor(frnd(SHAPES.length));
	if (result.wave_type === 3) {
		result.wave_type = SQUARE;
	}
	if (rnd(1))
	{
		result.p_base_freq = 0.2 + frnd(0.3);
		result.p_freq_ramp = 0.1 + frnd(0.4);
		result.p_repeat_speed = 0.4 + frnd(0.4);
	}
	else
	{
		result.p_base_freq = 0.2 + frnd(0.3);
		result.p_freq_ramp = 0.05 + frnd(0.2);
		if (rnd(1))
		{
			result.p_vib_strength = frnd(0.7);
			result.p_vib_speed = frnd(0.6);
		}
	}
	result.p_env_attack = 0.0;
	result.p_env_sustain = frnd(0.4);
	result.p_env_decay = 0.1 + frnd(0.4);

	return result;
};

hitHurt = function() {
	result = Params();
	result.wave_type = rnd(2);
	if (result.wave_type === SINE)
		result.wave_type = NOISE;
	if (result.wave_type === SQUARE)
		result.p_duty = frnd(0.6);
	result.wave_type = Math.floor(frnd(SHAPES.length));
	result.p_base_freq = 0.2 + frnd(0.6);
	result.p_freq_ramp = -0.3 - frnd(0.4);
	result.p_env_attack = 0.0;
	result.p_env_sustain = frnd(0.1);
	result.p_env_decay = 0.1 + frnd(0.2);
	if (rnd(1))
		result.p_hpf_freq = frnd(0.3);
	return result;
};


jump = function() {
	result = Params();
	result.wave_type = SQUARE;
	result.wave_type = Math.floor(frnd(SHAPES.length));
	if (result.wave_type === 3) {
		result.wave_type = SQUARE;
	}
	result.p_duty = frnd(0.6);
	result.p_base_freq = 0.3 + frnd(0.3);
	result.p_freq_ramp = 0.1 + frnd(0.2);
	result.p_env_attack = 0.0;
	result.p_env_sustain = 0.1 + frnd(0.3);
	result.p_env_decay = 0.1 + frnd(0.2);
	if (rnd(1))
		result.p_hpf_freq = frnd(0.3);
	if (rnd(1))
		result.p_lpf_freq = 1.0 - frnd(0.6);
	return result;
};

blipSelect = function() {
	result = Params();
	result.wave_type = rnd(1);
	result.wave_type = Math.floor(frnd(SHAPES.length));
	if (result.wave_type === 3) {
		result.wave_type = rnd(1);
	}
	if (result.wave_type === SQUARE)
		result.p_duty = frnd(0.6);
	result.p_base_freq = 0.2 + frnd(0.4);
	result.p_env_attack = 0.0;
	result.p_env_sustain = 0.1 + frnd(0.1);
	result.p_env_decay = frnd(0.2);
	result.p_hpf_freq = 0.1;
	return result;
};

random = function() {
	result = Params();
	result.wave_type = Math.floor(frnd(SHAPES.length));
	result.p_base_freq = Math.pow(frnd(2.0) - 1.0, 2.0);
	if (rnd(1))
		result.p_base_freq = Math.pow(frnd(2.0) - 1.0, 3.0) + 0.5;
	result.p_freq_limit = 0.0;
	result.p_freq_ramp = Math.pow(frnd(2.0) - 1.0, 5.0);
	if (result.p_base_freq > 0.7 && result.p_freq_ramp > 0.2)
		result.p_freq_ramp = -result.p_freq_ramp;
	if (result.p_base_freq < 0.2 && result.p_freq_ramp < -0.05)
		result.p_freq_ramp = -result.p_freq_ramp;
	result.p_freq_dramp = Math.pow(frnd(2.0) - 1.0, 3.0);
	result.p_duty = frnd(2.0) - 1.0;
	result.p_duty_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
	result.p_vib_strength = Math.pow(frnd(2.0) - 1.0, 3.0);
	result.p_vib_speed = frnd(2.0) - 1.0;
	result.p_env_attack = Math.pow(frnd(2.0) - 1.0, 3.0);
	result.p_env_sustain = Math.pow(frnd(2.0) - 1.0, 2.0);
	result.p_env_decay = frnd(2.0) - 1.0;
	result.p_env_punch = Math.pow(frnd(0.8), 2.0);
	if (result.p_env_attack + result.p_env_sustain + result.p_env_decay < 0.2) {
		result.p_env_sustain += 0.2 + frnd(0.3);
		result.p_env_decay += 0.2 + frnd(0.3);
	}
	result.p_lpf_resonance = frnd(2.0) - 1.0;
	result.p_lpf_freq = 1.0 - Math.pow(frnd(1.0), 3.0);
	result.p_lpf_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
	if (result.p_lpf_freq < 0.1 && result.p_lpf_ramp < -0.05)
		result.p_lpf_ramp = -result.p_lpf_ramp;
	result.p_hpf_freq = Math.pow(frnd(1.0), 5.0);
	result.p_hpf_ramp = Math.pow(frnd(2.0) - 1.0, 5.0);
	result.p_pha_offset = Math.pow(frnd(2.0) - 1.0, 3.0);
	result.p_pha_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
	result.p_repeat_speed = frnd(2.0) - 1.0;
	result.p_arp_speed = frnd(2.0) - 1.0;
	result.p_arp_mod = frnd(2.0) - 1.0;
	return result;
};

const generators = [
	pickupCoin,
	laserShoot,
	explosion,
	powerUp,
	hitHurt,
	jump,
	blipSelect,
	pushSound,
	random,
	birdSound
]

const generatorNames = [
	'pickupCoin',
	'laserShoot',
	'explosion',
	'powerUp',
	'hitHurt',
	'jump',
	'blipSelect',
	'pushSound',
	'random',
	'birdSound'
]

generateFromSeed = function(seed)
{
	var seedSplit = seed.toString().split(':')
	seed = seedSplit[0]
	var volume = seedSplit[1] / 10 || 1

	rng = new RNG( (seed / 100) | 0 );
	const generatorindex = seed % 100;
	const soundGenerator = generators[generatorindex % generators.length];
	var result = soundGenerator();

	result.sound_vol = volume * SOUND_VOL
	result.seed = seed;
	return result;
}


const SOUND_VOL = 0.25;
const MAX_SOUND_VOL = 39
const SAMPLE_RATE = 5512;
const BIT_DEPTH = 8;

const SQUARE = 0;
const SAWTOOTH = 1;
const SINE = 2;
const NOISE = 3;
const TRIANGLE = 4;
const BREAKER = 5;

const SHAPES = [ 'square', 'sawtooth', 'sine', 'noise', 'triangle', 'breaker' ];

var AUDIO_CONTEXT;

// Since 2015, all navigators support AudioContext, but Safari used a prefix until 2021
function checkAudioContextExists()
{
	try
	{
		if (AUDIO_CONTEXT == null)
		{
			if (typeof AudioContext != 'undefined')
			{
				AUDIO_CONTEXT = new AudioContext();
			}
			else if (typeof webkitAudioContext != 'undefined')
			{
				AUDIO_CONTEXT = new webkitAudioContext();
			}
		}
	}
	catch (ex)
	{
		window.console.log(ex)
	}
}

checkAudioContextExists();

// Playback volume
const masterVolume = 1.0;


function SoundEffect(length, sample_rate)
{
	this._buffer = AUDIO_CONTEXT.createBuffer(1, length, sample_rate);
}

SoundEffect.prototype.getBuffer = function()
{
	return this._buffer.getChannelData(0);
}


//unlock bullshit
function ULBS()
{
	if (AUDIO_CONTEXT.state === 'suspended')
	{
		var unlock = function()
		{
			AUDIO_CONTEXT.resume().then(function()
				{
					document.body.removeEventListener('touchstart', unlock);
					document.body.removeEventListener('touchend', unlock);
					document.body.removeEventListener('mousedown', unlock);
					document.body.removeEventListener('mouseup', unlock);
					document.body.removeEventListener('keydown', unlock);
					document.body.removeEventListener('keyup', unlock);
				}
			);
		};

		document.body.addEventListener('touchstart', unlock, false);
		document.body.addEventListener('touchend', unlock, false);
		document.body.addEventListener('mousedown', unlock, false);
		document.body.addEventListener('mouseup', unlock, false);
		document.body.addEventListener('keydown', unlock, false);
		document.body.addEventListener('keyup', unlock, false);
	}
}

SoundEffect.prototype.play = function()
{
	ULBS();

	var source = AUDIO_CONTEXT.createBufferSource();
	var filter1 = AUDIO_CONTEXT.createBiquadFilter(); // defaults to lowpass filter. What's the use of having three of them?
	var filter2 = AUDIO_CONTEXT.createBiquadFilter();
	var filter3 = AUDIO_CONTEXT.createBiquadFilter();

	source.buffer = this._buffer;
	source.connect(filter1);

	filter1.frequency.value = 1600;
	filter2.frequency.value = 1600;
	filter3.frequency.value = 1600;

	filter1.connect(filter2);
	filter2.connect(filter3);
	filter3.connect(AUDIO_CONTEXT.destination);
	const t = AUDIO_CONTEXT.currentTime;
	if (typeof source.start != 'undefined')
	{
		source.start(t);
	} else {
		source.noteOn(t);
	}
	source.onended = function()
	{
		filter3.disconnect()
	}
}

SoundEffect.MIN_SAMPLE_RATE = 22050;

// redefine the SoundEffect class in case AudioContext is not supported by the browser
if (typeof AUDIO_CONTEXT == 'undefined')
{
	SoundEffect = function SoundEffect(length, sample_rate)
	{
		this._sample_rate = sample_rate;
		this._buffer = new Array(length);
		this._audioElement = null;
	}

	SoundEffect.prototype.getBuffer = function()
	{
		this._audioElement = null;
		return this._buffer;
	}

	SoundEffect.prototype.play = function()
	{
		if (this._audioElement)
		{
			this._audioElement.cloneNode(false).play();
		} else {
			for (var i = 0; i < this._buffer.length; i++)
			{
				// bit_depth is always 8, rescale [-1.0, 1.0) to [0, 256)
				this._buffer[i] = 255 & Math.floor(128 * clamp(0, this._buffer[i] + 1, 2));
			}
			var wav = MakeRiff(this._sample_rate, BIT_DEPTH, this._buffer);
			this._audioElement = new Audio();
			this._audioElement.src = wav.dataURI;
			this._audioElement.play();
		}
	}

	SoundEffect.MIN_SAMPLE_RATE = 1;
}


// ===== EFFECTS =====

// ----- TONE -----

/* Sets a variable base period for the generator */
function ToneEffect(sound_params)
{
	// parameters
	this.fperiod = 100.0 / (sound_params.p_base_freq * sound_params.p_base_freq + 0.001)
	this.fmaxperiod = 100.0 / (sound_params.p_freq_limit * sound_params.p_freq_limit + 0.001)
	this.stop_at_max = (sound_params.p_freq_limit > 0.0)
	this.fdslide = -Math.pow(sound_params.p_freq_dramp, 3.0) * 0.000001
	this.initial_fslide = 1.0 - Math.pow(sound_params.p_freq_ramp, 3.0) * 0.01

	// state
	this.reset()
}

ToneEffect.prototype.reset = function()
{
	this.fslide = this.initial_fslide;
}

ToneEffect.prototype.tick = function(fperiod)
{
	this.fslide += this.fdslide
	const result = fperiod * this.fslide
	if (result > this.fmaxperiod)
	{
		return this.fmaxperiod;
	}
	return result;
}


// ----- ARPEGIO -----

/* Arpegio: multiplies the base period of the sound by a given factor, only once, after a given delay. */
function ArpegioEffect(sound_params)
{
	// parameters
	this.mod = (sound_params.p_arp_mod >= 0.0) ? (1.0 - Math.pow(sound_params.p_arp_mod, 2.0) * 0.9) : (1.0 + Math.pow(sound_params.p_arp_mod, 2.0) * 10.0)
	this.limit = (sound_params.p_arp_speed == 1.0) ? 0 : (Math.floor(Math.pow(1.0 - sound_params.p_arp_speed, 2.0) * 20000 + 32))

	// state
	this.reset()
}

ArpegioEffect.prototype.reset = function()
{
	this.not_yet_triggered = true
}

ArpegioEffect.prototype.tick = function(fperiod, t)
{
	if (this.not_yet_triggered && t >= this.limit)
	{
		this.not_yet_triggered = false
		return fperiod * this.mod;
	}
	return fperiod;
}


// ----- VIBRATO -----

function VibratoEffect(sound_params)
{
	this.phase = 0.0
	this.speed = Math.pow(sound_params.p_vib_speed, 2.0) * 0.01
	this.amp = sound_params.p_vib_strength * 0.5
}

VibratoEffect.prototype.tick = function(fperiod)
{
	if (this.amp > 0.0)
	{
		this.phase += this.speed
		return fperiod * (1.0 + Math.sin(this.phase) * this.amp);
	}
	return fperiod;
}


// ----- Wave -----

function WaveFunction(sound_params)
{
	// parameters
	this.initial_square_duty = 0.5 - sound_params.p_duty * 0.5
	this.square_slide = -sound_params.p_duty_ramp * 0.00005
	const wave_type = sound_params.wave_type
	this.wave_type = wave_type
	this.is_noise = (wave_type === NOISE)
	const wave_functions = [ this.square, this.sawtooth, this.sine, this.noise, this.triangle, this.breaker ]
	if (wave_type in wave_functions)
	{
		this.wave_function = wave_functions[wave_type]
		this.wave_function.bind(this)
	}
	else
		throw new Exception('bad wave type! ' + wave_type);

	// state
	this.phase = 0
	if (this.is_noise)
	{
		this.noise_buffer = []
		this.generateNoiseBuffer()
	}
	this.reset()
}

WaveFunction.prototype.reset = function()
{
	this.square_duty = this.initial_square_duty
}

WaveFunction.prototype.generateNoiseBuffer = function()
{
	for (var i = 0; i < 32; ++i)
		this.noise_buffer[i] = Math.random() * 2.0 - 1.0
}

// TODO: once again it should be a modification of the 'square_duty' parameter
WaveFunction.prototype.tick = function()
{
	this.square_duty = clamp(0.0, this.square_duty + this.square_slide, 0.5)
}

WaveFunction.prototype.subtick = function(period)
{
	this.phase += 1;
	if (this.phase >= period)
	{
		this.phase %= period;
		if (this.is_noise)
		{
			this.generateNoiseBuffer()
		}
	}

	// Base waveform
	return this.wave_function(this.phase / period);
}

WaveFunction.prototype.square = function(fp) { return (fp < this.square_duty) ? 0.5 : -0.5; }
WaveFunction.prototype.sawtooth = (fp) => (1.0 - fp * 2)
WaveFunction.prototype.sine = (fp) => Math.sin(fp * 2 * Math.PI)
WaveFunction.prototype.noise = function(fp) { return this.noise_buffer[Math.floor(fp * 32)]; }
WaveFunction.prototype.triangle = (fp) => (Math.abs(1 - fp * 2) - 1)
WaveFunction.prototype.breaker = (fp) => (Math.abs(1 - fp * fp * 2) - 1)



// ----- Envelope -----

function EnvelopeEffect(sound_params)
{
	// state
	// this.vol = 0.0
	this.stage = 0
	this.time = 0

	// parameters
	this.length = [
		Math.floor(sound_params.p_env_attack * sound_params.p_env_attack * 100000.0),
		Math.floor(sound_params.p_env_sustain * sound_params.p_env_sustain * 100000.0),
		Math.floor(sound_params.p_env_decay * sound_params.p_env_decay * 100000.0)
	]
	this.total_length = this.length[0] + this.length[1] + this.length[2]
	this.punch = sound_params.p_env_punch
}

EnvelopeEffect.prototype.tick = function()
{
	this.time++
	if (this.time > this.length[this.stage])
	{
		this.time = 1;
		this.stage++;
		while (this.stage < 3 && this.length[this.stage] === 0) // skip stages of length 0
			this.stage++;
		if (this.stage === 3)
			return null;
	}
	if (this.stage === 0)
		return this.time / this.length[0];
	if (this.stage === 1)
		return 1.0 + Math.pow(1.0 - this.time / this.length[1], 1.0) * 2.0 * this.punch;
	// this.stage == 2
	return 1.0 - this.time / this.length[2];
}


// ----- Phaser -----

/* Adds a short-delay (normally in the same phase) repetition of the signal to itself, with a varying delay. */
function PhaserEffect(sound_params)
{
	// definition
	this.fdphase = Math.pow(sound_params.p_pha_ramp, 2.0) * 1.0;
	if (sound_params.p_pha_ramp < 0.0)
		this.fdphase = -this.fdphase;

	// state
	this.fphase = Math.pow(sound_params.p_pha_offset, 2.0) * 1020.0;
	if (sound_params.p_pha_offset < 0.0)
		this.fphase = -this.fphase;
	this.iphase = Math.abs(Math.floor(this.fphase));
	this.ipp = 0;
	this.buffer = Array(1024).fill(0.0);
}

// increases the delay. Should actually probably be a different effect affecting the parameter 'iphase' of the PhaserEffect. This would avoid the need to have a 'subtick' method.
PhaserEffect.prototype.tick = function()
{
	this.fphase += this.fdphase;
	this.iphase = Math.min(1023, Math.abs(Math.floor(this.fphase)))
}

PhaserEffect.prototype.subtick = function(sub_sample)
{
	this.buffer[this.ipp & 1023] = sub_sample
	const result = sub_sample + this.buffer[(this.ipp - this.iphase + 1024) & 1023]
	this.ipp = (this.ipp + 1) & 1023
	return result;
}


// ----- Frequency Filters -----

function FrequencyFilterEffect(sound_params)
{
	// Parameters of the low-pass filter
	this.w = Math.pow(sound_params.p_lpf_freq, 3.0) * 0.1;
	this.dmp = Math.min(0.8, 5.0 / (1.0 + Math.pow(sound_params.p_lpf_resonance, 2.0) * 20.0) * (0.01 + this.w) )

	// state of the low-pass filter
	this.p = 0.0
	this.dp = 0.0

	// Parameters of the high-pass filter
	this.hp = Math.pow(sound_params.p_hpf_freq, 2.0) * 0.1;

	// state of the high-pass filter
	this.php = 0.0;

	// parameters for the variation of the actual parameters (should be treated as an effect affecting the parameters)
	this.w_d = 1.0 + sound_params.p_lpf_ramp * 0.0001;
	this.hp_d = 1.0 + sound_params.p_hpf_ramp * 0.0003;
	this.do_lowpass = (sound_params.p_lpf_freq != 1.0)
}

// increases or decreases the high pass filter strength. Should actually probably be a different effect affecting the parameter 'hp' of the FrequencyFilterEffect.
// This would avoid the need to have a 'subtick' method.
FrequencyFilterEffect.prototype.tick = function()
{
	if (this.hp_d != 0.0)
	{
		this.hp = clamp(0.00001, this.hp*this.hp_d, 0.1)
	}
}

FrequencyFilterEffect.prototype.subtick = function(sub_sample)
{
	const pp = this.p

	// Low-pass filter
	this.w = clamp(0.0, this.w * this.w_d, 0.1)
	if (this.do_lowpass)
	{
		this.dp += (sub_sample - this.p) * this.w
		this.dp -= this.dp * this.dmp
		this.p += this.dp
	}
	else
	{
		this.p = sub_sample
		this.dp = 0.0
	}

	// High-pass filter
	this.php += this.p - pp;
	this.php -= this.php * this.hp;
	return this.php;
}


// ===== GENERATE SOUND =====

SoundEffect.generate = function(ps)
{
/*  window.console.log(ps.wave_type + "\t" + ps.seed);

	var psstring="";
	for (var n in ps) {
		if (ps.hasOwnProperty(n)) {
			psstring = psstring +"result." + n+" = " + ps[n] + ";\n";
		}
	}
window.console.log(ps);
window.console.log(psstring);*/
	function repeat()
	{
		rep_time = 0;

		tone.reset()
		fperiod = tone.fperiod // TODO: we actually have a feedback loop, and should deal with it as such.
		period = Math.floor(fperiod)

		generator.reset()

		arpegio.reset() // should not change anything to comment that, because the effect is only activated once at a fixed time, even when there are repetitions.
	};

	var rep_time;
	var period;

	var tone = new ToneEffect(ps)
	var arpegio = new ArpegioEffect(ps)
	var vibrato = new VibratoEffect(ps)

	var generator = new WaveFunction(ps)
	var freq_filter = new FrequencyFilterEffect(ps)
	var envelope = new EnvelopeEffect(ps)
	var phaser = new PhaserEffect(ps)

	repeat();  // First time through, this is a bit of a misnomer

	// Repeat
	var rep_limit = Math.floor(Math.pow(1.0 - ps.p_repeat_speed, 2.0) * 20000
														 + 32);
	if (ps.p_repeat_speed == 0.0)
		rep_limit = 0;

	//var gain = 2.0 * Math.log(1 + (Math.E - 1) * ps.sound_vol);
	var gain = 2.0 * ps.sound_vol;
	var gain = Math.exp(ps.sound_vol) - 1;

	var num_clipped = 0;

	// ...end of initialization. Generate samples.

	// downsampler effect
	var sample_sum = 0;
	var num_summed = 0;
	var summands = Math.floor(44100 / ps.sample_rate);

	var buffer_i = 0;
	var buffer_length = Math.ceil(envelope.total_length / summands);

	var sound;
	if (ps.sample_rate < SoundEffect.MIN_SAMPLE_RATE) {
		// Assume 4x gets close enough to MIN_SAMPLE_RATE
		sound = new SoundEffect(4 * buffer_length, SoundEffect.MIN_SAMPLE_RATE);
	} else {
		sound = new SoundEffect(buffer_length, ps.sample_rate)
	}
	var buffer = sound.getBuffer();

	for (var t = 0; ; ++t)
	{

		// Repeats
		if (rep_limit != 0 && ++rep_time >= rep_limit)
			repeat();

		// Arpeggio (single)
		fperiod = arpegio.tick(fperiod, t) // TODO: fperiod is actually a member of ToneEffect

		// Frequency slide, and frequency slide slide!
		fperiod = tone.tick(fperiod)

		// Vibrato
		var rfperiod = vibrato.tick(fperiod)

		period = Math.max(8, Math.floor(rfperiod)) // period should be at least 8 because of the 8x supersampling

		generator.tick()

		// Volume envelope
		env_vol = envelope.tick()
		if (env_vol === null)
			break;

		// Phaser step
		phaser.tick()

		freq_filter.tick()

		// 8x supersampling
		var sample = 0.0;
		for (var si = 0; si < 8; ++si)
		{
			var sub_sample = generator.subtick(period)

			// Low-pass and High-pass filter
			sub_sample = freq_filter.subtick(sub_sample)

			// Phaser
			sub_sample = phaser.subtick(sub_sample)

			// final accumulation
			sample += sub_sample;
		}

		// envelope application
		sample *= env_vol;

		// Accumulate samples appropriately for sample rate
		sample_sum += sample;
		if (++num_summed < summands)
			continue;

		num_summed = 0;
		sample = sample_sum / summands;
		sample_sum = 0;

		sample = sample / 8 * masterVolume;
		sample *= gain;

		buffer[buffer_i++] = sample;

		if (ps.sample_rate < SoundEffect.MIN_SAMPLE_RATE) {
			buffer[buffer_i++] = sample;
			buffer[buffer_i++] = sample;
			buffer[buffer_i++] = sample;
		}
	}

	if (summands > 0) {
		sample = sample_sum / summands;

		sample = sample / 8 * masterVolume;
		sample *= gain;

		buffer[buffer_i++] = sample;

		if (ps.sample_rate < SoundEffect.MIN_SAMPLE_RATE) {
			buffer[buffer_i++] = sample;
			buffer[buffer_i++] = sample;
			buffer[buffer_i++] = sample;
		}
	}

	return sound;
};


// TODO: the rest of this file is technically not directly a part of sfxr and should be moved in engine/audio.js
var sfxCache = {};
var cachedSeeds = [];
var CACHE_MAX = 50;

function cacheSeed(seed){
	if (seed in sfxCache) {
		return sfxCache[seed];
	}

	var params = generateFromSeed(seed);
	params.sample_rate = SAMPLE_RATE;
	params.bit_depth = BIT_DEPTH;

	var sound = SoundEffect.generate(params);
	sfxCache[seed] = sound;
	cachedSeeds.push(seed);

	while (cachedSeeds.length>CACHE_MAX) {
		var toRemove=cachedSeeds[0];
		cachedSeeds = cachedSeeds.slice(1);
		delete sfxCache[toRemove];
	}

	return sound;
}


function playSound(seed) {
	if (muted){
		return;
	}
	checkAudioContextExists();
	if (unitTesting) return;
	cacheSeed(seed).play();
}



function killAudioButton(){
	var mb = document.getElementById("muteButton");
	var umb = document.getElementById("unMuteButton");
	if (mb){
		mb.remove();
		umb.remove();
	}
}

function showAudioButton(){
	var mb = document.getElementById("muteButton");
	var umb = document.getElementById("unMuteButton");
	if (mb){
		mb.style.display="block"; 
		umb.style.display="none";
	}
}


function toggleMute() {
	if (muted===0){
		muteAudio();
	} else {
		unMuteAudio();
	}
}

function muteAudio() {
	muted=1; 
	tryDeactivateYoutube();
	var mb = document.getElementById("muteButton");
	var umb = document.getElementById("unMuteButton");
	if (mb){
		mb.style.display="none"; 
		umb.style.display="block";
	}
}
function unMuteAudio() {
	muted=0; 
	tryActivateYoutube();
	var mb = document.getElementById("muteButton");
	var umb = document.getElementById("unMuteButton");
	if (mb){
		mb.style.display="block"; 
		umb.style.display="none";
	}
}

/*
 Code extracted from codemirror/codemirror.js that is used for parsing and is the only reason why PuzzleScript player had to include codemirror.
 */

function CodeMirrorStringStream(string, tabSize)
{
	this.pos = this.start = 0;
	this.string = string;
	this.tabSize = tabSize || 8;
	this.lastColumnPos = this.lastColumnValue = 0;
	this.lineStart = 0;
}

CodeMirrorStringStream.prototype = {
eol: function() {return this.pos >= this.string.length},
sol: function() {return this.pos == this.lineStart},
peek: function() {return this.string.charAt(this.pos) || undefined},
next: function()
{
	if (this.pos < this.string.length)
		return this.string.charAt(this.pos++)
},
eat: function(match)
{
	var ch = this.string.charAt(this.pos)
	if (typeof match == "string")
		var ok = ch == match
	else
		var ok = ch && (match.test ? match.test(ch) : match(ch));
	if (ok)
	{
		++this.pos;
		return ch;
	}
},
eatWhile: function(match)
{
	var start = this.pos
	while (this.eat(match)) { }
	return this.pos > start
},
skipToEnd: function() { this.pos = this.string.length },
skipTo: function(ch)
{
	const found = this.string.indexOf(ch, this.pos)
	if (found > -1)
	{
		this.pos = found
		return true
	}
},
match: function(pattern, consume, caseInsensitive)
{
	if (typeof pattern == "string")
	{
		var cased = (str) => (caseInsensitive ? str.toLowerCase() : str)
		var substr = this.string.substr(this.pos, pattern.length)
		if (cased(substr) == cased(pattern))
		{
			if (consume !== false)
				this.pos += pattern.length
			return true
		}
	}
	else
	{
		var match = this.string.slice(this.pos).match(pattern)
		if (match && match.index > 0) return null
		if (match && consume !== false)
			this.pos += match[0].length
		return match
	}
}
}


function isColor(str)
{
	str = str.trim()
	return ( (str in colorPalettes.arnecolors) || (/^#([0-9A-F]{3,8})$/i.test(str) && ([4,7,9]).includes(str.length) ) || (str === "transparent") )
}

function colorToHex(palette, str)
{
	str = str.trim()
	return (str in palette) ? palette[str]+'FF' : str
}

colorPalettesAliases = [ 'mastersystem', 'gameboycolour', 'amiga', 'arnecolors', 'famicom', 'atari', 'pastel', 'ega', 'amstrad', 'proteus_mellow', 'proteus_rich', 'proteus_night', 'c64', 'whitingjp' ]

colorPalettes = {
	mastersystem : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#555555",
	darkgrey		: "#555500",
	lightgrey		: "#AAAAAA",
	gray			: "#555555",
	darkgray		: "#555500",
	lightgray		: "#AAAAAA",
	red				: "#FF0000",
	darkred			: "#AA0000",
	lightred		: "#FF5555",
	brown			: "#AA5500",
	darkbrown		: "#550000",
	lightbrown		: "#FFAA00",
	orange			: "#FF5500",
	yellow 			: "#FFFF55",
	green			: "#55AA00",
	darkgreen		: "#005500",
	lightgreen		: "#AAFF00",
	blue			: "#5555AA",
	lightblue		: "#AAFFFF",
	darkblue		: "#000055",
	purple			: "#550055",
	pink			: "#FFAAFF"
	},

	gameboycolour : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#7F7F7C",
	darkgrey		: "#3E3E44",
	lightgrey		: "#BAA7A7",
	gray			: "#7F7F7C",
	darkgray		: "#3E3E44",
	lightgray		: "#BAA7A7",
	red				: "#A7120C",
	darkred			: "#880606",
	lightred		: "#BA381F",
	brown			: "#57381F",
	darkbrown		: "#3E2519",
	lightbrown		: "#8E634B",
	orange			: "#BA4B32",
	yellow 			: "#C0BA6F",
	green			: "#517525",
	darkgreen		: "#385D12",
	lightgreen		: "#6F8E44",
	blue			: "#5D6FA7",
	lightblue		: "#8EA7A7",
	darkblue		: "#4B575D",
	purple			: "#3E3E44",
	pink			: "#BA381F"
	},

	amiga : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#BBBBBB",
	darkgrey		: "#333333",
	lightgrey		: "#FFEEDD",
	gray			: "#BBBBBB",
	darkgray		: "#333333",
	lightgray		: "#FFEEDD",
	red				: "#DD1111",
	darkred			: "#990000",
	lightred		: "#FF4422",
	brown			: "#663311",
	darkbrown		: "#331100",
	lightbrown		: "#AA6644",
	orange			: "#FF6644",
	yellow 			: "#FFDD66",
	green			: "#448811",
	darkgreen		: "#335500",
	lightgreen		: "#88BB77",
	blue			: "#8899DD",
	lightblue		: "#BBDDEE",
	darkblue		: "#666688",
	purple			: "#665555",
	pink			: "#997788"
	},

	arnecolors : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#9d9d9d",
	darkgrey		: "#697175",
	lightgrey		: "#cccccc",
	gray			: "#9d9d9d",
	darkgray		: "#697175",
	lightgray		: "#cccccc",
	red				: "#be2633",
	darkred			: "#732930",
	lightred		: "#e06f8b",
	brown			: "#a46422",
	darkbrown		: "#493c2b",
	lightbrown		: "#eeb62f",
	orange			: "#eb8931",
	yellow 			: "#f7e26b",
	green			: "#44891a",
	darkgreen		: "#2f484e",
	lightgreen		: "#a3ce27",
	blue			: "#1d57f7",
	lightblue		: "#B2DCEF",
	darkblue		: "#1B2632",
	purple			: "#342a97",
	pink			: "#de65e2"
	},
	famicom : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#7c7c7c",
	darkgrey		: "#080808",
	lightgrey		: "#bcbcbc",
	gray			: "#7c7c7c",
	darkgray		: "#080808",
	lightgray		: "#bcbcbc",
	red				: "#f83800",
	darkred			: "#881400",
	lightred		: "#f87858",
	brown			: "#AC7C00",
	darkbrown		: "#503000",
	lightbrown		: "#FCE0A8",
	orange			: "#FCA044",
	yellow 			: "#F8B800",
	green			: "#00B800",
	darkgreen		: "#005800",
	lightgreen		: "#B8F8B8",
	blue			: "#0058F8",
	lightblue		: "#3CBCFC",
	darkblue		: "#0000BC",
	purple			: "#6644FC",
	pink			: "#F878F8"
	},

	atari : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#909090",
	darkgrey		: "#404040",
	lightgrey		: "#b0b0b0",
	gray			: "#909090",
	darkgray		: "#404040",
	lightgray		: "#b0b0b0",
	red				: "#A03C50",
	darkred			: "#700014",
	lightred		: "#DC849C",
	brown			: "#805020",
	darkbrown		: "#703400",
	lightbrown		: "#CB9870",
	orange			: "#CCAC70",
	yellow 			: "#ECD09C",
	green			: "#58B06C",
	darkgreen		: "#006414",
	lightgreen		: "#70C484",
	blue			: "#1C3C88",
	lightblue		: "#6888C8",
	darkblue		: "#000088",
	purple			: "#3C0080",
	pink			: "#B484DC"
	},
	pastel : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#3e3e3e",
	darkgrey		: "#313131",
	lightgrey		: "#9cbcbc",
	gray			: "#3e3e3e",
	darkgray		: "#313131",
	lightgray		: "#9cbcbc",
	red				: "#f56ca2",
	darkred			: "#a63577",
	lightred		: "#ffa9cf",
	brown			: "#b58c53",
	darkbrown		: "#787562",
	lightbrown		: "#B58C53",
	orange			: "#EB792D",
	yellow 			: "#FFe15F",
	green			: "#00FF4F",
	darkgreen		: "#2b732c",
	lightgreen		: "#97c04f",
	blue			: "#0f88d3",
	lightblue		: "#00fffe",
	darkblue		: "#293a7b",
	purple			: "#ff6554",
	pink			: "#eb792d"
	},
	ega : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#555555",
	darkgrey		: "#555555",
	lightgrey		: "#aaaaaa",
	gray			: "#555555",
	darkgray		: "#555555",
	lightgray		: "#aaaaaa",
	red				: "#ff5555",
	darkred			: "#aa0000",
	lightred		: "#ff55ff",
	brown			: "#aa5500",
	darkbrown		: "#aa5500",
	lightbrown		: "#ffff55",
	orange			: "#ff5555",
	yellow 			: "#ffff55",
	green			: "#00aa00",
	darkgreen		: "#00aaaa",
	lightgreen		: "#55ff55",
	blue			: "#5555ff",
	lightblue		: "#55ffff",
	darkblue		: "#0000aa",
	purple			: "#aa00aa",
	pink			: "#ff55ff"
	},


	proteus_mellow : {
	black   		: "#3d2d2e",
	white			: "#ddf1fc",
	grey			: "#9fb2d4",
	darkgrey		: "#7b8272",
	lightgrey		: "#a4bfda",
	gray			: "#9fb2d4",
	darkgray		: "#7b8272",
	lightgray		: "#a4bfda",
	red				: "#9d5443",
	darkred			: "#8c5b4a",
	lightred		: "#94614c",
	brown			: "#89a78d",
	darkbrown		: "#829e88",
	lightbrown		: "#aaae97",
	orange			: "#d1ba86",
	yellow 			: "#d6cda2",
	green			: "#75ac8d",
	darkgreen		: "#8fa67f",
	lightgreen		: "#8eb682",
	blue			: "#88a3ce",
	lightblue		: "#a5adb0",
	darkblue		: "#5c6b8c",
	purple			: "#d39fac",
	pink			: "#c8ac9e"
	},
	

	proteus_night : {
	black   		: "#010912",
	white			: "#fdeeec",
	grey			: "#051d40",
	darkgrey		: "#091842",
	lightgrey		: "#062151",
	gray			: "#051d40",
	darkgray		: "#091842",
	lightgray		: "#062151",
	red				: "#ad4576",
	darkred			: "#934765",
	lightred		: "#ab6290",
	brown			: "#61646b",
	darkbrown		: "#3d2d2d",
	lightbrown		: "#8393a0",
	orange			: "#0a2227",
	yellow 			: "#0a2541",
	green			: "#75ac8d",
	darkgreen		: "#0a2434",
	lightgreen		: "#061f2e",
	blue			: "#0b2c79",
	lightblue		: "#809ccb",
	darkblue		: "#08153b",
	purple			: "#666a87",
	pink			: "#754b4d"
	},
	


	proteus_rich: {
	black   		: "#6f686f",
	white			: "#d1b1e2",
	grey			: "#b9aac1",
	darkgrey		: "#8e8b84",
	lightgrey		: "#c7b5cd",
	gray			: "#b9aac1",
	darkgray		: "#8e8b84",
	lightgray		: "#c7b5cd",
	red				: "#a11f4f",
	darkred			: "#934765",
	lightred		: "#c998ad",
	brown			: "#89867d",
	darkbrown		: "#797f75",
	lightbrown		: "#ab9997",
	orange			: "#ce8c5c",
	yellow 			: "#f0d959",
	green			: "#75bc54",
	darkgreen		: "#599d79",
	lightgreen		: "#90cf5c",
	blue			: "#8fd0ec",
	lightblue		: "#bcdce7",
	darkblue		: "#0b2c70",
	purple			: "#9b377f",
	pink			: "#cd88e5"
	},
	

	
amstrad : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#7f7f7f",
	darkgrey		: "#636363",
	lightgrey		: "#afafaf",
	gray			: "#7f7f7f",
	darkgray		: "#636363",
	lightgray		: "#afafaf",
	red				: "#ff0000",
	darkred			: "#7f0000",
	lightred		: "#ff7f7f",
	brown			: "#ff7f00",
	darkbrown		: "#7f7f00",
	lightbrown		: "#ffff00",
	orange			: "#ff007f",
	yellow 			: "#ffff7f",
	green			: "#01ff00",
	darkgreen		: "#007f00",
	lightgreen		: "#7fff7f",
	blue			: "#0000ff",
	lightblue		: "#7f7fff",
	darkblue		: "#00007f",
	purple			: "#7f007f",
	pink			: "#ff7fff"
	},
c64 : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#6C6C6C",
	darkgrey		: "#444444",
	lightgrey		: "#959595",
	gray			: "#6C6C6C",
	darkgray		: "#444444",
	lightgray		: "#959595",
	red				: "#68372B",
	darkred			: "#3f1e17",
	lightred		: "#9A6759",
	brown			: "#433900",
	darkbrown		: "#221c02",
	lightbrown		: "#6d5c0d",
	orange			: "#6F4F25",
	yellow 			: "#B8C76F",
	green			: "#588D43",
	darkgreen		: "#345129",
	lightgreen		: "#9AD284",
	blue			: "#6C5EB5",
	lightblue		: "#70A4B2",
	darkblue		: "#352879",
	purple			: "#6F3D86",
	pink			: "#b044ac"
},
whitingjp : {
  black       : "#202527",
  white       : "#eff8fd",
  grey        : "#7b7680",
  darkgrey    : "#3c3b44",
  lightgrey   : "#bed0d7",
  gray        : "#7b7680",
  darkgray    : "#3c3b44",
  lightgray   : "#bed0d7",
  red         : "#bd194b",
  darkred     : "#6b1334",
  lightred    : "#ef2358",
  brown       : "#b52e1c",
  darkbrown   : "#681c12",
  lightbrown  : "#e87b45",
  orange      : "#ff8c10",
  yellow      : "#fbd524",
  green       : "#36bc3c",
  darkgreen   : "#317610",
  lightgreen  : "#8ce062",
  blue        : "#3f62c6",
  lightblue   : "#57bbe0",
  darkblue    : "#2c2fa0",
  purple      : "#7037d9",
  pink        : "#ec2b8f"
}
};

var reg_color_names = /(black|white|darkgray|lightgray|gray|grey|darkgrey|lightgrey|red|darkred|lightred|brown|darkbrown|lightbrown|orange|yellow|green|darkgreen|lightgreen|blue|lightblue|darkblue|purple|pink|transparent)\b/
var reg_color = /(black|white|gray|darkgray|lightgray|grey|darkgrey|lightgrey|red|darkred|lightred|brown|darkbrown|lightbrown|orange|yellow|green|darkgreen|lightgreen|blue|lightblue|darkblue|purple|pink|transparent|#(?:[0-9a-f]{3}){1,2})\b/








var all_screen_types = []

// Base class, implements an empty screen
function EmptyScreen(screen_type = 'empty')
{
	this.screen_type = screen_type
	this.noAutoTick = true
	this.noSwipe = false
	this.alwaysAllowUndo = false
	this.dontDoWin = false
	all_screen_types.push(this)
}
EmptyScreen.prototype.get_virtual_screen_size = () => [ 0, 0 ]
EmptyScreen.prototype.redraw_virtual_screen = (ctx) => null
EmptyScreen.prototype.leftMouseClick = (e) => false
EmptyScreen.prototype.rightMouseClick = (e) => false
EmptyScreen.prototype.mouseMove = (e) => null
EmptyScreen.prototype.checkKey = (e, inputdir) => false
EmptyScreen.prototype.checkRepeatableKey = (e, inputdir) => false
var empty_screen = new EmptyScreen()


// Text screen
function TextModeScreen(screen_type = 'text')
{
	EmptyScreen.call(this, screen_type)
	this.text = []
	this.done = false // not yet pressed the key that would leave the screen
}
TextModeScreen.prototype = Object.create(EmptyScreen.prototype)
TextModeScreen.prototype.get_nb_tiles = () => [ terminal_width, terminal_height ]
TextModeScreen.prototype.get_virtual_screen_size = () => [ terminal_width*(font_width+1), terminal_height*(font_height+1) ]
var msg_screen = new TextModeScreen()

// Menu screen, based on TextModeScreen
function MenuScreen(open_soundname, select_soundname)
{
	TextModeScreen.call(this, 'menu')
	this.menu_items = []
	this.item = 0 //which item is currently highlighted/selected
	this.open_soundname = open_soundname
	this.select_soundname = select_soundname
}
MenuScreen.prototype = Object.create(TextModeScreen.prototype)
var pause_menu_screen = new MenuScreen('pausescreen')
var title_screen = new MenuScreen('gamescreen', 'startgame')

// Level screen, also base class for flickscreen and zoomscreen
function LevelScreen(screen_type = 'level')
{
	EmptyScreen.call(this, screen_type)
	this.noAutoTick = false
}
LevelScreen.prototype = Object.create(EmptyScreen.prototype)
LevelScreen.prototype.get_nb_tiles = () => [ this.level.width, this.level.height ]
LevelScreen.prototype.get_virtual_screen_size = function()
{
	const [w,h] = this.get_nb_tiles()
	return [ w*sprite_width, h*sprite_height ];
}
LevelScreen.prototype.get_viewport = () => [0, 0, this.level.width, this.level.height]
var level_screen = new LevelScreen()

// Flick screen, also base class for zoomscreen (could be the reverse, it's just to reuse the methods)
function TiledWorldScreen(screen_type = 'flickscreen') { LevelScreen.call(this, screen_type) }
TiledWorldScreen.prototype = Object.create(LevelScreen.prototype)
TiledWorldScreen.prototype.get_nb_tiles = () => state.metadata.flickscreen
TiledWorldScreen.prototype.get_viewport = function()
{
	// TODO: oldflickscreendat is a global variable because it needs to be recorded for undos
	const [w, h] = this.get_nb_tiles()
	const playerPositions = this.level.getPlayerPositions()
	if ( (playerPositions.length === 0) && (oldflickscreendat !== undefined) )
		return oldflickscreendat

	const playerPosition = playerPositions[0] || 0
	const [px, py] = this.level.cellCoord(playerPosition)

	const [mini, minj] = this.get_viewport_for_focus_point(px, py, w, h)
	const maxi = Math.min(mini + w, this.level.width)
	const maxj = Math.min(minj + h, this.level.height)
	oldflickscreendat = [mini, minj, maxi, maxj]
	return oldflickscreendat
}
TiledWorldScreen.prototype.get_viewport_for_focus_point = (px, py, w, h) => [ Math.floor(px/w) * w, Math.floor(py/h) * h ]
var tiled_world_screen = new TiledWorldScreen()


// Zoom screen
function CameraOnPlayerScreen() { TiledWorldScreen.call(this, 'zoomscreen') }
CameraOnPlayerScreen.prototype = Object.create(TiledWorldScreen.prototype)
CameraOnPlayerScreen.prototype.get_nb_tiles = function()
{
	const [w, h] = state.metadata.zoomscreen
	return [ Math.min(w, this.level.width), Math.min(h, this.level.height) ]
}
CameraOnPlayerScreen.prototype.get_viewport_for_focus_point = (px, py, w, h) => [
	clamp(0, px - Math.floor(w/2), this.level.width  - w),
	clamp(0, py - Math.floor(h/2), this.level.height - h)
]
var camera_on_player_screen = new CameraOnPlayerScreen()


// Main screen: has a virtual screen for content, magnifies and centers it
function ScreenLayout()
{
	// content of the virtual screen
	this.content = title_screen
	// layout parameters
	this.magnification = 0
	this.margins = [0, 0]
}

ScreenLayout.prototype.resize = function(canvas_size)
{
	// Update layout parameters
	[this.magnification, this.margins] = centerAndMagnify(this.content.get_virtual_screen_size(), canvas_size)
}

ScreenLayout.prototype.leftMouseClick = function(event) { return this.content.leftMouseClick(event); }
ScreenLayout.prototype.rightMouseClick = function(event) { return this.content.rightMouseClick(event); }
ScreenLayout.prototype.mouseMove = function(event) { return this.content.mouseMove(event); }
ScreenLayout.prototype.checkKey = function(event, inputdir) { return this.content.checkKey(event, inputdir); }
ScreenLayout.prototype.checkRepeatableKey = function(event, inputdir) { return this.content.checkRepeatableKey(event, inputdir); }
ScreenLayout.prototype.noAutoTick = function() { return this.content.noAutoTick; }
ScreenLayout.prototype.noSwipe = function() { return this.content.noSwipe; }
ScreenLayout.prototype.alwaysAllowUndo = function() { return this.content.alwaysAllowUndo; }
ScreenLayout.prototype.dontDoWin = function() { return this.content.dontDoWin; }

var screen_layout = new ScreenLayout()


function centerAndMagnify(content_size, container_size)
{
	const pixel_sizes = content_size.map( (s, i) => (container_size[i] / s) )
	const magnification = Math.max(1, Math.floor(Math.min(...pixel_sizes)) )
	return [ magnification, container_size.map( (s, i) => Math.floor( (s - content_size[i]*magnification)/2 ) ) ];
}

var canvasdict = {}

function makeSpriteCanvas(name, width=sprite_width, height=sprite_height)
{
	var canvas
	if (name in canvasdict)
	{
		canvas = canvasdict[name]
	}
	else
	{
		canvas = document.createElement('canvas')
		canvasdict[name] = canvas
	}
	canvas.width  = width
	canvas.height = height
	return canvas
}

function createSprite(name, spritegrid, colors, margins, mag = 1, offset = [0,0])
{
	if (colors === undefined)
	{
		colors = [state.bgcolor, state.fgcolor]
	}
	if (margins === undefined)
	{
		margins = [0, 0]
	}

	const sprite_w = spritegrid.reduce( (m, line) => Math.max(m, line.length), 0 )
	const sprite_h = spritegrid.length

	var sprite = makeSpriteCanvas(name, sprite_w, sprite_h)
	sprite.offset = offset

	var spritectx = sprite.getContext('2d')
	spritectx.clearRect(0, 0, sprite_w, sprite_h)
	spritectx.fillStyle = state.fgcolor
	spritectx.translate(margins[0]*mag, margins[1]*mag)
	for (const [j, line] of spritegrid.entries())
	{
		for (const [k, val] of line.entries())
		{
			if (val >= 0)
			{
				spritectx.fillStyle = colors[val]
				spritectx.fillRect(Math.floor(k*mag), Math.floor(j*mag), mag, mag)
			}
		}
	}

	return sprite;
}

function forceRegenImages()
{
	regenSpriteImages()
}

var spriteimages = []
function regenSpriteImages()
{
	spriteimages = []

	for (var i = 0; i < sprites.length; i++)
	{
		if (sprites[i] !== undefined)
		{
			spriteimages[i] = createSprite(i.toString(), sprites[i].dat, sprites[i].colors, undefined, undefined, sprites[i].offset)
		}
	}
}


// ==========
// REDRAW
// ==========

TextModeScreen.prototype.redraw_virtual_screen = function(ctx)
{
	const char_width  = font_width
	const char_height = font_height
	const grid_width  = (1+font_width)
	const grid_height = (1+font_height)
	for (const [j, [line, color]] of this.text.entries() )
	{
		const f = font.colored_font(color)
		if (f === null)
			return
		for (var i = 0; i < line.length; i++)
		{
			draw_char(ctx, f, line.charAt(i), i*grid_width, j*grid_height, char_width, char_height)
		}
	}
}

LevelScreen.prototype.redraw_virtual_screen = function(ctx)
{
	const [ mini, minj, maxi, maxj ] = this.get_viewport()
	const [ size_x, size_y ] = [ maxi-mini, maxj-minj ]

	for (const layer_group of state.collision_layer_groups)
	{
		const Δhoriz = layer_group.leftward ? -sprite_width  : sprite_width
		const Δvert  = layer_group.upward   ? -sprite_height : sprite_height
		const Δi_horiz = layer_group.leftward ? -this.level.height : this.level.height
		const Δi_vert  = layer_group.upward ? -1 : 1
		const initial_col = layer_group.leftward ? size_x-1 : 0
		const initial_row = layer_group.upward   ? size_y-1 : 0

		const [ size1, size2 ] = layer_group.horizontal_first ? [ size_x, size_y ] : [ size_y, size_x ]
		const [ Δx1, Δy1, Δx2, Δy2 ] = layer_group.horizontal_first ? [ Δhoriz, 0, 0, Δvert ] : [ 0, Δvert, Δhoriz, 0 ]
		const [ Δi1, Δi2 ] = layer_group.horizontal_first ? [ Δi_horiz, Δi_vert] : [ Δi_vert, Δi_horiz ]

		let x2 = initial_col*sprite_width
		let y2 = (initial_row+1)*sprite_height
		let i2 = (minj+initial_row) + (mini+initial_col)*this.level.height

		for (let counter2 = size2; counter2 > 0; counter2--)
		{
			let i1 = i2
			let x1 = x2
			let y1 = y2
			for (let counter1 = size1; counter1 > 0; counter1--)
			{
				this.level.mapCellObjects(
					i1,
					function(k) {
						if ( (k >= layer_group.first_id) && (k <= layer_group.last_id) )
							ctx.drawImage(spriteimages[k], x1+spriteimages[k].offset[0], y1+spriteimages[k].offset[1]-spriteimages[k].height)
					}
				)
				i1 += Δi1
				x1 += Δx1
				y1 += Δy1
			}
			i2 += Δi2
			x2 += Δx2
			y2 += Δy2
		}
	}
}

ScreenLayout.prototype.init_graphics = function(canvas_id = 'gameCanvas')
{
	this.canvas = document.getElementById(canvas_id)
	this.ctx = this.canvas.getContext('2d')
	this.virtual_screen_canvas = document.createElement('canvas')
	this.vc_ctx = this.virtual_screen_canvas.getContext('2d')
}
screen_layout.init_graphics()

// creates a buffer. To save memory, use rescale_canvas_into.
function rescale_canvas(m, ctx_from, ctx_to, w, h, margins)
{
	const scaled_imagedata = ctx_to.getImageData(margins[0], margins[1], w*m, h*m)
	rescale_canvas_into(m, ctx_from, scaled_imagedata.data, w, h)
	return scaled_imagedata
}

function rescale_canvas_into(m, ctx_from, pixels, w, h)
{
	const vc_pixels = ctx_from.getImageData(0, 0, w, h).data

	const delta_j = w*m*4
	for (var y=0, i=0, j=0; y<h; ++y)
	{
		const jstart = j
		for (var x=0; x<w; ++x, i+=4)
		{
			for (var x2=0; x2<m; ++x2, j+=4)
			{
				pixels[j  ] = vc_pixels[i  ]
				pixels[j+1] = vc_pixels[i+1]
				pixels[j+2] = vc_pixels[i+2]
				pixels[j+3] = vc_pixels[i+3]
			}
		}
		const jend = j
		for (var y2=1; y2<m; ++y2, j+=delta_j)
		{
			pixels.copyWithin(j, jstart, jend)
		}
	}
	return
}

ScreenLayout.prototype.redraw = function()
{
	if (this.magnification === 0)
		return

	// Draw virtual screen's content
	this.vc_ctx.fillStyle = state.bgcolor
	this.vc_ctx.fillRect(0, 0, this.virtual_screen_canvas.width, this.virtual_screen_canvas.height)
	this.content.redraw_virtual_screen(this.vc_ctx)

	// Center screen content
	this.ctx.save()
	this.ctx.translate(this.margins[0], this.margins[1])

	// Draw content
	if (this.magnification == 1)
	{
		this.ctx.drawImage(this.virtual_screen_canvas, 0, 0)
	}
	else
	{
		this.ctx.scale(this.magnification, this.magnification)
		rescale_canvas_into(this.magnification, this.vc_ctx, this.scaled_imagedata.data, this.virtual_screen_canvas.width, this.virtual_screen_canvas.height, this.margins)
		this.ctx.putImageData(this.scaled_imagedata, ...this.margins)
	}

	this.ctx.restore()
}

function redraw()
{
	screen_layout.redraw()
}


// ==========
// RESIZE
// ==========

ScreenLayout.prototype.resize_canvas = function(pixel_ratio)
{
	// Resize canvas
	const c = this.canvas
	c.width  = pixel_ratio * c.parentNode.clientWidth
	c.height = pixel_ratio * c.parentNode.clientHeight
	this.resize( [c.width, c.height] )

	// clear background
	this.ctx.fillStyle = state.bgcolor
	this.ctx.fillRect(0, 0, c.width, c.height)

	// Resize virtual canvas
	const vc = this.virtual_screen_canvas
	const vc_size = this.content.get_virtual_screen_size()
	vc.width  = vc_size[0]
	vc.height = vc_size[1]

	// Get the pixel buffer that we will use
	this.scaled_imagedata = this.ctx.getImageData(this.margins[0], this.margins[1], vc_size[0]*this.magnification, vc_size[1]*this.magnification)

	this.redraw()
}

function canvasResize()
{
	const pixel_ratio = window.devicePixelRatio || 1
	screen_layout.resize_canvas(pixel_ratio)
}

window.addEventListener('resize', canvasResize, false)




const error_messages = { // actually also warning messages

	// identifiers.js
	// ==============

	identifier_name_is_keyword: (candname) => 'You named an object "' + candname.toUpperCase() + '", but this is a keyword. Don\'t do that!',
	identifier_already_defined: (candname, definition_string, l) => 'Object "' + candname.toUpperCase() + '" already defined' + definition_string + ' on ' + makeLinkToLine(l, 'line ' + l.toString()),
	wrong_identifier_type_generic: (identifier, identifier_type, accepted_types_descr) => 'You cannot use '+identifier.toUpperCase()+' here because it is ' + identifier_type_as_text[identifier_type] + ' but I was expecting ' + accepted_types_descr,

	// compiler.js
	// ===========

	// generateExtraMembers
	no_collision_layers: 'No collision layers defined.  All objects need to be in collision layers.',
	too_many_sprite_colors: 'Colors are identified by digits in the sprite matrix, so you cannot use more than 10.',
	no_palette_in_object: object_name => 'Colors not specified for object "' + object_name +'".',
	no_object: 'You need to have some objects defined',
	no_background: 'You have to define something to be the background',
	background_is_aggregate: "Background cannot be an aggregate (declared with 'and'), it has to be a simple type, or property (declared in terms of others using 'or').",

	// ruleToMask
	no_matching_ellipsis_in_RHS: 'An ellipsis on the left must be matched by one in the corresponding place on the right.',
	no_matching_ellipsis_in_LHS: 'An ellipsis on the right must be matched by one in the corresponding place on the left.',
	no_layer_for_object: object_name => 'Oops! ' +object_name.toUpperCase()+' not assigned to a layer.',
	rule_cannot_match_anything: 'This rule will never match anything, because it requires the presence of an entity that has been excluded by a NO.',
	spawn_aggregate: object_name => 'You want to spawn a random "' + object_name.toUpperCase() + '", but I don\'t know how to do that.',
	cant_overlap: (object_name1, object_name2) => 'Rule matches object types that can\'t overlap: "' + object_name1.toUpperCase() + '" and "' + object_name2.toUpperCase() + '".',

	// generateMasks
	no_player_defined: "Error, didn't find any object called player, either in the objects section, or the legends section. there must be a player!",

	// tokenizeWinConditionIdentifier
	unknown_object_in_wincondition: n => 'Unknown object name "' + n +'" found in win condition.',
	invalid_object_in_wincondition: (n, type) => 'Invalid object name found in win condition: ' + n + ' is ' + type + ', but win conditions objects have to be objects or properties (defined using "or", in terms of other properties)',

	// levelFromString
	unknown_symbol_in_level: ch => 'Error, symbol "' + ch + '", used in level map, not found. Do you need to add it to the legend, or define a new object?',
	property_symbol_in_level: ch => 'Error, symbol "' + ch + '" is defined using \'or\', and therefore ambiguous - it cannot be used in a map. Did you mean to define it in terms of \'and\'?',
	wrong_symbol_type_in_level: (ch, type) => 'Error, symbol "' + ch + '" is defined as ' + identifier_type_as_text[type] + '. It cannot be used in a map.',

	// generateSoundData
	incorrect_sound_declaration: 'Incorrect sound declaration.', // TODO: explain what is incorrect
	bad_seed: seed => 'Expecting sfx data, instead found "' + seed + '".',
	null_seed: seed => 'Sound seed "' + seed + '" contains a null volume!',
	too_loud: (seed, max_volume) => 'Sorry, the volume defined in the seed "' + seed + '" is too loud. By respect to players\' audition, I will not accept seeds with a volume higher than ' + max_volume + '.',

	// compile
	no_level_found: 'No levels found. Add some levels!',

	// parser.js
	// =========

	// prelude:
	unknown_metadata: 'Unrecognised stuff in the prelude.',
	not_a_sprite_size: (value_str, default_value) => 'Wrong parameter for sprite_size in the preamble: was expecting WxH with W and H as numbers, but got: ' + value_str + '. Reverting back to default ' + default_value + ' size.',
	invalid_preamble_option: (option, key) => '"' + option +'" is not a valid option for "' + key.toUpperCase() + '". Refer to <a href="../Documentation/prelude.html" target="Pattern_Script_Documentation">the documentation</a> for possible values.',
	palette_not_found: (val, default_value) => 'Palette "'+val+'" not found, defaulting to '+default_value+'.',
	// objects:
	invalid_color_for_object: (object_name, c) => 'Invalid color specified for object'+((object_name !== undefined) ? ' "' + object_name + '"' : '')+', namely "' + c + '".',
	invalid_value_in_transorm: (expected_type, received_value) => 'Invalid sprite transformation: I was expecting a '+expected_type+' but I got "'+received_value+'".',
	palette_too_small: (i,n,l) => 'Trying to access color number ' + i + ' from the color palette of sprite ' + n + ', but there are only ' + l + ' defined in it.',
	// sounds:
	unexpected_sound_token: candname => 'unexpected sound token "'+candname+'".',
	// collision layers:
	object_in_multiple_layers: object_name => 'Object "' + object_name.toUpperCase() + '" appears in multiple collision layers. I ignored it, but you should fix this!',
	// levels
	no_grid_in_level: 'You are creating a new level with this line, but there was no grid in the previous level. A level NEEDS a grid. Otherwise, I will merge levels in a way that you may not expect.',
	non_rectangular_level: 'Maps must be rectangular, yo (In a level, the length of each row must be the same).',
	long_level_name: max_length => 'Level names should not be longer than ' + max_length + ' characters to fit on the title screen.',
	long_level_title: 'Long level title might get truncated on pause menu.',

	// rule_parser.js
	// ==============

	// parseRuleDirections
	random_on_nonfirst_group_rule: 'A rule-group can only be marked random by the first rule.', // TODO: better explain why in the message.

	// parseRuleString
	direction_NO_object: 'Syntax error: "NO" cannot follow a direction in a rule.',
	directions_outside_cellrows: 'Invalid syntax. Directions should be placed at the start of a rule.',
	no_or_random_followed_by_direction: keyword => 'Invalid syntax. The keyword "'+keyword.toUpperCase()+'" must be followed by an object name.',
	random_in_LHS: keyword => keyword.toUpperCase()+' cannot be matched on the left-hand side, it can only appear on the right',
	movements_in_laterule: 'Setting movements in late rules does not make sense and I will simply ignore them, as late rules are applied after eveything has moved.',
	ellipses_not_alone: 'Ellipses shoud be alone in their own cell, like that: |...|',
	more_than_one_ellipses_in_cellrow: "You can't use two ellipses in a single cell match pattern.  If you really want to, please implement it yourself and send me a patch :)",
	rule_without_arrow: "A rule has to have an arrow in it.  There's no arrow here! Consider reading up about rules - you're clearly doing something weird",
	rule_arrow_in_cell: 'Encountered an unexpected "->" inside square brackets.  It\'s used to separate states, it has no place inside them.',
	rule_open_open_brackets:   "Multiple opening brackets without corresponding closing brackets.  Something fishy here.  Every '[' has to be closed by a ']', and you can't nest them.",
	rule_close_close_brackets: "Multiple closing brackets without corresponding opening brackets.  Something fishy here.  Every '[' has to be closed by a ']', and you can't nest them.",
	commands_in_cellrow: 'Commands must appear at the end of the rule, outside the cell rows (square brackety things).',
	different_nb_cellrows: 'Error, when specifying a rule, the number of matches (square bracketed bits) on the left hand side of the arrow must equal the number on the right',
	different_nb_cells: 'In a rule, each pattern to match on the left must have a corresponding pattern on the right of equal length (number of cells).',

	// rule_expansion.js
	// =================

	ambiguous_movement: w => 'This rule has an ambiguous movement on the right-hand side, \"'+ w + "\", that can't be inferred from the left-hand side. (Either for every ambiguous movement associated to an entity on the right there has to be a corresponding one on the left attached to the same entity, OR, if there's a single occurrence of a particular ambiguous movement on the left, all properties of the same movement attached to the same object on the right are assumed to be the same (or something like that)).",
	ambiguous_property: name => 'This rule has a property on the right-hand side, \"'+ name.toUpperCase() + "\", that can't be inferred from the left-hand side.  (either for every property on the right there has to be a corresponding one on the left in the same cell, OR, if there's a single occurrence of a particular property name on the left, all properties of the same name on the right are assumed to be the same).",

	// rule_groups.js
	// ==============

	// generateLoopPointsAux
	unbalanced_loop: "Need to have matching number of 'startLoop' and 'endLoop' loop points.",
	// ruleGroupDiscardOverlappingTest
	overlapping_objects_in_cell: (example1, example2) => example1 + ' and ' + example2 + ' can never overlap, but this rule requires that to happen.',	

	// message_screen.js
	// =================

	title_truncated: h => 'Game title is too long to fit on screen, truncating to '+h+' lines.',
}

function get_error_message(msg)
{
	if (typeof msg === 'string')
		return msg
	const f = error_messages[msg[0]]
	if (typeof f === 'string')
		return f
	return f( ...(msg.slice(1)) )
}

function error_message_equal(m1=null, m2=null)
{
	switch (typeof m1)
	{
		case 'object':
			if ( (m1 !== null) && (m2 !== null) )
				return ( (m1.length == m2.length) && m1.every( (x,i) => error_message_equal(x, m2[i])) )
		default: return (m1 === m2)
	}
}



// TODO: all these functions are very similar and should be factorized
// Also, consider merging with console.js
// And finally, there should be a standalone version of the engine/parser that do not depend on the editor.

var compiling = false
var errorStrings = []
var warningStrings = []


function makeLinkToLine(lineNumber, anchor_text = null)
{
	const l = lineNumber.toString()
	return '<a onclick="jumpToLine(' + l + ');"  href="javascript:void(0);">' + ((anchor_text === null) ? l : anchor_text) + '</a>';
}

function logErrorCacheable(str, lineNumber, urgent)
{
	logErrorAux(str, lineNumber, urgent, 'errorText', errorStrings)
}

function logError(str, lineNumber, urgent)
{
	logErrorAux(str, lineNumber, urgent, 'errorText', errorStrings, true)
}

function logWarning(str, lineNumber, urgent)
{
	logErrorAux(str, lineNumber, urgent, 'warningText', warningStrings, true)
}

function logErrorAux(str, lineNumber, urgent = false, text_class, text_cache, print_immediately)
{
	if (compiling||urgent)
	{
		const txt = get_error_message(str)
		const lineString = (lineNumber !== undefined) ? makeLinkToLine(lineNumber, '<span class="errorTextLineNumber"> line ' + lineNumber.toString() + '</span>') + ': ' : ''
		const errorString = lineString + '<span class="'+text_class+'">' + txt + '</span>'
		const key = (typeof str === 'string') ? str : [str, lineNumber]
		if (text_cache.findIndex(x => error_message_equal(x, key)) < 0 || urgent)
		{
			// not a duplicate error, we need to log it
			consolePrint(errorString, print_immediately)
			text_cache.push(key)
		}
	}
}



// uses: state

const empty_terminal_line    = '                                  ';
const selected_terminal_line = '##################################';
const doted_terminal_line    = '..................................';

const terminal_width = empty_terminal_line.length
const terminal_height = 13

MenuScreen.prototype.isContinuePossible = function()
{
	if ( (this.curlevel === undefined) && (this.curlevelTarget === undefined) )
		return false
	// test is savepoint is valid (TODO: use unique ids for levels instead)
	const l = state.levels[this.curlevel.level]
	if (l === undefined)
		return false // some levels before save point have been deleted and now we're after the game
	const b = l.boxes[this.curlevel.box]
	return (b !== undefined) && (this.curlevel.msg < b.length) // box index is invalid or some messages have been deleted
}


function skipTextBox()
{
	const next_level = new LevelState(curlevel.level+((curlevel.box === 3) ? 1 : 0), 2, -1)
	if (next_level.level >= state.levels.length)
	{
		next_level.level--
		next_level.box = 3
		next_level.msg = state.levels[state.levels.length-1].boxes[3].length-1
	}
	loadLevelFromState(state, next_level)
}

function titleMenuNewGame()
{
	loadLevelFromState(state, (new LevelState()).next())
}

MenuScreen.prototype.titleMenuContinue = function()
{
	loadLevelFromState(state, this.curlevel, undefined, true, this.curlevelTarget)
}


function pauseMenuRestart()
{
	loadLevelFromState(state, curlevel)
}

MenuScreen.prototype.doSelectedFunction = function()
{
	this.done = false
	const func = this.menu_entries[this.item][1]
	this.updateMenuItems() // in case we need to come back to the menu after the selected function
	func()
}

MenuScreen.prototype.makeTerminalScreen = function()
{
	this.text = Array.from(
		{
			3: ' Pattern:Script Terminal ',
			4: ' v 1.7 ',
			8: ' insert cartridge ',
			length:terminal_height
		},
		l => [(l === undefined) ? doted_terminal_line : centerText(l, doted_terminal_line), '#ffffff']
	)
}

MenuScreen.prototype.makeMenuItems = function(nb_lines, menu_entries)
{
	this.done = false
	this.menu_entries = menu_entries
	const l = menu_entries.length - 1
	this.interline_size = Math.ceil( nb_lines / (l+1) )
	const menu_height = this.interline_size*l + 1
	this.first_menu_line = this.text.length + Math.floor( ( nb_lines - menu_height ) / 2)
	this.text.push( ...Array(nb_lines).fill(['', state.fgcolor]) )
	this.item = 0
	this.updateMenuItems()
}

MenuScreen.prototype.updateMenuItems = function()
{
	for (const [i, [item_text, item_function]] of this.menu_entries.entries())
	{
		this.text[this.first_menu_line + i*this.interline_size] = [centerText( item_text, empty_terminal_line), state.fgcolor]
	}
	this.text[this.first_menu_line + this.item*this.interline_size] = [centerText( '# '+this.menu_entries[this.item][0]+' #', this.done ? selected_terminal_line : empty_terminal_line), state.fgcolor]
}

MenuScreen.prototype.openMenu = function(previous_screen = screen_layout.content)
{
	this.escaped_screen = previous_screen
	screen_layout.content = this
	tryPlaySimpleSound(this.open_soundname)
	canvasResize()
}

MenuScreen.prototype.closeMenu = function()
{
	if (this.escaped_screen === null)
		return
	screen_layout.content = this.escaped_screen
	// TODO: closing the title screen back to the pause menu does not play pausescreen sound.
	canvasResize()
}

// sets: this.text
MenuScreen.prototype.makeTitle = function()
{
	if (state.levels.length === 0)
	{
		this.makeTerminalScreen()
		return
	}

	const title = (state.metadata.title !== undefined) ? state.metadata.title : 'Pattern:Script Game';

	const title_bottomline = 3
	const author_bottomline = 5
	const empty_line = ['', state.fgcolor]
	this.text = [ empty_line ]

	// Add title
	const max_title_height = (state.metadata.author === undefined) ? author_bottomline : title_bottomline
	var titlelines = wordwrap(title)
	if (titlelines.length > max_title_height)
	{
		titlelines.splice(max_title_height)
		logWarning(['title_truncated', max_title_height], undefined, true)
	}
	this.text.push(...titlelines.map( l => [centerText(l), state.titlecolor] ), ...Array(Math.max(0, max_title_height - titlelines.length - 1)).fill(empty_line))

	// Add author(s)
	if (state.metadata.author !== undefined)
	{
		var attributionsplit = wordwrap('by ' + state.metadata.author)
		if (attributionsplit[0].length < terminal_width)
		{
			attributionsplit[0] = " " + attributionsplit[0];
		}
		if (attributionsplit.length > author_bottomline - title_bottomline)
		{
			attributionsplit.splice(author_bottomline - title_bottomline)
			logWarning('Author list too long to fit on screen, truncating to three lines.', undefined, true)
		}
		this.text.push(...attributionsplit.map( l => [alignTextRight(l, Math.max(l.length - terminal_width, 1)), state.authorcolor] ))
		// I prefer them centered:
		// this.text.push(...attributionsplit.map( l => centerText(l) ))
	}
	this.text.push( ...Array(author_bottomline - this.text.length).fill(empty_line) )

	// Add menu options
	this.makeMenuItems(3,  this.isContinuePossible() ? [['continue from '+state.levels[this.curlevel.level].name, () => this.titleMenuContinue()], ['new game', titleMenuNewGame]] : [['start', titleMenuNewGame]])
	this.text.push( empty_line )

	// Add key configuration info:
	this.text.push( [alignTextLeft('arrow keys to move'), state.keyhintcolor] )
	this.text.push( [alignTextLeft( ('noaction' in state.metadata) ? 'X to select' : 'X to select / action'), state.keyhintcolor] )
	var msgs = []
	if ( ! ('noundo' in state.metadata) )
		msgs.push('Z to undo')
	if ( ! ('norestart' in state.metadata) )
		msgs.push('R to restart')
	this.text.push( [alignTextLeft( msgs.join(', ') ), state.keyhintcolor] )

	this.text.push(empty_line)
}

function centerText(txt, context=empty_terminal_line)
{
	return alignTextLeft(txt, Math.max(0, Math.floor((terminal_width - txt.length)/2)), context)
}

function alignTextLeft(txt, lmargin=7, context=empty_terminal_line)
{
	return context.slice(0, lmargin) + txt + context.slice(txt.length + lmargin)
}

function alignTextRight(txt, rmargin=1, context=empty_terminal_line)
{
	return context.slice(0, -rmargin - txt.length) + txt + context.slice(context.length - rmargin)
}

function wordwrap(str, width = terminal_width)
{
	if (!str) { return str; }
 
	const regex = '.{1,'+width+'}(\\s|$)|.{'+width+'}|.+$'
	// cont regex = '.{1,'+width+'}(\\s|$)|\\S+?(\\s|$)'
	return str.match( RegExp(regex, 'g') );
}

function wordwrapAndColor(str, color, width = terminal_width)
{
	return wordwrap(str, width).map(l => [centerText(l), color])
}


MenuScreen.prototype.makePauseMenu = function()
{
	const empty_line = [empty_terminal_line, state.fgcolor]
	const level = state.levels[curlevel.level]
	this.text = [ empty_line, [centerText('-< GAME PAUSED >-'), state.titlecolor], [centerText(level.name), state.titlecolor] ]
	if ( ('show_level_title_in_menu' in state.metadata) && (level.title.length > 0) )
	{
		let title = level.title
		if (title.length > empty_terminal_line.length)
			title = title.substring(0, empty_terminal_line.length - 1) + '…'
		this.text.push([centerText(title), state.titlecolor])
	}
	this.text.push( empty_line )
	this.makeMenuItems(
		terminal_height - 5,
		[
			['resume game', () => this.closeMenu()],
			(screen_layout.content.screen_type === 'text') ? ['skip text', skipTextBox] : ['replay level from the start', pauseMenuRestart],
			['exit to title screen', goToTitleScreen]
		]
	)
	this.text.push( empty_line )
}


// uses state
TextModeScreen.prototype.doMessage = function(message)
{
	message ||= this
	screen_layout.content = this
	const empty_line = [ empty_terminal_line, state.fgcolor ]

	this.text = Array(terminal_height).fill(empty_line)

	const offset = Math.max(0, Math.floor((terminal_height-2)/2) - Math.floor(message.text.length/2) )

	const count = Math.min(message.text.length, terminal_height - 1)
	this.text.splice(offset, count, ...message.text)

	if ( ! this.done )
	{
		this.text[clamp(10, count+1, 12)] = [centerText('X to continue'), state.keyhintcolor]
	}
	
	canvasResize()
}

// uses: STRIDE_OBJ, STRIDE_MOV

// levels are only constructed in engine/engine_base.js/unloadGame and compiler.js/levelFromString
function Level(width, height, objects)
{
	// Definition of the level layout (should be constant)
	this.width = width
	this.height = height
	this.n_tiles = width * height
	// This is both the initial state of the level (constant) and the current state (mutable).
	this.objects = objects
}

Level.prototype.clone = function()
{
	return new Level(this.width, this.height, new Int32Array(this.objects))
}

Level.prototype.cellCoord = function(cell_index)
{
	return [ (cell_index/this.height)|0, (cell_index%this.height) ]
}

Level.prototype.delta_index = function(direction)
{
	const [dx, dy] = dirMasksDelta[direction]
	return dx*this.height + dy
}

Level.prototype.getCell = function(index)
{
	return new BitVec(this.objects.subarray(index * STRIDE_OBJ, index * STRIDE_OBJ + STRIDE_OBJ));
}

Level.prototype.getCellInto = function(index, targetarray)
{
	for (var i=0;i<STRIDE_OBJ;i++) {
		targetarray.data[i] = this.objects[index*STRIDE_OBJ+i];
	}
	return targetarray;
}

Level.prototype.mapCellObjects = function(index, func)
{
	for (var i=0; i<STRIDE_OBJ; i++)
	{
		var bits = this.objects[index*STRIDE_OBJ+i]
		for (k=0; bits != 0; k++)
		{
			if (bits & 1)
			{
				func(i*32+k)
			}
			bits >>>= 1
		}
	}
}

Level.prototype.setCell = function(index, vec)
{
	for (var i = 0; i < vec.data.length; ++i)
	{
		this.objects[index * STRIDE_OBJ + i] = vec.data[i];
	}
}


// a set of static movement bitvecs to use as needed.
var _movementVecs
var _movementVecIndex = 0

Level.prototype.getMovements = function(index) // !!! increments _movementVecIndex !
{
	var _movementsVec =_movementVecs[_movementVecIndex]
	_movementVecIndex = (_movementVecIndex+1) % _movementVecs.length

	for (var i=0; i<STRIDE_MOV; i++)
	{
		_movementsVec.data[i] = this.movements[index*STRIDE_MOV + i];	
	}
	return _movementsVec;
}

Level.prototype.setMovements = function(index, vec)
{
	for (var i = 0; i < vec.data.length; ++i)
	{
		this.movements[index*STRIDE_MOV + i] = vec.data[i]
	}
}

Level.prototype.calculateRowColMasks = function()
{
	for(var i=0; i<this.mapCellContents.length; i++)
	{
		this.mapCellContents[i] = 0
	}

	for (var i=0; i<this.width; i++)
	{
		this.colCellContents[i].setZero()
	}

	for (var i=0; i<this.height; i++)
	{
		this.rowCellContents[i].setZero()
	}

	for (var i=0; i<this.width; i++)
	{
		for (var j=0; j<this.height; j++)
		{
			const cellContents = this.getCellInto(j + i*this.height, _o9)
			this.mapCellContents.ior(cellContents)
			this.rowCellContents[j].ior(cellContents)
			this.colCellContents[i].ior(cellContents)
		}
	}
}

Level.prototype.updateCellContent = function(cell_index, cellMask, movMask)
{
	this.setCell(cell_index, cellMask)
	this.setMovements(cell_index, movMask)

	const [x, y] = this.cellCoord(cell_index)
	this.colCellContents[x].ior(cellMask)
	this.rowCellContents[y].ior(cellMask)
	this.mapCellContents.ior(cellMask)
}

Level.prototype.rebuildArrays = function()
{
	this.movements = new Int32Array(this.n_tiles * STRIDE_MOV);

	this.rigidMovementAppliedMask = [];
	this.rigidGroupIndexMask = [];
	this.rowCellContents = [];
	this.colCellContents = [];
	this.mapCellContents = new BitVec(STRIDE_OBJ);
	_movementVecs = [ new BitVec(STRIDE_MOV), new BitVec(STRIDE_MOV), new BitVec(STRIDE_MOV) ]

	static_CellReplacement = make_static_CellReplacement()
	_o2_5 = new BitVec(STRIDE_OBJ);
	_o3 = new BitVec(STRIDE_OBJ);
	_o6 = new BitVec(STRIDE_OBJ);
	_o7 = new BitVec(STRIDE_OBJ);
	_o8 = new BitVec(STRIDE_OBJ);
	_o9 = new BitVec(STRIDE_OBJ);
	_o10 = new BitVec(STRIDE_OBJ);
	_o11 = new BitVec(STRIDE_OBJ);
	_m3 = new BitVec(STRIDE_MOV);

	for (var i=0; i<this.height; i++) {
		this.rowCellContents[i] = new BitVec(STRIDE_OBJ);	    	
	}
	for (var i=0; i<this.width; i++) {
		this.colCellContents[i] = new BitVec(STRIDE_OBJ);	    	
	}

	for (var i=0; i<this.n_tiles; i++)
	{
		this.rigidMovementAppliedMask[i] = new BitVec(STRIDE_MOV);
		this.rigidGroupIndexMask[i] = new BitVec(STRIDE_MOV);
	}
}

Level.prototype.backUp = function()
{
	return {
		objects: new Int32Array(this.objects),
		width:  this.width,
		height: this.height,
	}
}

Level.prototype.forSerialization = function()
{
	return {
		objects : Array.from(this.objects),
		width :  this.width,
		height : this.height,
	}
}

Level.prototype.restore = function(lev)
{
	this.objects = new Int32Array(lev.objects)

	if ( (this.width !== lev.width) || (this.height !== lev.height) )
	{
		this.width = lev.width
		this.height = lev.height
		this.n_tiles = lev.width * lev.height
		this.rebuildArrays() //regenerate all other stride-related stuff
	}
	else 
	{
		// layercount doesn't change
		for (var i=0; i<this.n_tiles; i++)
		{
			this.movements[i] = 0
			this.rigidMovementAppliedMask[i] = 0
			this.rigidGroupIndexMask[i] = 0
		}	

		for (var i=0; i<this.height; i++)
		{
			this.rowCellContents[i].setZero();
		}
		for (var i=0; i<this.width; i++)
		{
			this.colCellContents[i].setZero();
		}
	}

	againing = false
}



function BitVec(init) {
	this.data = new Int32Array(init);
}

BitVec.prototype.clone = function() {
	return new BitVec(this.data);
}

// Operations on the whole set of bits
// ===================================

// Don't use these functions with a bitvec created from Level.getCell, which uses internally a subarray that adds layers of abstraction.
// It's faster to first getCellInto and then use the functions.

function generate_bitvec_function(formula, return_var)
{
	var params = []
	const body = formula.replace(/{([a-zA-Z_][a-zA-Z_\d]*)}/g, function(_, match)
		{
			if ( (match !== 'this') && (params.indexOf(match) < 0) )
				params.push(match)
			return match+'.data[i]'
		})
	params.sort()
	const return_value = (return_var !== undefined) ? '\nreturn ' + return_var : ''
	return Function(...params, 'for (var i=0; i<this.data.length; ++i) ' + body + return_value)
}

BitVec.prototype.cloneInto = generate_bitvec_function('{target} = {this}', 'target')

BitVec.prototype.setZero = generate_bitvec_function('{this} = 0')

BitVec.prototype.inot = generate_bitvec_function('{this} = ~{this}')

BitVec.prototype.iand = generate_bitvec_function('{this} &= {other}')

BitVec.prototype.ior = generate_bitvec_function('{this} |= {other}')

// Note that x.iclear(y) is equivalent to x.iand(y.clone().inot()) and can sometimes be optimized by precomputing y.clone().inot()
BitVec.prototype.iclear = generate_bitvec_function('{this} &= ~{other}')

BitVec.prototype.iClearAddInto = generate_bitvec_function('{dest} = ({this} & ~{a}) | {b}', 'dest')

BitVec.prototype.iAddBut = generate_bitvec_function('{this} |= {a} & ~{b}')


// Operations on individual bits
// =============================

BitVec.prototype.ibitset = function(ind) {
	this.data[ind>>5] |= 1 << (ind & 31);
}

BitVec.prototype.ibitclear = function(ind) {
	this.data[ind>>5] &= ~(1 << (ind & 31));
}

BitVec.prototype.get = function(ind) {
	return (this.data[ind>>5] & 1 << (ind & 31)) !== 0;
}

// Operations on a small subranges (for layers)
// ============================================

// TODO: it would be more efficient probably to ensure all layers fit in a single cell of the array, even if it makes using more memory (it requires at least 19 layers to use
// one more integer, and at least 115 layers to use two more integers, so I think it's reasonable), and computing the shift for a layer cannot anymore be as simple as 5*layer.

BitVec.prototype.getshiftor = function(mask, shift) {
	var toshift = shift & 31;
	var ret = this.data[shift>>5] >>> (toshift);
	if (toshift) {
		ret |= this.data[(shift>>5)+1] << (32 - toshift);
	}
	return ret & mask;
}

BitVec.prototype.ishiftor = function(mask, shift) {
	var toshift = shift&31;
	var low = mask << toshift;
	this.data[shift>>5] |= low;
	if (toshift) {
		var high = mask >> (32 - toshift);
		this.data[(shift>>5)+1] |= high;
	}
}

BitVec.prototype.ishiftclear = function(mask, shift) {
	var toshift = shift & 31;
	var low = mask << toshift;
	this.data[shift>>5] &= ~low;
	if (toshift){
		var high = mask >> (32 - (shift & 31));
		this.data[(shift>>5)+1] &= ~high;
	}
}


// Comparisons of bit sets
// =======================

BitVec.prototype.equals = function(other) {
	// if (this.data.length !== other.data.length) // this function is only used twice on objects that are guarenteed to be the same size
	// 	return false;
	for (var i = 0; i < this.data.length; ++i) {
		if (this.data[i] !== other.data[i])
			return false;
	}
	return true;
}

BitVec.prototype.iszero = function() {
	for (var i = 0; i < this.data.length; ++i) {
		if (this.data[i])
			return false;
	}
	return true;
}

BitVec.prototype.bitsSetInArray = function(arr) { // are the bits in 'this' a subset of the bits in 'arr'?
	for (var i = 0; i < this.data.length; ++i) {
		if ((this.data[i] & arr[i]) !== this.data[i]) {
			return false;
		}
	}
	return true;
}

BitVec.prototype.bitsClearInArray = function(arr) {
	for (var i = 0; i < this.data.length; ++i) {
		if (this.data[i] & arr[i]) {
			return false;
		}
	}
	return true;
}

BitVec.prototype.anyBitsInCommon = function(other) {
	return !this.bitsClearInArray(other.data);
}

BitVec.prototype.forEachBitSet = function(func)
{
	for (var i=0; i<this.data.length; i++)
	{
		var bits = this.data[i]
		for (k=0; bits != 0; k++)
		{
			if (bits & 1)
			{
				func((i<<5)+k)
			}
			bits >>>= 1
		}
	}
}



function CommandsSet()
{
	BitVec.call(this, 13) // todo
	this.message = null
	this.nb_commands = 0
}
CommandsSet.prototype = Object.create(BitVec.prototype)

// DO NOT CHANGE THE ORDER OF COMMANDS
CommandsSet.commandwords = [ 'cancel', 'restart', 'again', 'win', 'checkpoint', 'nosave', 'sfx0', 'sfx1', 'sfx2', 'sfx3', 'sfx4', 'sfx5', 'sfx6', 'sfx7', 'sfx8', 'sfx9', 'sfx10', 'message' ]
CommandsSet.command_keys = {}
CommandsSet.commandwords.forEach( (word, index) => { CommandsSet.command_keys[word] = index} )

CommandsSet.prototype.is_command = function(word)
{
	return CommandsSet.command_keys.hasOwnProperty(word)
}

CommandsSet.prototype.addCommand = function(command)
{
	const key = CommandsSet.command_keys[command]
	if (this.get(key))
		return
	this.ibitset(key)
	this.nb_commands++
}

CommandsSet.prototype.setMessage = function(msg_text)
{
	this.message = msg_text
	this.addCommand('message')
}

CommandsSet.prototype.reset = function()
{
	this.setZero()
	this.message = null
}

CommandsSet.prototype.get_representation = function()
{
	return CommandsSet.commandwords.filter( (k,i) => this.get(i) ).join(' ').replace('message', '(message, "'+this.message+'")')
}

var ellipsisPattern = ['ellipsis'];

function Rule(rule, string_representation)
{
	this.direction = rule[0]; 		/* direction rule scans in */
	this.patterns = rule[1];		/* lists of CellPatterns to match */
	this.hasReplacements = rule[2];
	this.lineNumber = rule[3];		/* rule source for debugging */
	this.isEllipsis = rule[4];		/* true if pattern has ellipsis */
	this.groupNumber = rule[5];		/* execution group number of rule */
	this.isRigid = rule[6];
	this.commands = rule[7];		/* cancel, restart, sfx, etc */
	this.isRandom = rule[8];
	this.parameter_expansion_string = rule[9]
	this.cellRowMasks = this.patterns.map( p => computePatternMask(p) )
	this.cellRowMatches = this.patterns.map( (p,i) => this.generateCellRowMatchesFunction(p, this.isEllipsis[i]) )
	this.ruleMask = this.cellRowMasks.reduce( (acc, m) => { acc.ior(m); return acc }, new BitVec(STRIDE_OBJ) )
	/* TODO: eliminate isRigid, groupNumber, isRandom
	from this class by moving them up into a RuleGroup class */
	this.string_representation = string_representation
	this.makeRigidMask()
}

function computePatternMask(cellRow)
{
	var rowMask = new BitVec(STRIDE_OBJ)
	for (const cell of cellRow)
	{
		if (cell === ellipsisPattern)
			continue
		rowMask.ior(cell.objectsPresent)
	}
	return rowMask
}

// See notes on generation in engine/generate_matches.js

Rule.prototype.generateCellRowMatchesFunction = function(cellRow, hasEllipsis)
{
	const cr_l = cellRow.length
	var fn = ''
	if (hasEllipsis === false)
	{
		var mul = STRIDE_OBJ === 1 ? '' : '*'+STRIDE_OBJ;	
		for (var i = 0; i < STRIDE_OBJ; ++i) {
			fn += 'var cellObjects' + i + ' = objects[i' + mul + (i ? '+'+i : '') + '];\n';
		}
		mul = STRIDE_MOV === 1 ? '' : '*'+STRIDE_MOV;
		for (var i = 0; i < STRIDE_MOV; ++i) {
			fn += 'var cellMovements' + i + ' = movements[i' + mul + (i ? '+'+i : '') + '];\n';
		}
		/*
		hard substitute in the first one - if I substitute in all of them, firefox chokes.
		*/
		fn += "return "+cellRow[0].generateMatchString('0_');// cellRow[0].matches(i)";
		for (var cellIndex=1; cellIndex<cr_l; cellIndex++)
		{
			fn+="&&cellRow["+cellIndex+"].matches(i+"+cellIndex+"*d, objects, movements)";
		}
		fn+=";";

		if (fn in matchCache) {
			return matchCache[fn];
		}
		//console.log(fn.replace(/\s+/g, ' '));
		return matchCache[fn] = new Function('cellRow', 'i', 'd', 'objects', 'movements', fn)
	}
	else
	{
		fn += "var result = [];\n"
		fn += "if(cellRow[0].matches(i, objects, movements)";
		var cellIndex=1;
		for (;cellRow[cellIndex]!==ellipsisPattern;cellIndex++) {
			fn+="&&cellRow["+cellIndex+"].matches(i+"+cellIndex+"*d, objects, movements)";
		}
		cellIndex++;
		fn+=") {\n";
		fn+="\tfor (var k=kmin;k<kmax;k++) {\n"
		fn+="\t\tif(cellRow["+cellIndex+"].matches(i+d*(k+"+(cellIndex-1)+"), objects, movements)";
		cellIndex++;
		for (;cellIndex<cr_l;cellIndex++) {
			fn+="&&cellRow["+cellIndex+"].matches(i+d*(k+"+(cellIndex-1)+"), objects, movements)";			
		}
		fn+="){\n";
		fn+="\t\t\tresult.push([i,k]);\n";
		fn+="\t\t}\n"
		fn+="\t}\n";				
		fn+="}\n";		
		fn+="return result;"


		if (fn in matchCache) {
			return matchCache[fn];
		}
		//console.log(fn.replace(/\s+/g, ' '));
		return matchCache[fn] = new Function('cellRow', 'i', 'kmax', 'kmin', 'd', 'objects', 'movements', fn)
	}	

}


Rule.prototype.toJSON = function() {
	/* match construction order for easy deserialization */
	return [
		this.direction, this.patterns, this.hasReplacements, this.lineNumber, this.isEllipsis,
		this.groupNumber, this.isRigid, this.commands, this.isRandom, this.cellRowMasks
	];
}



function matchCellRow(level, direction, cellRowMatch, cellRow, cellRowMask, d)
{
	const len = cellRow.length - 1

	var xmin = (direction === 4) ? len : 0
	var xmax = level.width - ((direction === 8) ? len : 0)
	var ymin = (direction === 1) ? len : 0
	var ymax = level.height - ((direction === 2) ? len : 0)

	var result = []
	
	if (direction>2)
	{ // horizontal

		for (var y=ymin; y<ymax; y++)
		{
			if ( ! cellRowMask.bitsSetInArray(level.rowCellContents[y].data) )
				continue

			for (var x=xmin; x<xmax; x++)
			// for (const x of possible_xs)
			{
				const i = x*level.height + y
				if (cellRowMatch(cellRow, i, d, level.objects, level.movements))
				{
					result.push(i)
				}
			}
		}
	}
	else
	{
		for (var x=xmin; x<xmax; x++)
		{
			if ( ! cellRowMask.bitsSetInArray(level.colCellContents[x].data) )
				continue

			for (var y=ymin; y<ymax; y++)
			{
				const i = x*level.height + y
				if (cellRowMatch(cellRow, i, d, level.objects, level.movements))
				{
					result.push(i)
				}
			}
		}		
	}
	return result
}


function matchCellRowWildCard(level, direction, cellRowMatch, cellRow, cellRowMask, d)
{
	const len = cellRow.length - 2//remove one to deal with wildcard (it takes one cell in cellRow, but can be entirely skipped)

	const xmin = (direction === 4) ? len : 0
	const xmax = level.width - ((direction === 8) ? len : 0)
	const ymin = (direction === 1) ? len : 0
	const ymax = level.height - ((direction === 2) ? len : 0)

	var result = []

	if (direction > 2)
	{ // horizontal
		for (var y=ymin; y<ymax; y++)
		{
			if ( ! cellRowMask.bitsSetInArray(level.rowCellContents[y].data) )
				continue

			for (var x=xmin; x<xmax; x++)
			{
				const kmax = (direction === 4) ? 1+x-xmin : (xmax-x)
				result.push.apply(result, cellRowMatch(cellRow, x*level.height + y, kmax, 0, d, level.objects, level.movements))
			}
		}
	}
	else
	{
		for (var x=xmin; x<xmax; x++)
		{
			if ( ! cellRowMask.bitsSetInArray(level.colCellContents[x].data) )
				continue

			for (var y=ymin; y<ymax; y++)
			{
				const kmax = (direction === 2) ? ymax-y : (1+y-ymin)
				result.push.apply(result, cellRowMatch(cellRow, x*level.height + y, kmax, 0, d, level.objects, level.movements))
			}
		}		
	}

	return result
}

Rule.prototype.findMatches = function(level)
{
	if ( ! this.ruleMask.bitsSetInArray(level.mapCellContents.data) )
		return []

	const d = level.delta_index(this.direction)

	var matches = []
	const cellRowMasks = this.cellRowMasks
	for (const [cellRowIndex, cellRow] of this.patterns.entries())
	{
		const cellRowMask = cellRowMasks[cellRowIndex]

		const matchFunction = this.cellRowMatches[cellRowIndex];
		if (this.isEllipsis[cellRowIndex])
		{
			var match = matchCellRowWildCard(level, this.direction, matchFunction, cellRow, cellRowMask, d)
		} else {
			var match = matchCellRow(level, this.direction, matchFunction, cellRow, cellRowMask, d)
		}
		if (match.length === 0)
			return match
		matches.push(match)
	}
	return matches
}

Rule.prototype.applyAt = function(level, tuple, check, delta_index = level.delta_index(this.direction))
{
	// have to double check they apply because the first check only tested individual cell rows and called this function for all possible tuples,
	// but the application of one rule can invalidate the next ones.
	if (check)
	{
		for (var cellRowIndex=0; cellRowIndex<this.patterns.length; cellRowIndex++)
		{
			if (this.isEllipsis[cellRowIndex]) //if ellipsis
			{
				if ( this.cellRowMatches[cellRowIndex](this.patterns[cellRowIndex], tuple[cellRowIndex][0], tuple[cellRowIndex][1]+1, tuple[cellRowIndex][1], delta_index, level.objects, level.movements).length == 0 )
					return false
			}
			else if ( ! this.cellRowMatches[cellRowIndex](this.patterns[cellRowIndex], tuple[cellRowIndex], delta_index, level.objects, level.movements) )
				return false
		}
	}

	var result=false;
	
	//APPLY THE RULE
	for (var cellRowIndex=0; cellRowIndex<this.patterns.length; cellRowIndex++)
	{
		var preRow = this.patterns[cellRowIndex];
		
		var currentIndex = this.isEllipsis[cellRowIndex] ? tuple[cellRowIndex][0] : tuple[cellRowIndex];
		for (const preCell of preRow)
		{
			if (preCell === ellipsisPattern)
			{
				var k = tuple[cellRowIndex][1];
				currentIndex += delta_index*k
				continue;
			}
			result = preCell.replace(this, level, currentIndex) || result;
			currentIndex += delta_index
		}
	}

	if (verbose_logging && result)
	{
		const rule_expansion = (this.parameter_expansion_string.length > 0) ? ' '+this.parameter_expansion_string : ''
		const cell_positions = tuple.map( (x,i) => this.isEllipsis[i] ? x[0] : x ).map( i => level.cellCoord(i).map(c => c.toString()) )
		const position = cell_positions.map(([x,y]) => '<a class="cellhighlighter" onmouseleave="highlightCell(null);" onmouseenter="highlightCell(['+x+','+y+'])">('+x+';'+y+')</a>').join(', ')
		consolePrint('<font color="green">Rule ' + makeLinkToLine(this.lineNumber) + rule_expansion + ' applied at ' + position + '.</font>');
	}

	return result
}

Rule.prototype.tryApply = function(level)
{
	const delta = level.delta_index(this.direction)

	//get all cellrow matches
	const matches = this.findMatches(level)
	if (matches.length === 0)
		return false

	var result = false
	if (this.hasReplacements)
	{
		var chk = false
		for (const tuple of cartesian_product(...matches))
		{
			result = this.applyAt(level, tuple, chk, delta) || result
			chk = true
		}
	}

	this.queueCommands()
	return result
}

Rule.prototype.queueCommands = function()
{

	// priority cancel > restart > everything else + sfx and message commands allowed after a cancel / restart

	// if cancel is the queue from other rules, ignore everything
	const preexisting_cancel = execution_context.commandQueue.get(CommandsSet.command_keys.cancel)
	if (preexisting_cancel)
		return

	// if restart is in the queue from other rules, only apply if there's a cancel present here
	const preexisting_restart = execution_context.commandQueue.get(CommandsSet.command_keys.restart)
	const currule_cancel = this.commands.get(CommandsSet.command_keys.cancel)
	if ( preexisting_restart && ( ! currule_cancel ) )
		return

	//if you are writing a cancel or restart, clear the current queue
	if ( this.commands.get(CommandsSet.command_keys.restart) || currule_cancel )
	{
		this.commands.cloneInto(execution_context.commandQueue)
	}
	else
	{
		execution_context.commandQueue.ior(this.commands)
	}

	if (this.commands.message !== null)
	{
		execution_context.commandQueue.message = this.commands.message
	}

	if (verbose_logging)
	{
		for(const command of CommandsSet.commandwords.filter( (k,i) => this.commands.get(i) ) )
		{
			consolePrint('<font color="green">Rule ' + makeLinkToLine(this.lineNumber) + ' triggers command ' + command + '.</font>', true)
			execution_context.commandQueue.sourceRules[CommandsSet.command_keys[command]] = this
		}
	}
}


Rule.prototype.makeRigidMask = function(nb_layers, STRIDE_MOV, rigidGroupIndex)
{
	if ( ! this.isRigid )
		return

	// write the rigidGroupIndex in all layers identified by replacementMovementLayerMask
	this.rigidMask = new BitVec(STRIDE_MOV)
	for (var layer = 0; layer < nb_layers; layer++)
	{
		this.rigidMask.ishiftor(rigidGroupIndex, layer * 5)
	}
	for (const pattern of this.patterns)
	{
		for (const cell_pattern of pattern)
		{
			cell_pattern.makeRigidMask(this.rigidMask)
		}
	}
}



var STRIDE_OBJ = 1;
var STRIDE_MOV = 1;

function CellPattern(row) {
	this.objectsPresent = row[0];
	this.objectsMissing = row[1];
	this.anyObjectsPresent = row[2];
	this.movementsPresent = row[3];
	this.movementsMissing = row[4];
	this.replacement = null
	this.matches = this.generateMatchFunction()
};

function CellReplacement(row)
{
	[ this.objectsClear, this.objectsSet, this.movementsClear, this.movementsSet, this.movementsLayerMask, this.randomEntityMask, this.randomDirMask ] = row
}

CellReplacement.prototype.cloneInto = function(dest)
{
	this.objectsClear.cloneInto(dest.objectsClear)
	this.objectsSet  .cloneInto(dest.objectsSet)

	this.movementsClear.cloneInto(dest.movementsClear)
	this.movementsSet  .cloneInto(dest.movementsSet)
	dest.movementsLayerMask = this.movementsLayerMask

	dest.randomEntityMask = this.randomEntityMask
	dest.randomDirMask    = this.randomDirMask
}

CellReplacement.prototype.applyRandoms = function()
{
	// replace random entities
	if ( ! this.randomEntityMask.iszero() )
	{
		var choices=[]
		for (var i=0; i<32*STRIDE_OBJ; i++)
		{
			if (this.randomEntityMask.get(i))
			{
				choices.push(i)
			}
		}
		const rand = RandomGen.pickInArray(choices)
		const layer = state.identifiers.objects[state.idDict[rand]].layer
		this.objectsSet.ibitset(rand)
		this.objectsClear.ior(state.layerMasks[layer])
		this.movementsClear.ishiftor(0x1f, 5*layer)
	}
	
	// replace random dirs
	for (const layerIndex of this.randomDirMask)
	{
		this.movementsSet.ibitset(RandomGen.integer(4) + 5*layerIndex)
	}
}

var make_static_CellReplacement = () => new CellReplacement(Array.from(([1,1,0,0,0,1,0]), (x,i) => (i==6) ? [] : new BitVec(x ? STRIDE_OBJ : STRIDE_MOV) ))
var static_CellReplacement = make_static_CellReplacement()



var matchCache = {};



CellPattern.prototype.generateMatchString = function()
{
	var fn = '(true'
	for (var i = 0; i < Math.max(STRIDE_OBJ, STRIDE_MOV); ++i)
	{
		var co = 'cellObjects' + i
		var cm = 'cellMovements' + i
		var op = this.objectsPresent.data[i]
		var om = this.objectsMissing.data[i]
		var mp = this.movementsPresent.data[i]
		var mm = this.movementsMissing.data[i]
		if (op)
		{ // test that all bits set in op (objects present) are also set in co (cell's objects), i.e. the cell contains all the objects requested
			if (op&(op-1)) // true if op has more than one bit set
				fn += '\t\t&& ((' + co + '&' + op + ')===' + op + ')\n';
			else
				fn += '\t\t&& (' + co + '&' + op + ')\n';
		}
		if (om) // test that 'co & om == 0', i.e. the cell does not contain any of the objects missing (or rather, forbidden objects)
			fn += '\t\t&& !(' + co + '&' + om + ')\n';
		if (mp) {
			if (mp&(mp-1))
				fn += '\t\t&& ((' + cm + '&' + mp + ')===' + mp + ')\n';
			else
				fn += '\t\t&& (' + cm + '&' + mp + ')\n';
		}
		if (mm)
			fn += '\t\t&& !(' + cm + '&' + mm + ')\n';
	}
	// for each set of objects in anyObjectsPresent, test that the cell contains at least one object of the set. That's for properties in a single layer.
	for (const anyObjectPresent of this.anyObjectsPresent)
	{
		fn += "\t\t&& (0";
		for (var i = 0; i < STRIDE_OBJ; ++i) {
			var aop = anyObjectPresent.data[i];
			if (aop)
				fn += "|(cellObjects" + i + "&" + aop + ")";
		}
		fn += ")";
	}
	fn += '\t)';
	return fn;
}

CellPattern.prototype.generateMatchFunction = function()
{
	var i
	var fn = ''
	var mul = STRIDE_OBJ === 1 ? '' : '*'+STRIDE_OBJ
	for (var i = 0; i < STRIDE_OBJ; ++i)
	{
		fn += '\tvar cellObjects' + i + ' = objects[i' + mul + (i ? '+'+i : '') + '];\n'
	}
	mul = STRIDE_MOV === 1 ? '' : '*'+STRIDE_MOV
	for (var i = 0; i < STRIDE_MOV; ++i)
	{
		fn += '\tvar cellMovements' + i + ' = movements[i' + mul + (i ? '+'+i: '') + '];\n';
	}
	fn += 'return ' + this.generateMatchString()+';';
	if (fn in matchCache)
		return matchCache[fn]
	// console.log(fn.replace(/\s+/g, ' '));
	return matchCache[fn] = new Function('i', 'objects', 'movements', fn);
}

CellPattern.prototype.toJSON = function() {
	return [
		this.movementMask, this.cellMask, this.nonExistenceMask,
		this.moveNonExistenceMask, this.moveStationaryMask, this.randomDirOrEntityMask,
		this.movementsToRemove
	];
};

CellPattern.prototype.replaceRigid = function(rule, level, cell_index)
{
	if (this.rigidMask === undefined)
		return false

	const replacementMovementLayerMask = this.replacement.movementsLayerMask

	var curRigidGroupIndexMask = level.rigidGroupIndexMask[cell_index] || new BitVec(STRIDE_MOV)
	var curRigidMovementAppliedMask = level.rigidMovementAppliedMask[cell_index] || new BitVec(STRIDE_MOV)

	// if level.rigidGroupIndexMask[cell_index] is undefined, we take a blank BitVec, so the test bellow will only succeed if rigidMask is zero. Which can only be true if
	// replacementMovementLayerMask is zero. But in that case, the content of the cell will not change, so we could simply not do replaceRigid in that case. And once
	// we have eliminated this possibility we know that if level.rigidGroupIndexMask[cell_index] is undefined, the test bellow will fail
	if ( this.rigidMask.bitsSetInArray(curRigidGroupIndexMask.data) || replacementMovementLayerMask.bitsSetInArray(curRigidMovementAppliedMask.data) )
		return false

	curRigidGroupIndexMask.ior(this.rigidMask)
	level.rigidGroupIndexMask[cell_index] = curRigidGroupIndexMask
	curRigidMovementAppliedMask.ior(replacementMovementLayerMask)
	level.rigidMovementAppliedMask[cell_index] = curRigidMovementAppliedMask
	return true
}

CellPattern.prototype.makeRigidMask = function(rule_rigidMask)
{
	if (this.replacement === null)
		return

	var replacementMovementLayerMask = this.replacement.movementsLayerMask.clone()
	replacementMovementLayerMask.iand(rule_rigidMask)
	if ( replacementMovementLayerMask.iszero() )
		return
	this.rigidMask = replacementMovementLayerMask
}

var _o2_5,_o3,_o6,_o7,_o8,_o9,_o10,_o11;
var _m3;

CellPattern.prototype.replace = function(rule, level, currentIndex)
{
	if (this.replacement === null)
		return false;

	this.replacement.cloneInto(static_CellReplacement)

	// Ensure the movements are cleared in layers from which an object is removed or some movement is set
	static_CellReplacement.movementsClear.ior(this.replacement.movementsLayerMask) // why is this not done directly at the creation of this.replacement?

	static_CellReplacement.applyRandoms()
	
	var oldCellMask = level.getCellInto(currentIndex, _o3)
	var oldMovementMask = level.getMovements(currentIndex)
	
	var curCellMask = oldCellMask.iClearAddInto(static_CellReplacement.objectsClear, static_CellReplacement.objectsSet, _o2_5)
	var curMovementMask = oldMovementMask.iClearAddInto(static_CellReplacement.movementsClear, static_CellReplacement.movementsSet, _m3)

	// Rigid + check if something changed
	if ( ( ! this.replaceRigid(rule, level, currentIndex) ) && oldCellMask.equals(curCellMask) && oldMovementMask.equals(curMovementMask) )
		return false

	// Sfx
	sfxCreateMask .iAddBut(curCellMask, oldCellMask)
	sfxDestroyMask.iAddBut(oldCellMask, curCellMask)

	// Update the level
	level.updateCellContent(currentIndex, curCellMask, curMovementMask)
	return true
}



var sprites = [ ]

var RandomGen = new RNG() // only used for execution of random movements and properties in rules.

const introstate = {
	title: "EMPTY GAME",
	attribution: "increpare",
	objectCount: 2,
	metadata:[],
	levels:[],
	bgcolor:"#000000",
	fgcolor:"#FFFFFF"
}

var state = introstate;

function tryPlaySimpleSound(soundname)
{
	if ( (state.sfx_Events !== undefined) && (state.sfx_Events[soundname] !== undefined) )
	{
		playSound(state.sfx_Events[soundname])
	}
}


// SAVE POINTS
// ===========

// Save point is only used for the 'continue' option of title screen.
// It's different from restartTarget, which is used for restarts triggered with the R key.

function setSavePoint(curlevel, new_restart_target)
{
	const key = ( state && state.metadata && (state.metadata.game_uri !== undefined) ) ? state.metadata.game_uri : document.URL
	try
	{
		if (curlevel === undefined)
		{
			storage_remove(key)
		}
		else if ( (curlevel.shouldSetSavePoint()) || (new_restart_target !== undefined) )
		{
			const l = state.levels[curlevel.level]
			storage_set(key, JSON.stringify(l.is_named ? Object.assign({name:l.name},curlevel) : curlevel) )
		}

		if (new_restart_target !== undefined)
		{
			storage_set(key+'_checkpoint', JSON.stringify(new_restart_target))
		}
		else
		{
			storage_remove(key+'_checkpoint')
		}
	}
	catch (ex) { }
}

function getSavePoint()
{
	let keys = [ document.URL ]
	if ( state && state.metadata && (state.metadata.game_uri !== undefined) )
	{
		keys.unshift(state.metadata.game_uri)
	}
	try {
		for (const key of keys)
		{
			if ( ! storage_has(key) )
				continue
			const stored_level = JSON.parse(storage_get(key))
			const result_level = (stored_level instanceof Object)
				? LevelState.prototype.findSame(stored_level)
				: LevelState.prototype.makeFromOldSchoolIndex(stored_level)
			if ( ! storage_has(key+'_checkpoint') )
				return [ result_level, undefined ]

			let curlvlTarget = JSON.parse(storage_get(key+'_checkpoint'))

			let arr = []
			const from = curlvlTarget.hasOwnProperty('lev') ? curlvlTarget.lev.objects : curlvlTarget.dat // compatibility feature
			for(var p in Object.keys(from))
			{
				arr[p] = from[p]
			}
			curlvlTarget.lev.objects = new Int32Array(arr)

			return [ result_level, curlvlTarget ]
		}
	} catch(ex) { }
	return [ undefined, undefined ]
}




// LOADING LEVELS
// ==============

function loadLevelFromLevelDat(state, leveldat, randomseed)
{
	RandomGen = new RNG(randomseed)
	forceRegenImages() // why do we need that?
	
	execution_context.resetUndoStack()

	level.restore(leveldat)
	execution_context.setRestartTarget()

	screen_layout.content = level_screen
	if (state.metadata.flickscreen !== undefined)
	{
		screen_layout.content = tiled_world_screen
	}
	else if (state.metadata.zoomscreen !== undefined)
	{
		screen_layout.content = camera_on_player_screen
	}
	screen_layout.content.level = level

	// init oldflickscreendat
	if ( (state.metadata.flickscreen !== undefined) || (state.metadata.zoomscreen !== undefined) )
	{
		oldflickscreendat = undefined
		screen_layout.content.get_viewport()
	}

	keybuffer = []

	execution_context.run_rules_on_level_start_phase = ('run_rules_on_level_start' in state.metadata)
	if (execution_context.run_rules_on_level_start_phase)
	{
		processInput(processing_causes.run_rules_on_level_start)
	}

	clearInputHistory()
	canvasResize()
}

function loadLevelFromState(state, level_index, randomseed, set_save = true, save_data = undefined)
{
	curlevel = level_index
	if (level_index.box == 2)
	{
		tryPlaySimpleSound('startlevel')
		loadLevelFromLevelDat(state, (save_data !== undefined) ? save_data.lev : state.levels[level_index.level].grid, randomseed)
	}
	else
	{
		showTempMessage(level_index.getMessage())
	}
	if (set_save)
	{
		setSavePoint(level_index, save_data) // always set the save point at the start of level
	}
}




// Backup levels
// =============

function executionContext()
{
	// Undo/restart/checkpoints data
	this.backups = [] // only used in doUndo
	this.restartTarget = null // last checkpoint reached.
	this.run_rules_on_level_start_phase = null

	// Output queue
	this.commandQueue = new CommandsSet()
	this.commandQueue.sourceRules = [] // only used with verbose_logging
}
var execution_context = new executionContext()

executionContext.prototype.resetCommands = function()
{
	this.commandQueue.reset()
	this.commandQueue.sourceRules = []
}


executionContext.prototype.resetUndoStack = function()
{
	this.backups = []
}

executionContext.prototype.backUp = function()
{
	return {
		lev: level.backUp(),
		oldflickscreendat: oldflickscreendat.concat([])
	}
}

executionContext.prototype.forSerialization = function()
{
	return {
		lev: level.forSerialization(),
		oldflickscreendat: oldflickscreendat.concat([])
	}
}

executionContext.prototype.restore = function(backup = this.restartTarget)
{
	oldflickscreendat = backup.oldflickscreendat.concat([])
	level.restore(backup.lev)
	this.resetCommands()
}

executionContext.prototype.pushToUndoStack = function(bak = this.backUp())
{
	this.backups.push(bak)
}

executionContext.prototype.setRestartTarget = function(bak = this.backUp())
{
	this.restartTarget = bak
}


// Youtube
// =======

function tryDeactivateYoutube()
{
	var youtubeFrame = document.getElementById("youtubeFrame");
	if (youtubeFrame){
		document.body.removeChild(youtubeFrame);
	}
}

var ifrm;
function tryActivateYoutube(){
	var youtubeFrame = document.getElementById("youtubeFrame");
	if (youtubeFrame){
		return;
	}
	if (canYoutube) {
		if ('youtube' in state.metadata) {
			var youtubeid=state.metadata['youtube'];
			var url = "https://www.youtube.com/embed/"+youtubeid+"?autoplay=1&loop=1&playlist="+youtubeid;
			ifrm = document.createElement("IFRAME");
			ifrm.setAttribute("src",url);
			ifrm.setAttribute("id","youtubeFrame");
			ifrm.style.visibility="hidden";
			ifrm.style.width="500px";
			ifrm.style.height="500px";
			ifrm.style.position="absolute";
			ifrm.style.top="-1000px";
			ifrm.style.left="-1000px";
			document.body.appendChild(ifrm);
		}
	}
}


// GAME STATE
// ==========

// Current level
function LevelState(level_index = 0, box_index = 0, msg_index = -1)
{
	this.level = level_index
	this.box = box_index // 0=messages before title, 1=messages after title, 2=level, 3=messages after level
	this.msg = msg_index
}

LevelState.prototype.getMessage = function()
{
	return state.levels[this.level].boxes[this.box][this.msg]
}

LevelState.prototype.nextBox = function()
{
	this.box += 1
	this.msg = -1
	return this.next()
}
LevelState.prototype.nextLevel = function() // TODO: assumes it exists
{
	this.level += 1
	this.box = -1
	return this.nextBox()
}

LevelState.prototype.next = function()
{
	if (this.box == 2)
		return this.nextBox()
	const l = state.levels[this.level]
	if (l === undefined)
		return null
	if (this.msg < l.boxes[this.box].length - 1)
	{
		this.msg += 1
		return this
	}
	if (this.box == 3)
		return this.nextLevel()
	if (this.box == 0)
		return this.nextBox()
	this.box = 2
	this.msg = -1
	return this
}

LevelState.prototype.findSame = function(ls)
{
	const index = (ls.name !== undefined) ? state.levels.findIndex(l => l.is_named && (l.name == ls.name)) : ls.level
	return new LevelState( (index<0) ? ls.level : index, ls.box, ls.msg)
}

LevelState.prototype.makeFromOldSchoolIndex = function(old_level_index)
{
	let result = new LevelState()
	for (; old_level_index >= 0; --old_level_index)
		result = result.next()
	return result
}

LevelState.prototype.shouldSetSavePoint = function()
{
	if (this.msg > 0) // Only save at the beginning of message boxes
		return false
	if (this.level > 0)
		return true
	return (this.box > (new LevelState()).next().box)
}

// Only called at the end of compile()
// TODO: level_index being anything else than null is editor/unit_tests only features and should be removed from exported games.
function setGameState(_state, level_index, randomseed = null)
{
	oldflickscreendat=[];
	timer=0;
	autotick=0;
	winning=false;
	againing=false;
	msg_screen.done = false
	STRIDE_MOV=_state.STRIDE_MOV;
	STRIDE_OBJ=_state.STRIDE_OBJ;
	
	sfxCreateMask=new BitVec(STRIDE_OBJ);
	sfxDestroyMask=new BitVec(STRIDE_OBJ);

	// show the title screen if there's no level_index
	if ( (level_index === undefined) && ( (state.levels.length === 0) || (_state.levels.length === 0) ) )
	{
		level_index = null
	}
	RandomGen = new RNG(randomseed)

	state = _state

	//set sprites
	sprites = []
	for (var object of state.identifiers.objects)
	{
		sprites[object.id] = {
			colors: object.colors,
			dat: object.spritematrix,
			offset: object.sprite_offset
		}
	}

	autotick = 0
	autotickinterval = (state.metadata.realtime_interval !== undefined) ? state.metadata.realtime_interval*1000 : 0
	repeatinterval = (state.metadata.key_repeat_interval !== undefined) ? state.metadata.key_repeat_interval*1000 : 150
	againinterval = (state.metadata.again_interval !== undefined) ? state.metadata.again_interval*1000 : 150
	norepeat_action = (state.metadata.norepeat_action !== undefined)
	if ( throttle_movement && (autotickinterval === 0) )
	{
		logWarning("throttle_movement is designed for use in conjunction with realtime_interval. Using it in other situations makes games gross and unresponsive, broadly speaking.  Please don't.");
	}
	
	if (typeof level_index === 'function')
	{
		level_index = level_index(state.levels)
	}

	if (level_index !== undefined)
	{
		winning = false
		timer = 0
		msg_screen.done = false
		pause_menu_screen.done = false
		level = new Level()
		if ( (level_index === null) || (level_index === -1) )
		{
			// restart
			goToTitleScreen(false)
		}
		else
		{
			if ( ! (level_index instanceof LevelState) ) // old school level indexes: integers including messages
			{
				level_index = LevelState.prototype.makeFromOldSchoolIndex(level_index)
			}
			// go to given level (can only happen when called from makeGIF or from the level editor with a callback level func)
			loadLevelFromState(state, level_index, randomseed, false)
		}
	}

	canvasResize()

	if ( (state.sounds.length === 0) && (state.metadata.youtube === null) )
	{
		killAudioButton()
	}
	else
	{
		showAudioButton()
	}
	
}


// MORE LEVEL STUFF
// ================


function DoRestart(bak)
{
	if ( (bak === undefined) && ('norestart' in state.metadata) )
		return
	execution_context.pushToUndoStack(bak)

	if (verbose_logging) { consolePrint("--- restarting ---", true) }

	execution_context.restore()

	tryPlaySimpleSound('restart')

	if ('run_rules_on_level_start' in state.metadata)
	{
		processInput(processing_causes.run_rules_on_level_start)
	}
	
	execution_context.resetCommands()
}

executionContext.prototype.backupDiffers = function()
{
	if (this.backups.length === 0)
		return true

	const bak = this.backups[this.backups.length-1]
	return level.objects.some( (o, i) => o !== bak.lev.objects[i] )
}

executionContext.prototype.doUndo = function()
{
	if ( ( ! screen_layout.alwaysAllowUndo() ) && ('noundo' in state.metadata) )
		return

	// See Pattern:Script issue #23
	while (this.backupDiffers() === false)
	{
		this.backups.pop()
	}
	if (this.backups.length === 0)
	{
		if (verbose_logging) { consolePrint("--- nothing to undo ---", true) }
		return
	}

	forceUndo(this.backups[this.backups.length-1])
	this.backups = this.backups.splice(0, this.backups.length-1)
	tryPlaySimpleSound('undo')
}

function forceUndo(backup)
{
	if (verbose_logging) { consolePrint("--- undoing ---", true) }
	execution_context.restore(backup)
}


// Match rules and collect commands
// ================================

function applyRandomRuleGroup(ruleGroup, level)
{
	var propagated = false

	var matches = []
	for (const [ruleIndex, rule] of ruleGroup.entries())
	{
		const ruleMatches = rule.findMatches(level)
		if (ruleMatches.length > 0)
		{
			for (const tuple of cartesian_product(...ruleMatches))
			{
				matches.push([rule, tuple])
			}
		}		
	}

	if (matches.length === 0)
		return false

	const [rule, tuple] = RandomGen.pickInArray(matches)
	const modified = rule.applyAt(level, tuple, false)
	rule.queueCommands()
	return modified
}

const max_loop_count = 200

function applyRuleGroup(ruleGroup, level)
{
	if (ruleGroup[0].isRandom)
		return applyRandomRuleGroup(ruleGroup, level)

	var skip_from = ruleGroup.length - 1
	var loopcount = 1
	var result = false
	while(loopcount <= max_loop_count)
	{
		var last_applied = null
		for (const [i, rule] of ruleGroup.entries())
		{
			if (rule.tryApply(level))
				last_applied = i
			if ( (i === skip_from) && (last_applied === null))
				return result
		}
		skip_from = last_applied
		result = true
		loopcount++
	}
	logErrorCacheable('Got caught looping lots in a rule group :O', ruleGroup[0].lineNumber, true)
	return result
}

//for each rule, try to match it
function applyRules(rules, level, loopPoint, bannedGroup)
{
	//when we're going back in, let's loop, to be sure to be sure
	var loopCount = 0
	var ruleGroupIndex = 0
	var last_applied = null
	var skip_from = null
	var skip_to = null

	while (ruleGroupIndex < rules.length)
	{
		if ( ! (bannedGroup && bannedGroup[ruleGroupIndex]) && applyRuleGroup(rules[ruleGroupIndex], level) )
		{
			last_applied = ruleGroupIndex
		}
		// loopPoint[ruleGroupIndex] is set on the last ruleGroupIndex before an endloop and contains the first ruleGroupIndex after the matching startloop
		if ( (last_applied !== null) && (loopPoint[ruleGroupIndex] !== undefined) )
		{
			skip_from = last_applied
			skip_to = ruleGroupIndex
			ruleGroupIndex = loopPoint[ruleGroupIndex]
			last_applied = null
			loopCount++
			if (loopCount <= max_loop_count)
				continue
			logErrorCacheable('got caught in an endless startloop...endloop vortex, escaping!', rules[ruleGroupIndex][0].lineNumber, true)
			return
		}
		if ( (skip_from === ruleGroupIndex) && (last_applied === null) )
		{
			ruleGroupIndex = skip_to
		}
		ruleGroupIndex++
	}
}



// Apply global effects of rules
// =============================


const dirMasksDelta = {
	 1:[ 0,-1],//up
	 2:[ 0, 1],//down
	 4:[-1, 0],//left
	 8:[ 1, 0],//right
	15:[ 0, 0],//moving?
	16:[ 0, 0],//action
	 3:[ 0, 0]//'no'
}

Level.prototype.repositionEntitiesAtCell = function(positionIndex, seedsToPlay_CanMove, nb_layers)
{
	var movementMask = this.getMovements(positionIndex)
	if (movementMask.iszero())
		return false

	var sourceMask = this.getCellInto(positionIndex, _o8)
	const [sx, sy] = this.cellCoord(positionIndex)

	var moved = false
	for (var layer=0; layer<nb_layers; layer++)
	{
		const dirMask = movementMask.getshiftor(0x1f, 5*layer)
		if (dirMask === 0)
			continue

		const [dx, dy] = dirMasksDelta[dirMask]
		const [tx, ty] = [sx+dx, sy+dy]

		if ( (clamp(0, tx, this.width-1) != tx) || (clamp(0, ty, this.height-1) != ty) )
			continue

		const targetIndex = ty + tx*this.height

		const layerMask = state.layerMasks[layer]
		var targetMask = this.getCellInto(targetIndex, _o7)

		if ( (targetIndex !== positionIndex) && layerMask.anyBitsInCommon(targetMask) ) // if moving and collision.
			continue

		// TODO: this test is there because at that point we know that something will move in that layer, but it's not the place to do that
		for (const o of state.sfx_MovementMasks[layer])
		{
			if ( (dirMask & o.directionMask) && o.objectMask.anyBitsInCommon(sourceMask) && (seedsToPlay_CanMove.indexOf(o.seed) === -1) )
			{
				seedsToPlay_CanMove.push(o.seed) // TODO: we should use a set or bitvec instead of an array
			}
		}

		movementMask.ishiftclear(dirMask, 5*layer)
		moved = true

		if (targetIndex === positionIndex)
			continue

		var movingEntities = sourceMask.clone()
		movingEntities.iand(layerMask)
		targetMask.ior(movingEntities)

		sourceMask.iclear(layerMask)
		this.setCell(targetIndex, targetMask) // TODO: we write the whole cell content, when we just need to do getCell(position).clear(layerMask), which could be done faster with ishiftclear

		this.colCellContents[tx].ior(movingEntities)
		this.rowCellContents[ty].ior(movingEntities)
		// this.mapCellContents.ior(movingEntities) // would not change
	}
	if ( ! moved )
		return false

	this.setCell(positionIndex, sourceMask)
	this.setMovements(positionIndex, movementMask)
	return moved
}

//if this returns!=null, need to go back and reprocess
function resolveMovements(level, bannedGroup, seedsToPlay_CanMove, seedsToPlay_CantMove, nb_layers)
{
	var moved = true
	while(moved)
	{
		moved = false
		for (var i=0; i<level.n_tiles; i++)
		{
			moved |= level.repositionEntitiesAtCell(i, seedsToPlay_CanMove, nb_layers)
		}
	}
	var doUndo = false

	for (var i=0; i<level.n_tiles; i++)
	{
		const cellMask = level.getCellInto(i, _o6)
		var movementMask = level.getMovements(i)
		if ( ! movementMask.iszero() )
		{
			const rigidMovementAppliedMask = level.rigidMovementAppliedMask[i]
			if (rigidMovementAppliedMask !== 0)
			{
				movementMask.iand(rigidMovementAppliedMask)
				if ( ! movementMask.iszero() )
				{
					//find what layer was restricted
					for (var j=0; j<nb_layers; j++)
					{
						if (movementMask.getshiftor(0x1f, 5*j) !== 0)
						{
							//this is our layer!
							var rigidGroupIndex = level.rigidGroupIndexMask[i].getshiftor(0x1f, 5*j)
							rigidGroupIndex-- //group indices start at zero, but are incremented for storing in the bitfield
							bannedGroup[ state.rigidGroupIndex_to_GroupIndex[rigidGroupIndex] ] = true
							doUndo = true
							break
						}
					}
				}
			}
			for (const [layer, sfx_objects] of state.sfx_MovementFailureMasks.entries() )
			{
				const dirMask = movementMask.getshiftor(0x1f, 5*layer)
				for (const o of sfx_objects)
				{				
					if ( (dirMask & o.objectMask) && o.objectMask.anyBitsInCommon(cellMask) && (seedsToPlay_CantMove.indexOf(o.seed) === -1) )
					{
						seedsToPlay_CantMove.push(o.seed)
					}
				}
			}
		}

		for (var j=0; j<STRIDE_MOV; j++)
		{
			level.movements[i*STRIDE_MOV + j] = 0
		}
		level.rigidGroupIndexMask[i] = 0
		level.rigidMovementAppliedMask[i] = 0
	}
	return doUndo
}


function showTempMessage(message)
{
	tryPlaySimpleSound('showmessage')
	msg_screen.doMessage(message)
	canvasResize()
}

CommandsSet.prototype.processOutput = function()
{
	for (var k = CommandsSet.command_keys['sfx0']; k <= CommandsSet.command_keys['sfx10']; k++)
	{
		if (this.get(k))
		{
			tryPlaySimpleSound(CommandsSet.commandwords[k])
		}
	}
	if ( (unitTesting === false) && (this.message !== null) )
	{
		keybuffer = []
		msg_screen.done = false
		showTempMessage(this.message)
	}
}


// Process inputs
// ==============

var sfxCreateMask = null
var sfxDestroyMask = null

Level.prototype.getPlayerPositions = function()
{
	var result = []
	var playerMask = state.playerMask
	for (i=0; i<this.n_tiles; i++) // TODO: this scans the whole level, can't we optimize that by using level.mapCellContents, level.rowCellContents, or level.colCellContents?
	{
		this.getCellInto(i,_o11)
		if (playerMask.anyBitsInCommon(_o11))
		{
			result.push(i)
		}
	}
	return result
}

Level.prototype.startMovement = function(dir)
{
	const playerPositions = this.getPlayerPositions()
	for (const playerPosIndex of playerPositions)
	{
		var cellMask = this.getCell(playerPosIndex)
		var movementMask = this.getMovements(playerPosIndex)

		cellMask.iand(state.playerMask)

		for (var i=0; i<state.objectCount; i++)
		{
			if (cellMask.get(i)) {
				movementMask.ishiftor(dir, 5 * state.identifiers.objects[ state.idDict[i] ].layer)
			}
		}

		this.setMovements(playerPosIndex, movementMask)
	}
	return playerPositions
}


const max_rigid_loops = 50

const processing_causes = { run_rules_on_level_start: -1, againing_test: -2, again_frame: -3, autotick: -4, } // positive inputs are directions/action

/* returns a bool indicating if anything changed */
function processInput(input)
{
	againing = false
	const in_level_start_animation = execution_context.run_rules_on_level_start_phase

	if (verbose_logging)
	{
		if (input < 0)
		{
			consolePrint('Turn starts with no input.')
		}
		else
		{
			consolePrint('=======================');
			consolePrint('Turn starts with input of ' + ['up','left','down','right','action'][input]+'.')
		}
	}

	var bak = execution_context.backUp()

	// TODO: use a global const generated from the one that defines these bits. And use a more consistent ordering of directions
	const playerPositions = (input >= 0) ? level.startMovement( ([1, 4, 2, 8, 16])[input] ) : []

	bannedGroup = []
	execution_context.resetCommands()

	level.calculateRowColMasks()
	const startState = {
		objects: new Int32Array(level.objects),
		movements: new Int32Array(level.movements),
		rigidGroupIndexMask: level.rigidGroupIndexMask.concat([]),
		rigidMovementAppliedMask: level.rigidMovementAppliedMask.concat([]),
		// colCellContents: level.colCellContents.map(x => x.clone()),
		// rowCellContents: level.rowCellContents.map(x => x.clone()),
		// mapCellContents: level.mapCellContents.clone(),
	}

	sfxCreateMask.setZero()
	sfxDestroyMask.setZero()

	var seedsToPlay_CanMove = []
	var seedsToPlay_CantMove = []

	var i = max_rigid_loops
	while (true)
	{
		if (verbose_logging) { consolePrint('applying rules') }
		applyRules(state.rules, level, state.loopPoint, bannedGroup)

		// not particularly elegant, but it'll do for now - should copy the world state and check after each iteration
		if ( ! resolveMovements(level, bannedGroup, seedsToPlay_CanMove, seedsToPlay_CantMove, state.collisionLayers.length) )
		{
			if (verbose_logging) { consolePrint('applying late rules') }
			applyRules(state.lateRules, level, state.lateLoopPoint)
			break
		}

		// trackback
		consolePrint("Rigid movement application failed, rolling back")
		//don't need to concat or anythign here, once something is restored it won't be used again.
		level.objects = new Int32Array(startState.objects)
		level.movements = new Int32Array(startState.movements)
		level.rigidGroupIndexMask = startState.rigidGroupIndexMask.concat([])
		level.rigidMovementAppliedMask = startState.rigidMovementAppliedMask.concat([])
		// TODO: shouldn't we also save/restore the level data computed by level.calculateRowColMasks()?
		// -> I tried and it does not help with speed, but is it correct not to do it?
		// level.colCellContents = startState.colCellContents.map(x => x.clone())
		// level.rowCellContents = startState.rowCellContents.map(x => x.clone())
		// level.mapCellContents = startState.mapCellContents.clone()
		execution_context.resetCommands()
		sfxCreateMask.setZero()
		sfxDestroyMask.setZero()
		// TODO: shouldn't we also reset seedsToPlay_CanMove and seedsToPlay_CantMove?

		i--
		if (i <= 0)
		{
			consolePrint('Cancelled '+max_rigid_loops+' rigid rules, gave up. Too many loops!')
			break
		}
	}

	execution_context.run_rules_on_level_start_phase = false // this will be reset to previous value only if againing

	// require_player_movement
	// TODO: shouldn't this be tested after CANCEL and RESTART commands? (and AGAIN ?)
	// TODO: should this be ignored in run_rules_on_level_start_phase?
	if ( (playerPositions.length > 0) && (state.metadata.require_player_movement !== undefined) )
	{
		// TODO: technically, this checks that at least one cell initially containing a player does not contain a player at the end. It fails to detect permutations of players.
		if ( playerPositions.every( pos => ! state.playerMask.bitsClearInArray(level.getCell(pos).data) ) )
		{
			if (verbose_logging) { consolePrint('require_player_movement set, but no player movement detected, so cancelling turn.', true) }
			forceUndo(bak)
			return false
		}
		//play player cantmove sounds here
	}


	// CANCEL command
	if (execution_context.commandQueue.get(CommandsSet.command_keys.cancel))
	{
		if (verbose_logging)
		{
			consolePrintFromRule('CANCEL command executed, cancelling turn.', execution_context.commandQueue.sourceRules[CommandsSet.command_keys.cancel], true)
		}
		execution_context.commandQueue.processOutput()
		tryPlaySimpleSound('cancel')
		forceUndo(bak)
		return false
	} 

	// RESTART command
	if (execution_context.commandQueue.get(CommandsSet.command_keys.restart))
	{
		if (verbose_logging)
		{
			consolePrintFromRule('RESTART command executed, reverting to restart state.', execution_context.commandQueue.sourceRules[CommandsSet.command_keys.restart], true)
		}
		execution_context.commandQueue.processOutput()
		if (in_level_start_animation)
		{
			if (verbose_logging) consolePrint('Restart cancelled because it would cause an infinite loop if executed during a "run_rules_on_level_start" phase.')
		}
		else
		{
			DoRestart(bak)
			return true
		}
	} 

	const modified = level.objects.some( (o, i) => o !== bak.lev.objects[i] )

	if (input === processing_causes.againing_test) // this is a fake frame just to check that applying again would cause some change
	{
		if (modified)
		{
			forceUndo(bak)
			return true
		}
		return (execution_context.commandQueue.get(CommandsSet.command_keys.win))
	}

	// Add the frame to undo stack if something changed in the frame and it has some actual player input (not ticks, not apply rules on level start, not againing)
	if (modified && (input >= 0) )
	{
		if ( execution_context.commandQueue.get(CommandsSet.command_keys.nosave) )
		{
			if (verbose_logging) consolePrintFromRule('NOSAVE command executed, this frame will NOT be pushed on the undo stack.', execution_context.commandQueue.sourceRules[CommandsSet.command_keys.nosave])
		}
		else
		{
			execution_context.backups.push(bak)
		}
	}

	for (const seed of seedsToPlay_CantMove)
	{
		playSound(seed)
	}

	for (const seed of seedsToPlay_CanMove)
	{
		playSound(seed)
	}

	for (const entry of state.sfx_CreationMasks)
	{
		if (sfxCreateMask.anyBitsInCommon(entry.objectMask))
		{
			playSound(entry.seed)
		}
	}

	for (const entry of state.sfx_DestructionMasks)
	{
		if (sfxDestroyMask.anyBitsInCommon(entry.objectMask))
		{
			playSound(entry.seed)
		}
	}

	execution_context.commandQueue.processOutput()

	if (screen_layout.content !== msg_screen)
	{
		if (verbose_logging) { consolePrint('Checking win condition.') }
		checkWin(input)
	}

	if ( ! winning )
	{
		if (execution_context.commandQueue.get(CommandsSet.command_keys.checkpoint))
		{
			if (verbose_logging)
			{ 
				consolePrintFromRule('CHECKPOINT command executed, saving current state to the restart state.', execution_context.commandQueue.sourceRules[CommandsSet.command_keys.checkpoint])
			}
			const new_restart_target = execution_context.forSerialization()
			if ( ! in_level_start_animation )
			{
				setSavePoint(curlevel, new_restart_target)
			}
			execution_context.setRestartTarget(new_restart_target)
		}	 

		if ( modified && execution_context.commandQueue.get(CommandsSet.command_keys.again) )
		{
			const r = execution_context.commandQueue.sourceRules[CommandsSet.command_keys.again]

			// first have to verify that something's changed
			// TODO: instead, we could precompute the next state and activate it when the again_interval times out. It would require to store the to-be-displayed console messages
			// with the precomputed level, but I think we can do that, and for emulation/debugging purposes it might be good to associate the error messages with the state
			let old_verbose_logging = verbose_logging
			verbose_logging = false
			if (processInput(processing_causes.againing_test)) // This is the only place we call processInput with the againing_test cause
			{
				if (old_verbose_logging) { consolePrintFromRule('AGAIN command executed, with changes detected - will execute another turn.', r) }
				againing = true // this is the only place where we set againing to true
				timer = 0
				execution_context.run_rules_on_level_start_phase = in_level_start_animation
			}
			else
			{
				if (old_verbose_logging) { consolePrintFromRule('AGAIN command not executed, it wouldn\'t make any changes.', r) }
			}
			verbose_logging = old_verbose_logging
		}
	}

	execution_context.resetCommands()

	if (verbose_logging) { consoleCacheDump() }

	return modified
}


// only called from update when closing a message, and from processInput
function checkWin(cause_of_processing)
{
	if ( ! execution_context.commandQueue.get(CommandsSet.command_keys.win) )
	{
		if (state.winconditions.length === 0)
			return

		for (const [quantifier, filter1, filter2] of state.winconditions)
		{
			// TODO: can we use level.mapCellContents to optimize this?
			// "no"   FAILS    if we find an x WITH    an y
			// "some" SUCCEEDS if we find an x WITH    an y
			// "all"  FAILS    if we find an x WITHOUT an y
			var rulePassed = (quantifier != 0)
			const search_WITH = (quantifier < 1)
			for (var i=0; i<level.n_tiles; i++)
			{
				const cell = level.getCellInto(i,_o10)
				if ( ( ! filter1.bitsClearInArray(cell.data) ) && (search_WITH ^ filter2.bitsClearInArray(cell.data)) )
				{
					rulePassed = ! rulePassed
					break
				}
			}
			if ( ! rulePassed )
				return
		}
	}

	// won
	if (cause_of_processing === processing_causes.run_rules_on_level_start)
	{
		// We can win in rules_on_level_phase but not on first frame, for making cutscene levels.
		consolePrint("Win Condition Satisfied (However this is in the run_rules_on_level_start rule pass, so I'm going to ignore it for you.  Why would you want to complete a level before it's already started?!)")
		return
	}

	consolePrint('Win Condition Satisfied')
	if ( screen_layout.dontDoWin() || winning )
		return

	againing = false
	tryPlaySimpleSound('endlevel')
	if (unitTesting)
	{
		nextLevel()
		return
	}
	winning = true
	timer = 0
}

function nextLevel()
{
	againing = false

	const next_level = curlevel.next()
	if (next_level === null) // end game
	{
		setSavePoint() // actually removes save point
		tryPlaySimpleSound('endgame') // TODO: we may need a small delay to play the sound before going back to the title screen which also plays a sound?
		goToTitleScreen(false)
		return
	}
	
	msg_screen.done = false
	loadLevelFromState(state, next_level)
}

function goToTitleScreen(escapable = true)
{
	againing = false
	;[ title_screen.curlevel, title_screen.curlevelTarget ] = getSavePoint()
	title_screen.makeTitle()
	title_screen.openMenu(escapable ? undefined : null)
	clearInputHistory()
}


function closeMessageScreen()
{
	msg_screen.done = false
	if (curlevel.box != 2) // was a message level
	{
		nextLevel()
		return
	}

	if (state.metadata.flickscreen !== undefined)
	{
		screen_layout.content = tiled_world_screen
	}
	else if (state.metadata.zoomscreen  !== undefined)
	{
		screen_layout.content = camera_on_player_screen
	}
	else
	{
		screen_layout.content = level_screen
	}
	canvasResize()
	checkWin()
}



/*
credits

brunt of the work by increpare (www.increpare.com)

all open source mit license blah blah

testers:
none, yet

code used

colors used
color values for named colours from arne, mostly (and a couple from a 32-colour palette attributed to him)
http://androidarts.com/palette/16pal.htm

the editor is a slight modification of codemirror (codemirror.net), which is crazy awesome.

for post-launch credits, check out activty on github.com/increpare/PuzzleScript

*/

const relativedirs = ['^', 'v', '<', '>', 'moving','stationary','parallel','perpendicular', 'no'];
const logicWords = ['all', 'no', 'on', 'in', 'some'];
const sectionNames = ['tags', 'objects', 'legend', 'sounds', 'collisionlayers', 'rules', 'winconditions', 'levels', 'mappings'];

const reg_name = /[\p{Letter}\p{Number}_]+/u;
const reg_tagged_name = /[\p{Letter}\p{Number}_:]+/u
const reg_maptagged_name = /[\p{Letter}\p{Number}_]+(?::[\p{Letter}\p{Number}_<^>]+)*/u
const reg_tagname = /[\p{Letter}\p{Number}_]+/u;
const reg_number = /[\d]+/;
const reg_soundseed = /\d+(?::[1-3]\d|:[1-9])?\b/
const reg_sprite_transform = /\s*(shift:(?:[\p{Letter}\p{Number}_]+|[>v<^])(?::-?\d+|:[\p{Letter}\p{Number}_]+)?|[-]|\||rot:(?:[\p{Letter}\p{Number}_]+|[>v<^]):(?:[\p{Letter}\p{Number}_]+|[>v<^])|translate:(?:[\p{Letter}\p{Number}_]+|[>v<^]):(?:[\p{Letter}\p{Number}_]+|-?\d+))\s*/u
const reg_spriterow = /[\.0-9]+[\p{Separator}\s]*/u;
const reg_sectionNames = /(tags|objects|collisionlayers|legend|sounds|rules|winconditions|levels|mappings)\b/u;
const reg_equalsrow = /[\=]+/;
const reg_notcommentstart = /[^\(]+/;
const reg_csv_separators = /[ \,]*/;
const reg_layergroups_separator = /\s*--([v^|][<>-]|[<>-][v^|])?(?:--)?\s*/
const reg_soundverbs = /(move|action|create|destroy|cantmove|undo|restart|titlescreen|gamescreen|pausescreen|startgame|cancel|endgame|startlevel|endlevel|showmessage|closemessage|sfx0|sfx10?|sfx2|sfx3|sfx4|sfx5|sfx6|sfx7|sfx8|sfx9)\b/u
const reg_directions = /^(action|up|down|left|right|\^|v|\<|\>|moving|stationary|parallel|perpendicular|horizontal|orthogonal|vertical|no|randomdir|random)$/;
const reg_loopmarker = /^(startloop|endloop)$/;
const reg_ruledirectionindicators = /^(up|down|left|right|horizontal|vertical|orthogonal|late|rigid)\b$/;
const reg_sounddirectionindicators = /(up|down|left|right|horizontal|vertical|orthogonal)\b/u;
const reg_winconditionquantifiers = /^(all|any|no|some)\b$/;
const reg_keywords = /(checkpoint|tags|objects|collisionlayers|legend|sounds|rules|winconditions|\.\.\.|levels|up|down|left|right|^|\||\[|\]|v|\>|\<|no|horizontal|orthogonal|vertical|any|all|no|some|moving|stationary|parallel|perpendicular|action)\b/;
const reg_level_commands = /(level|message|title(?::(\w*))?)\b/u


// ======== PARSER CONSTRUCTORS =========

// NOTE: CodeMirror creates A LOT of instances of this class, like more than 100 at the initial parsing. So, keep it simple!
function PuzzleScriptParser(sprites_in_code, sprites_to_compile)
{
	/* Variables only used when the parser is called by the compiler, ignored when called by CodeMirror */
	this.sprites_in_code = sprites_in_code
	this.sprites_to_compile = sprites_to_compile
	this.lineNumber = 0

	/*
		permanently useful
	*/
	this.identifiers = new Identifiers();

	/*
		for parsing
	*/
	this.commentLevel = 0

	this.section = ''

	this.is_start_of_line = false
	this.tokenIndex = 0
	this.lastTokenIndex = 0 // value of tokenIndex at the end of the previous line, if in the same section
	this.line_type = 0

	// metadata defined in the preamble
	this.metadata_keys = []   // TODO: we should not care about the keys, since it's a predefined set
	this.metadata_values = [] // TODO: we should initialize this with the predefined default values.

	// parsing state data used only in the OBJECTS section. Will be deleted by compiler.js/compileTextCode.
	this.current_identifier_index = undefined // The index of the ientifier which definition is currently being parsed
	this.objects_spritematrix = []

	// data for the LEGEND section.
	this.abbrevNames = []

	// data for the MAPPINGS section
	this.current_mapping = {
		from: {
			name: '',
			identifier_index: null,
			set: new Set(),
			array: []
		},
		name: '',
		mapping_index: null,
		result: [],
	}

	this.sounds = []

	this.collisionLayers = [] // an array of collision layers (from bottom to top), each as a Set of the indexes of the objects belonging to that layer
	this.collision_layer_groups = [ {first_layer: 0, horizontal_first: true, leftward: false, upward: false }]
	this.backgroundlayer = null;
	this.current_expansion_context = new ExpansionContext()
	this.current_layer_parameters = []

	this.rules = []

	this.winconditions = []

	this.levels = [ {boxes: [[],[],[],], grid: []} ]
}

// Copying is only done by CodeMirror, never when called by the compiler
PuzzleScriptParser.prototype.copy = function()
{
	const result = new PuzzleScriptParser()

	result.identifiers = this.identifiers.copy()

	result.commentLevel = this.commentLevel
	result.section = this.section

	result.is_start_of_line = this.is_start_of_line
	result.tokenIndex = this.tokenIndex
	result.lastTokenIndex = this.lastTokenIndex
	result.line_type = this.line_type

	result.metadata_keys   = this.metadata_keys.concat([])
	result.metadata_values = this.metadata_values.concat([])

	result.current_identifier_index = this.current_identifier_index
	result.objects_spritematrix = Array.from(this.objects_spritematrix)

	result.current_mapping = {
		from: {
			name: this.current_mapping.from.name,
			identifier_index: this.current_mapping.from.identifier_index,
			set: new Set(this.current_mapping.from.set),
			array: Array.from(this.current_mapping.from.array)
		},
		name: this.current_mapping.name,
		mapping_index: this.current_mapping.mapping_index,
		result: Array.from(this.current_mapping.result),
	}

	result.sounds = this.sounds.map( i => i.concat([]) )

	result.collisionLayers = this.collisionLayers.map( s => new Set(s) )
	result.collision_layer_groups = this.collision_layer_groups.concat()
	result.backgroundlayer = this.backgroundlayer
	result.current_expansion_context = this.current_expansion_context.copy()
	result.current_layer_parameters = Array.from( this.current_layer_parameters )

	result.rules = this.rules.concat([])

	result.winconditions = this.winconditions.map( i => i.concat([]) )

	result.abbrevNames = this.abbrevNames.concat([])

	// TODO: replace this with structuredClone
	result.levels = this.levels.map( level => { 
		let l = Object.assign({}, level)
		l.grid = level.grid.concat([])
		l.boxes = level.boxes.map( mb => mb.map(m => Object.assign({},m)) )
		return l
	})

	return result
}




//	======= LOG ERRORS AND WARNINGS =======

PuzzleScriptParser.prototype.logError = function(msg)
{
	// console.log(msg, this.lineNumber);// console.assert(false)
	logError(msg, this.lineNumber);
}

PuzzleScriptParser.prototype.logWarning = function(msg)
{
	// console.log(msg, this.lineNumber);
	logWarning(msg, this.lineNumber);
}




//  ======= RECORD & CHECK IDENTIFIERS AND METADATA =========

// The functions in this section do not rely on CodeMirror's API


//	------- METADATA --------

const metadata_with_mixedCase_value = ['youtube', 'author', 'homepage', 'title', 'game_uri']
const metadata_with_value = ['background_color','text_color','title_color','author_color','keyhint_color','key_repeat_interval','realtime_interval','again_interval','flickscreen','zoomscreen','color_palette','sprite_size','level_title_style','auto_level_titles']
const metadata_default_values = { auto_level_titles: 'always' }
const metadata_accepted_values = { auto_level_titles: ['named'], level_title_style: ['noheader', 'header'] }
const metadata_without_value = ['run_rules_on_level_start','norepeat_action','require_player_movement','debug','verbose_logging','throttle_movement','noundo','noaction','norestart','show_level_title_in_menu']

PuzzleScriptParser.prototype.registerMetaData = function(key, value)
{
	this.metadata_keys.push(key)
	this.metadata_values.push(value)
}



//	------- CHECK TAGS -------

PuzzleScriptParser.prototype.checkIfNewTagNameIsValid = function(name)
{
	if ( ['background', 'player'].includes(name) )
	{
		this.logError('Cannot use '+name.toUpperCase()+' as a tag name or tag class name: it has to be an object.');
		return false;
	}
	if ( forbidden_keywords.indexOf(name) >= 0)
	{
		this.logError('Cannot use the keyword '+name.toUpperCase()+' as a tag name or tag class name.');
		return false;
	}
	return true;
}



//	------- COLLISION LAYERS --------

// TODO: add a syntax to name collision_layers and use their name as a property?
// -> Actually, we should check that the identifiers given in a layer form a valid property definition.
//    or simply we check that a name given in a collision layer is not the name of an aggregate.
PuzzleScriptParser.prototype.addIdentifierInCollisionLayer = function(candname, layer_index, ...expansion)
{
	// we have a name: let's see if it's valid

	if (candname === 'background')
	{
		if ( (layer_index >= 0) && (this.collisionLayers[layer_index].length > 0) )
		{
			this.logError("Background must be in a layer by itself.");
		}
		this.backgroundlayer = layer_index;
	}
	else if (this.backgroundlayer === layer_index)
	{
		this.logError("Background must be in a layer by itself.");
	}

	if (layer_index < 0)
	{
		this.logError("no layers found.");
		return false;
	}
	
	// list other layers that contain an object that candname can be, as an object cannot appear in two different layers
	// Note: a better way to report this would be to tell "candname {is/can be a X, which} is already defined in layer N" depending on the type of candname
	const cand_index = this.identifiers.checkKnownIdentifier(candname, false, this)
	if (cand_index < 0)
	{
		this.logWarning('You are trying to add an object named '+candname.toUpperCase()+' in a collision layer, but no object with that name has been defined.');
		return false;
	}

	const identifier_index = this.identifiers.replace_parameters(cand_index, ...expansion)

	var identifier_added = true;
	for (const objpos of this.identifiers.getObjectsForIdentifier(identifier_index))
	{
		const obj = this.identifiers.objects[objpos];
		const l = obj.layer;
		if ( (l !== undefined) && (l != layer_index) )
		{
			identifier_added = false;
			this.logWarning(['object_in_multiple_layers', obj.name])
			// Note: I changed default PuzzleScript behavior, here, which was to change the layer of the object. -- ClementSparrow.
		}
		else
		{
			obj.layer = layer_index;
			this.collisionLayers[layer_index].add(objpos);
		}
	}
	return identifier_added;
}








//  ======== LEXER USING CODEMIRROR'S API =========


PuzzleScriptParser.prototype.parse_keyword_or_identifier = function(stream)
{
	const match = stream.match(/[\p{Separator}\s]*[\p{Letter}\p{Number}_:]+[\p{Separator}\s]*/u);
	return (match !== null) ? match[0].trim() : null;
}

PuzzleScriptParser.prototype.parse_sprite_pixel = function(stream)
{
	return stream.eat(/[.\d]/); // a digit or a dot
}






// ====== PARSING TOKENS IN THE DIFFERENT SECTIONS OF THE FILE =======

// ------ EFFECT OF BLANK LINES -------

PuzzleScriptParser.prototype.blankLine = function() // called when the line is empty or contains only spaces and/or comments
{
	switch (this.section)
	{
		case 'objects':
			if (this.line_type == 3) // a sprite matrix was given without transformations after
			{
				this.setSpriteMatrix()
			}
			// TODO: throw errors if line_type is 4 (waiting for object name to copy from)
			this.line_type = 0
			return
		case 'levels':
			if ( (this.line_type === 4) && (this.levels[this.levels.length-1].grid.length > 0) )
			{
				this.line_type = 5
			}
	}
}




// ------ PREAMBLE -------

PuzzleScriptParser.prototype.tokenInPreambleSection = function(is_start_of_line, stream)
{
	if ( ! is_start_of_line ) // we've already parsed the whole line, now we are necessarily in the metadata value's text
	{
		stream.match(reg_notcommentstart, true) // TODO: we probably want to read everything till the end of line instead, because comments should be forbiden on metadata lines as it prevents from putting parentheses in the metadata text...
		return (this.tokenIndex == -1) ? 'ERROR' : 'METADATATEXT'
	}

//	Get the metadata key
	const token = this.parse_keyword_or_identifier(stream)
	if (token === null)
	{
		stream.match(reg_notcommentstart, true);
		return 'ERROR'; // TODO: we should probably log an error, here? It implies that if a line starts with an invalid character, it will be silently ignored...
	}

	if ( metadata_without_value.includes(token) )
	{
		this.registerMetaData(token, 'true') // TODO: return the value instead of a string?
		this.tokenIndex = -1
		return 'METADATA'
	}

	if ( metadata_with_mixedCase_value.includes(token) )
	{
		stream.string = this.mixedCase
	}
	else if ( ! metadata_with_value.includes(token) )
	{
		stream.match(reg_notcommentstart, true)
		this.logError(['unknown_metadata'])
		return 'ERROR'
	}

	this.tokenIndex = 1

	const m2 = stream.match(reg_notcommentstart, false) // TODO: to end of line, not comment (see above)
	if (m2 === null)
	{
		const default_value = metadata_default_values[token]
		if (typeof default_value !== 'undefined')
			this.registerMetaData(token, default_value)
		else
			this.logError('MetaData "'+token+'" needs a value.')
		return 'METADATA'
	}

	const param = m2[0].trim()
	const accepted_values = metadata_accepted_values[token]
	if ( (typeof accepted_values === 'undefined') || accepted_values.includes(param) )
	{
		this.registerMetaData(token, param)
	}
	else
	{
		this.logError(['invalid_preamble_option', param, token])
		this.tokenIndex = -1
	}
	return 'METADATA'
}

PuzzleScriptParser.prototype.finalizeMetaData = function(metadata_name, default_value, error_id, validate_func)
{
	const key_index = this.metadata_keys.indexOf(metadata_name)
	if (key_index < 0)
	{
		this.registerMetaData(metadata_name, default_value)
		return
	}

	const value_str = this.metadata_values[key_index]
	const value = validate_func(value_str)
	if (value === null)
	{
		this.logError([error_id, value_str, default_value])
		this.metadata_values[key_index] = default_value
		return
	}

	this.metadata_values[key_index] = value
}

// TODO: merge with twiddleMetaData defined in compiler.js. Also, it should be done directly as we parse, not after the preamble.
PuzzleScriptParser.prototype.finalizePreamble = function()
{
	this.finalizeMetaData('sprite_size', [5, 5], 'not_a_sprite_size',
		function(s)
		{
			const result = s.split('x').map(str => parseInt(str))
			return result.some(isNaN) ? null : result
		}
	)
	this.finalizeMetaData('level_title_style', 'header', null, s => s)
	this.finalizeMetaData('color_palette', 'arnecolors', 'palette_not_found',
		function(val)
		{
			const palette_num = parseInt(val)
			if ( ( ! isNaN(palette_num) ) && (palette_num > 0) && (palette_num <= colorPalettesAliases.length) )
			{
				val = colorPalettesAliases[palette_num-1]
			}
			return (colorPalettes[val] === undefined) ? null : val
		}
	)
}


// ------ TAGS -------

PuzzleScriptParser.prototype.tokenInTagsSection = function(is_start_of_line, stream)
{
	switch (this.tokenIndex)
	{
		case 0: // tag class name
		{
			const tagclass_name_match = stream.match(reg_tagname, true);
			if (tagclass_name_match === null)
			{
				this.logError('Unrecognised stuff in the tags section.')
				stream.match(reg_notcommentstart, true);
				return 'ERROR'
			}
			if (stream.match(/[\p{Separator}\s]*=/u, false) === null) // not followed by an = sign
			{
				this.logError('I was expecting an "=" sign after the tag type name.')
				stream.match(reg_notcommentstart, true);
				return 'ERROR'
			}
			this.tokenIndex = 1
			const tagclass_name = tagclass_name_match[0];
			if ( ! this.checkIfNewTagNameIsValid(tagclass_name) )
			{
				return 'ERROR'
			}

			let tags = reg_notcommentstart.exec(stream.string)[0].split('=')[1].trim().split(' ').map(t => t.trim())
			tags = tags.filter(tagname => (tagname.length > 0) && this.checkIfNewTagNameIsValid(tagname) )
			if (tags.includes(tagclass_name))
			{
				this.logError('You cannot define tag class '+tagclass_name.toUpperCase()+' as an element of itself. I will ignore that.')
			}

			const identifier_index = this.identifiers.names.indexOf(tagclass_name)
			if (identifier_index >= 0)
			{
				const l = this.identifiers.lineNumbers[identifier_index];
				this.logError('You are trying to define a new tag class named "'+tagclass_name.toUpperCase()+'", but this name is already used for '+
					identifier_type_as_text[this.identifiers.comptype[identifier_index]]+((l >= 0) ? ' defined '+makeLinkToLine(l, 'line ' + l.toString())+'.' : ' keyword.'));
				return 'ERROR'
			}

			// we register the new tags now if they are valid. At that point the tag class can only be invalid if it contains no valid tag, so this is not an issue.
			const tag_set = new Set()
			for (const tagname of tags)
			{
				const added_tagset = this.identifiers.checkAndRegisterNewTagValue(tagname, findOriginalCaseName(tagname, this.mixedCase), tag_set, this)
			}
			if (tag_set.size === 0)
			{
				this.logError('The declaration of '+tagclass_name.toUpperCase()+' does not contain any valid tag. Tag classes cannot be empty!')
				return 'ERROR'
			}

			this.current_identifier_index = this.identifiers.names.length
			this.identifiers.registerNewIdentifier(tagclass_name, findOriginalCaseName(tagclass_name, this.mixedCase), identifier_type_tagset, identifier_type_tagset, tag_set, [null], 0, this.lineNumber)
			return 'NAME'
		}
		case 1: // equal sign
		{
			stream.next();
			this.tokenIndex = 2;
			return 'ASSIGNMENT'
		}
		case 2: // tag value names
		{
			const tagname_match = stream.match(reg_tagname, true);
			if (tagname_match === null)
			{
				this.logError('Invalid character in tag name: "' + stream.peek() + '".');
				stream.match(reg_notcommentstart, true);
				return 'ERROR'
			}
			const tagname = tagname_match[0]
			const identifier_index = this.identifiers.names.indexOf(tagname)
			if (identifier_index < 0)
				return 'ERROR'
			const tags_in_set = this.identifiers.object_set[this.current_identifier_index]
			const ok = Array.from(this.identifiers.object_set[identifier_index]).every(ii => tags_in_set.has(ii) )
			return ok ? 'NAME' : 'ERROR'
		}
		default:
		{
			logError('I reached a part of the code I should never have reached. Please submit a bug report to ClementSparrow!')
			stream.match(reg_notcommentstart, true);
			return null;
		}
	}
}





// ------ OBJECTS -------

function findOriginalCaseName(candname, mixedCase)
{
	function escapeRegExp(str)
	{
	  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	}

	var nameFinder =  new RegExp("\\b"+escapeRegExp(candname)+"\\b","i")
	var match = mixedCase.match(nameFinder);
	if (match != null)
	{
		return match[0];
	}
	return null;
}



PuzzleScriptParser.prototype.tryParseName = function(is_start_of_line, stream)
{
	//LOOK FOR NAME
	const match_name = is_start_of_line ? stream.match(reg_tagged_name, true) : stream.match(/[^\p{Separator}\s\()]+[\p{Separator}\s]*/u, true)
	if (match_name === null)
	{
		stream.match(reg_notcommentstart, true)
		if (stream.pos > 0)
		{
			this.logWarning('Unknown junk in object section. The main names for objects have to be words containing only the letters a-z, digits and : - if you want to call them something like ",", do it in the legend section. Also remember that object declarations MUST be separated by blank lines.')
		}
		return 'ERROR'
	}

	const candname = match_name[0].trim();

	if (is_start_of_line) // new object name
	{
		const new_identifier_index = this.identifiers.checkAndRegisterNewObjectIdentifier(candname, findOriginalCaseName(candname, this.mixedCase), this);
		if (new_identifier_index < 0)
		{
			this.current_identifier_index = undefined
			return 'ERROR'
		}
		this.current_identifier_index = new_identifier_index
		return 'NAME'
	}
	// set up alias
	if ( ! this.identifiers.checkIfNewIdentifierIsValid(candname, false, this) )
		return 'ERROR'
	this.identifiers.registerNewSynonym(candname, findOriginalCaseName(candname, this.mixedCase), this.current_identifier_index, [], this.lineNumber)
	return 'NAME';
}

PuzzleScriptParser.prototype.setSpriteMatrix = function()
{
	if ( (this.sprites_in_code === undefined) || (this.sprites_to_compile === undefined) ) // ignore this function if not compiling
		return
	const spritematrix_index = this.sprites_in_code.length
	this.sprites_in_code.push( Array.from(this.objects_spritematrix) )
	this.sprites_to_compile.push([
		Array.from(this.current_expansion_context.expansion, ([oi, replacements]) => [oi, [spritematrix_index, replacements]]),
		0, // 0 is for 'sprite in code'
		[] // transforms
	])
}


PuzzleScriptParser.prototype.tokenInObjectsSection = function(is_start_of_line, stream)
{
	if (is_start_of_line)
	{
		if ( [1,2].includes(this.line_type) )
		{
			this.line_type += 1
		}
	}

	switch (this.line_type)
	{
	case 0:
	case 1: // name of the object or synonym
		{
			this.objects_spritematrix = []
			this.line_type = 1
			const result = this.tryParseName(is_start_of_line, stream)
			if ( ! is_start_of_line )
				return result

			if (this.current_identifier_index === undefined) // invalid object name, check syntax but generate nothing
			{
				this.current_expansion_context = new ExpansionContext()
				return result
			}

			this.current_expansion_context = this.identifiers.expansion_context_from_identifier(this.current_identifier_index)
			// do not change the spritematrix and palette of an object that has been explicitely defined unless we're currently explicitly defining it.
			this.current_expansion_context.filter(
				([object_index, expansion]) =>
				{
					const identifier_index = this.identifiers.objects[object_index].identifier_index
					return (identifier_index === this.current_identifier_index) || (this.identifiers.implicit[identifier_index] !== 0)
				}
			)
			return result
		}
	case 2:
		{
			//LOOK FOR COLOR
			this.tokenIndex = 0;

			const match_color = stream.match(reg_color, true);
			if (match_color === null)
			{
				var str = stream.match(reg_name, true) || stream.match(reg_notcommentstart, true)
				this.logError(
					'Was looking for color' +
					( (this.current_identifier_index !== undefined) ? ' for object ' + this.identifiers.names[this.current_identifier_index].toUpperCase() : '' ) +
					', got "' + str + '" instead.'
				)
				return 'ERROR'
			}

		//	Get the game's palette
			const palette_metadata_index = this.metadata_keys.indexOf('color_palette')
			const palette_name = this.metadata_values[palette_metadata_index]
			const palette = colorPalettes[palette_name]

		//	Get the actual color
			const color_string = match_color[0].trim()
			const color_issue = ! isColor(color_string)
			if (color_issue)
			{
				const object_name = (this.current_identifier_index !== undefined) ? this.identifiers.names[this.current_identifier_index].toUpperCase() : undefined
				this.logError(['invalid_color_for_object', object_name, color_string])
			}
			const color = color_issue ? '#ff00ffff' /* magenta error color */ : colorToHex(palette, color_string)

		//	Set colors in every object defined
			// TODO Performance: that can be very long, this expansion should be done only once, when the whole list of colors is found
			let too_many_colors = false
			this.current_expansion_context.expansion.forEach(
				([object_index, expansed_parameters]) => {
					const o = this.identifiers.objects[object_index]
					if ( is_start_of_line || (o.colors === undefined) )
					{
						o.colors = [color]
					} else {
						too_many_colors ||= (o.colors.length == 11)
						o.colors.push(color)
					}
				}
			)
			if (too_many_colors)
			{
				this.logWarning(['too_many_sprite_colors'])
			}

		//	Return appropriate lexer style
			if (color_issue)
				return 'ERROR'
			const candcol = color_string.toLowerCase()
			if (candcol === 'transparent')
				return 'COLOR FADECOLOR'
			return 'COLOR-'+color.substring(0, 7)
		}
	case 3: // sprite matrix
		{
			const spritematrix = this.objects_spritematrix
			const ch = this.parse_sprite_pixel(stream)
			if (ch === undefined)
			{
				if (spritematrix.length === 0) // allows to not have a sprite matrix and start another object definition without a blank line
				{
					if (stream.match(/copy:\s+/u, true) === null)
					{
						stream.match(reg_notcommentstart, true)
						this.logWarning('Unknown junk in object section. I was expecting the definition of a sprite matrix, directly as pixel values or indirectly with a "copy: [object name]" instruction. Maybe you forgot to insert a blank line between two object definitions?')
						return 'ERROR'
					}

					// copy sprite from other object(s)
					this.line_type = 4
					if ( (new Set(this.current_expansion_context.parameters)).size !== this.current_expansion_context.parameters.length ) // check for duplicate class names
					{
						this.logWarning('Copying sprites for identifier '+this.identifiers.names[this.current_identifier_index].toUpperCase()+
							' is ambiguous and can have undesired consequences, because it contains multiple instances of a same tag class. To avoid this problem, use tag class aliases so that each tag class only appears once in the identifier.')
						return 'WARNING'
					}
					return null // TODO: new lexer type?
				}

				if (is_start_of_line) // after the sprite matrix
				{
					this.line_type = 5 // allow transformations after the sprite

				//	Compute the expansion that can be used by sprite transforms
					this.setSpriteMatrix()
					return null
				}

				this.logError(
					'Unknown junk in spritematrix' +
					( (this.current_identifier_index !== undefined) ? ' for object ' + this.identifiers.names[this.current_identifier_index].toUpperCase() : '') + '.'
				)
				stream.match(reg_notcommentstart, true)
				return null
			}

		//	Add a new line to the sprite matrix
			if (is_start_of_line)
			{
				spritematrix.push('')
			}

			spritematrix[spritematrix.length - 1] += ch

		//	Return the correct lexer tag
			if (ch === '.')
				return 'COLOR FADECOLOR';
			const n = parseInt(ch);
			if (isNaN(n))
			{
				this.logError(
					'Invalid character "' + ch + '" in sprite' +
					( (this.current_identifier_index !== undefined) ? ' for ' +this.identifiers.names[this.current_identifier_index].toUpperCase() : '') + '.'
				)
				return 'ERROR'
			}
			const token_colors = new Set()
			let ok = true
			if (this.current_identifier_index == undefined)
				return null // TODO: we should keep the palette defined and use it to display the pixel color
			// TODO Performance: this can take a lot of time, it would be much better to cache the result style
			for (const [object_index, expansed_parameters] of this.current_expansion_context.expansion)
			{
				const o = this.identifiers.objects[object_index]
				if (n >= o.colors.length)
				{
					this.logError(['palette_too_small', n, o.name.toUpperCase(), o.colors.length])
					ok = false
				}
				else
				{
					token_colors.add( 'COLOR-' + o.colors[n].toUpperCase() )
				}
			}
			if (!ok)
				return 'ERROR'
			return (token_colors.size == 1) ? 'COLOR BOLDCOLOR ' + token_colors.values().next().value : null
		}

	case 4: // copy spritematrix: name of the object to copy from
	{
	//	Get the name to copy the sprite matrix from
		const copy_from_match = stream.match(reg_tagged_name, true)
		if (copy_from_match === null)
		{
			this.logError('Unexpected character ' + stream.peek() + ' found instead of object name in definition of sprite copy.')
			stream.match(reg_notcommentstart, true)
			return 'ERROR'
		}
		copy_from_id = copy_from_match[0].trim()
		this.line_type = 5

	//	Get the identifier to copy from
		const copy_from_identifier_index = this.identifiers.checkKnownIdentifier(copy_from_id, true, this)
		if (copy_from_identifier_index < 0)
		{
			this.logError('I cannot copy the sprite of unknown object '+copy_from_id.toUpperCase()+'.')
			this.current_expansion_context = new ExpansionContext()
			return 'ERROR'
		}

	//	Now we need to replace the tag classes in the identifier according to the expansion parameters in the currently defined object
		// A better way to do this would be to find the tag class appearing in copy_from_id and check that each class also appears in this.current_expansion_context.parameters, and appears only once
		// it will also be faster because we don't actually expand the classes here
		// However, the difficulty is that we need to apply the tag mappings
		// but we have the same issue with transforms
		// Also when in the future we will allow mappings in the name of the identifier defined, it's ok because it does not define a duplicated expansion parameter
		let new_expansion = []
		let result = 'NAME'
		for (const [object_index, replacements_identifier_indexes] of this.current_expansion_context.expansion)
		{
		//	Get the identifier to copy from for this expansion
			const replaced_source_identifier_index = this.identifiers.replace_parameters(copy_from_identifier_index, this.current_expansion_context.parameters, replacements_identifier_indexes)
			if (this.identifiers.comptype[replaced_source_identifier_index] != identifier_type_object)
			{
				this.logError('Cannot copy the sprite of '+this.identifiers.names[this.current_identifier_index].toUpperCase()+' from '+copy_from_id+
					' because it would imply to copy from '+this.identifiers.names[replaced_source_identifier_index].toUpperCase() + ', which is not an atomic object.')
				result = 'ERROR'
				continue
			}
		//	Remember the object which sprite will be copied
			const source_object_index = this.identifiers.getObjectFromIdentifier(replaced_source_identifier_index)
			new_expansion.push( [object_index, [source_object_index, replacements_identifier_indexes]] )
		}
		this.current_expansion_context.expansion = new_expansion

		if (this.sprites_to_compile === undefined) // ignore sprites compilation if not compiling
			return result

		this.sprites_to_compile.push([
			new_expansion,
			1, // 1 is for 'copy from object'
			[]
		])
		return result
	}

	case 5: // transformations to apply to the matrix
	{
	//	Get one transformation instruction
		const transform_match = stream.match(reg_sprite_transform, true)
		if (transform_match === null)
		{
			this.logError('I do not understand this sprite transformation! Did you forget to insert a blank line between two object declarations?')
			stream.match(reg_notcommentstart, true)
			return 'ERROR'
		}
		const transform_string = transform_match[1]

	//	Check the type of the transformation's parameters
		const [transform_type, ...transform_parts] = transform_string.split(':')
		const expected_types = ({
			rot:       ['dir','dir'],
			shift:     ['dir','num'],
			translate: ['dir','num'],
			'-':       [],
			'|':       [],
		})[transform_type]
		let compiled_transformation = [ transform_type, ...transform_parts ]
		for (const [part_index, transform_part] of transform_parts.entries())
		{
			const expected_type = expected_types[part_index]
			let strings_to_test = [ transform_part ]

		//	If the parameter is a mapping name, apply it to replace the parameter
			const part_identifier_index = this.identifiers.names.indexOf(transform_part)
			if (part_identifier_index >= 0)
			{
				switch (this.identifiers.deftype[part_identifier_index])
				{
					case identifier_type_mapping:
					{
						// get the mapping
						const mapping_index = this.identifiers.tag_mappings[part_identifier_index][0]
						const mapping = this.identifiers.mappings[mapping_index]

						// Use it only if there is a corresponding expansion parameter in the current context…
						const tag_index = this.current_expansion_context.parameters.indexOf(mapping.from)
						if ( (tag_index >= 0) || (expected_type == 'dir') ) // it's ok to use direction mappins without direction in the defined object, it allows to use ^<v> as absolute directions
						{
							// … and it is unique
							if ( (expected_type != 'dir') && this.current_expansion_context.parameters.indexOf(mapping.from, tag_index+1) >= 0 )
							{
								this.logError('You\'re trying to use the tag mapping '+transform_part.toUpperCase()+' in a sprite transformation but its start set, '+this.identifiers.names[mapping.from].toUpperCase()+' appears multiple times in the object definition and I don\'t know which one to use for the mapping.')
								return 'ERROR'
							}
							strings_to_test = mapping.toset.map(ii => this.identifiers.names[ii])
							compiled_transformation[part_index+1] = [tag_index, mapping.fromset, strings_to_test] // it's OK to have tag_index = -1 here
						}
						break
					}
					case identifier_type_tagset:
					{
						const tag_index = this.current_expansion_context.parameters.indexOf(part_identifier_index)
						if (tag_index < 0)
							break

						if ( this.current_expansion_context.parameters.indexOf(part_identifier_index, tag_index+1) >= 0 )
						{
							this.logError('You\'re trying to use the tag class '+transform_part.toUpperCase()+' in a sprite transformation but it appears multiple times in the object definition and I don\'t know which one to use for expansion.')
							return 'ERROR'
						}
						const objects_ids = Array.from(this.identifiers.getObjectsForIdentifier(part_identifier_index))
						strings_to_test = objects_ids.map(ii => this.identifiers.names[ii])
						compiled_transformation[part_index+1] = [tag_index, objects_ids, strings_to_test]
					}
				}
			}

		//	Now test type
			switch (expected_type)
			{
				case 'dir':
					if ( strings_to_test.every( s => absolutedirs.includes(s) ) ) continue
					this.logError(['invalid_value_in_transorm', 'direction', transform_part])
					break
				case 'num':
					if ( strings_to_test.every( s => ! isNaN(parseInt(s)) ) ) continue
					this.logError(['invalid_value_in_transorm', 'number', transform_part])
				default:
			}
			return 'ERROR'
		}

		if (this.sprites_to_compile !== undefined)
		{
			this.sprites_to_compile[this.sprites_to_compile.length-1][2].push(compiled_transformation)
		}
		return 'NAME' // actually, we should add a new token type for the transform instructions but I'm lazy
	}
	default:
		window.console.logError("EEK shouldn't get here.")
	}
}







// ------ LEGEND -------

// TODO: when defining an abrevation to use in a level, give the possibility to follow it with a (background) color that will be used in the editor to display the levels
// Or maybe we want to directly use the object's sprite as a background image?
// Also, it would be nice in the level editor to have the letter displayed on each tile (especially useful for transparent tiles) and activate it with that key.
PuzzleScriptParser.prototype.tokenInLegendSection = function(is_start_of_line, stream)
{
	if (is_start_of_line)
	{
		//step 1 : verify format
		var longer = stream.string.replace('=', ' = ');
		longer = reg_notcommentstart.exec(longer)[0];

		var splits = longer.split(/[\p{Separator}\s]+/u).filter( v => (v !== '') );
		var ok = true;

		if (splits.length > 0)
		{
			const candname = splits[0].toLowerCase();
			if (splits.indexOf(candname, 2) >= 2)
			{
				this.logError("You can't define object " + candname.toUpperCase() + " in terms of itself!");
				ok = false; // TODO: we should raise the error only for the identifier that is wrong, not for the whole line.
			}
			if ( ! this.identifiers.checkIfNewIdentifierIsValid(candname, false, this) )
			{
				stream.match(reg_notcommentstart, true); // TODO: we should return an ERROR for this identifier but continue the parsing
				return 'ERROR';
			}
		}

		if (!ok) {
		} else if (splits.length < 3) {
			ok = false;
		} else if (splits[1] !== '=') {
			ok = false;
		} else if (splits.length === 3)
		{
			const old_identifier_index = this.identifiers.checkKnownIdentifier(splits[2].toLowerCase(), false, this);
			if (old_identifier_index < 0)
			{
				this.logError('Unknown object or property name '+splits[2].toUpperCase()+' found in the definition of the synonym '+splits[0].toUpperCase()+'!')
				ok = false
			}
			else
			{
				// TODO: deal with tags. It should be OK to declare a synonym for an identifier with tag classes (and even tag functions!) as tags, but only if
				// the set of tag classes is the same in the new and old identifiers.
				this.current_identifier_index = this.identifiers.registerNewSynonym(splits[0], findOriginalCaseName(splits[0], this.mixedCase), old_identifier_index, [], this.lineNumber)
			}
		} else if (splits.length % 2 === 0) {
			ok = false;
		} else {
			const lowertoken = splits[3].toLowerCase();
			for (var i = 5; i < splits.length; i += 2)
			{
				if (splits[i].toLowerCase() !== lowertoken)
				{
					ok = false;
					break;
				}
			}
			if (ok)
			{
				const new_identifier = splits[0];
				var new_definition = []
				for (var i = 2; i < splits.length; i += 2)
				{
					new_definition.push(splits[i]);
				}
				const compound_type = ({ and:identifier_type_aggregate, or: identifier_type_property})[lowertoken];
				if (compound_type === undefined)
				{
					ok = false;
				}
				else
				{
					var [ok2, objects_in_compound] = this.identifiers.checkCompoundDefinition(new_definition, new_identifier, compound_type, this)
					// TODO: deal with tag classes in the tags of new_identifier or in the objects_in_compound, and manage tag_mappings?
					this.current_identifier_index = this.identifiers.registerNewLegend(new_identifier, findOriginalCaseName(new_identifier, this.mixedCase), objects_in_compound, [], compound_type, 0, this.lineNumber)
					if (ok2 === false)
					{
						stream.match(/[^=]*/, true)
						this.tokenIndex = 1
						return 'ERROR'
					}
				} 
			}
		}

		if (ok === false)
		{
			this.logError('incorrect format of legend - should be one of A = B, A = B or C ( or D ...), A = B and C (and D ...)')
			stream.match(reg_notcommentstart, true)
			return 'ERROR'
		}

		this.tokenIndex = 0
	}

	// the line has been parsed, now we just consume the words, returning the appropriate token type
	this.tokenIndex++
	switch (this.tokenIndex)
	{
	case 1: // the new identifier
		{
			stream.match(/[^=]*/, true)
			return 'NAME'
		}
	case 2: // =
		{
			stream.next()
			stream.match(/[\p{Separator}\s]*/u, true)
			return 'ASSIGNMENT'
		}
	default:
		{
			const match_name = stream.match(reg_tagged_name, true)
			if (match_name === null)
			{
				this.logError("Something bad's happening in the LEGEND")
				stream.match(reg_notcommentstart, true)
				return 'ERROR'
			}
			const candname = match_name[0].trim()

			if (this.tokenIndex % 2 === 0)
				return 'LOGICWORD'
			const identifier_index = this.identifiers.checkKnownIdentifier(candname.toLowerCase(), false, this)
			if (identifier_index < 0)
				return 'ERROR'
			const objects = this.identifiers.object_set[identifier_index]
			if ([...objects].some( object => ! this.identifiers.object_set[this.current_identifier_index].has(object) ))
				return 'ERROR'
			return 'NAME'
		}
	}
}





// ------- MAPPINGS -------

PuzzleScriptParser.prototype.tokenInMappingSection = function(is_start_of_line, stream)
{
	if (is_start_of_line)
	{
		this.line_type = (this.line_type+1) % 2
		if (this.lastTokenIndex === 0)
		{
		}
		else if (this.line_type === 0) // we were parsing the first line
		{
			if (this.lastTokenIndex < 3)
			{
				this.logError('You started a mapping definition but did not end it. There should be START_SET_NAME => MAPPING_NAME on the first line.')
			}
		}
		else
		{
			if (this.lastTokenIndex < 2)
			{
				this.logError('You started a mapping definition but did not end it. There should be START_SET_NAMES -> MAPPED_VALUES on the second line.');
			}
		}		
		if (this.line_type == 1) // first line
		{
			this.current_mapping = {
				from: {
					identifier_index: null,
					name: '',
					set: new Set(),
					array: [],
				},
				name: '',
				mapping_index: null,
				result: [],
			}
			this.current_identifier_index = null
		}
	}

	if (this.line_type === 1) // first line
	{
		switch (this.tokenIndex)
		{
			case 0: // set of values the function opperates on: tag class or object property
			{
				const fromset_name_match = stream.match(reg_tagged_name, true);
				if (fromset_name_match === null)
				{
					this.logError('Unrecognised stuff in the mappings section.')
					stream.match(reg_notcommentstart, true);
					return 'ERROR'
				}
				this.tokenIndex = 1;
				const fromset_name = fromset_name_match[0];
				const identifier_index = this.identifiers.checkIdentifierIsKnownWithType(fromset_name, [identifier_type_property, identifier_type_tagset], false, this);
				if (identifier_index === -2) // unknown identifier
				{
					this.logError('Unknown identifier for a mapping\'s start set: '+fromset_name.toUpperCase()+'.')
					stream.match(reg_notcommentstart, true);
					return 'ERROR';
				}
				if ( identifier_index === -1 )
				{
					this.logError('Cannot create a mapping with a start set defined as '+identifier_type_as_text[this.identifiers.comptype[identifier_index]]+': only tag classes and object properties are accepted here.');
					stream.match(reg_notcommentstart, true);
					return 'ERROR';
				}
				this.current_mapping.from = {
					name: fromset_name,
					identifier_index: identifier_index,
					set: new Set(this.identifiers.object_set[identifier_index]),
					array: [],
				}
				return 'NAME'
			}
			case 1: // arrows
			{
				this.tokenIndex = 2;
				if (stream.match(/=>/, true) === null) // not followed by an => sign
				{
					this.logError('I was expecting an "=>" sign after the name of the mapping\'s start set.')
					return 'ERROR'
				}
				return 'ARROW'
			}
			case 2: // name of the function
			{
				this.tokenIndex = 3
				const fromset_identifier_index = this.current_mapping.from.identifier_index
				this.current_identifier_index = null
				const toset_name_match = stream.match(reg_tagged_name, true);
				if (toset_name_match === null)
				{
					this.logError('Unrecognised stuff in the mappings section while reading the mapping\'s name.')
					stream.match(reg_notcommentstart, true);
					return 'ERROR'
				}
				const toset_name = toset_name_match[0]
				this.current_mapping.name = toset_name
				if ( (this.identifiers.comptype[fromset_identifier_index] === identifier_type_property) ? ! this.identifiers.checkIfNewIdentifierIsValid(toset_name, false, this) : ! this.checkIfNewTagNameIsValid(toset_name) )
				{
					this.logError('Invalid mapping name: '+toset_name.toUpperCase()+'.')
					stream.match(reg_notcommentstart, true);
					return 'ERROR';
				}
				if (fromset_identifier_index !== null)
				{
					this.current_identifier_index = this.identifiers.registerNewMapping(toset_name, findOriginalCaseName(toset_name, this.mixedCase), fromset_identifier_index, new Set(), 0, this.lineNumber)
					this.current_mapping.mapping_index = this.identifiers.mappings.length-1
				}
				return 'NAME'
			}
			case 3: // error: extra stuff
			{
				stream.match(reg_notcommentstart, true)
				this.logWarning('The first line of a mapping definition should be STARTSETNAME => MAPPINGNAME, but you provided extra stuff after that. I will ignore it.');
				return 'ERROR';
			}

		}
	}
	else // second line
	{
		switch (this.tokenIndex)
		{
			case 0: // elements of the start set
			{
				if (stream.match(/->/, true))
				{
					// check that we have listed all the values in the start set.
					if (this.current_mapping.from.set.size > 0)
					{
						// TODO: create a mean to get the name of the start set of the currently defined mapping
						logError('You have not specified every values in the mapping start set '+this.current_mapping.from.name.toUpperCase()+
							'. You forgot: '+Array.from(this.current_mapping.from.set, ii => this.identifiers.names[ii].toUpperCase()).join(', ')+'.');
					}
					if (this.current_mapping.mapping_index !== null)
					{
						this.identifiers.mappings[this.current_mapping.mapping_index].fromset = this.current_mapping.from.array
					}
					this.current_mapping.result = []
					this.tokenIndex = 2
					return 'ARROW'
				}
				const fromvalue_match = stream.match(reg_tagged_name, true);
				if (fromvalue_match === null)
				{
					this.logError('Invalid character in mapping definition: "' + stream.peek() + '".');
					stream.match(reg_notcommentstart, true);
					return 'ERROR'
				}
				const fromvalue_name = fromvalue_match[0];
				// TODO: better define the accepted types here
				const identifier_index = this.identifiers.checkIdentifierIsKnownWithType(fromvalue_name, [identifier_type_object, identifier_type_tag], false, this);
				if (identifier_index < 0)
					return 'ERROR'
				if ( ! this.current_mapping.from.set.delete(identifier_index) )
				{
					this.logError('Invalid declaration of a mapping start set: '+fromvalue_name.toUpperCase()+' is not an atomic member of '+this.current_mapping.from.name.toUpperCase()+'.')
					return 'ERROR';
				}
				// register the values in order and check that the whole set of values in the start set is covered.
				this.current_mapping.from.array.push(identifier_index)
				return 'NAME';
			}
			case 2: // elements of the end set
			{
				const tovalue_match = stream.match(reg_tagged_name, true);
				if (tovalue_match === null)
				{
					this.logError('Invalid character in mapping definition: "' + stream.peek() + '".');
					stream.match(reg_notcommentstart, true);
					return 'ERROR'
				}
				const tovalue_name = tovalue_match[0];
				if (this.current_identifier_index === null)
					return 'NAME';
				const accepted_types = (this.identifiers.comptype[this.current_mapping.from.identifier_index] === identifier_type_property) ? [identifier_type_object, identifier_type_property] : [identifier_type_tag, identifier_type_tagset]
				const identifier_index = this.identifiers.checkIdentifierIsKnownWithType(tovalue_name, accepted_types, false, this); // todo: better error message when we use a tag instead or a property and vice versa.
				if (identifier_index < 0)
					return 'ERROR'
				// TODO? check that the identifier is in the start set
				// register the mapping for this value
				var mapping = this.identifiers.mappings[this.current_mapping.mapping_index]
				mapping.toset.push( identifier_index )
				// if we got all the values in the set
				if (mapping.toset.length === mapping.fromset.length)
				{
					this.tokenIndex = 3
				}
				return 'NAME'
			}
			case 3: // error: extra stuff
			{
				stream.match(reg_notcommentstart, true)
				this.logWarning('The second line of a mapping definition should be START_SET_VALUES -> END_SET_VALUES, but you provided extra stuff after that. I will ignore it.');
				return 'ERROR';
			}
		}
	}
}


// ------ SOUNDS -------

PuzzleScriptParser.prototype.tokenInSoundsSection = function(is_start_of_line, stream)
{
	if (is_start_of_line)
	{
		var ok = true;
		var splits = reg_notcommentstart.exec(stream.string)[0].split(/[\p{Separator}\s]+/u).filter( v => (v !== '') );
		splits.push(this.lineNumber);
		this.sounds.push(splits);
	}
	var candname = stream.match(reg_soundverbs, true)
	if (candname!==null)
		return 'SOUNDVERB';
	candname = stream.match(reg_sounddirectionindicators,true);
	if (candname!==null)
		return 'DIRECTION';
	candname = stream.match(reg_soundseed, true);
	if (candname !== null)
	{
		this.tokenIndex++;
		return 'SOUND';
	} 
	candname = stream.match(/[^\[\|\]\p{Separator}\s]+/u, true) // will match everything but [|] and spaces
	if (candname !== null)
	{
		const m = candname[0].trim();
		if (this.identifiers.checkKnownIdentifier(m, false, this) >= 0)
			return 'NAME';
	}
	else
	{
		candname = stream.match(reg_notcommentstart, true);
		this.logError(['unexpected_sound_token', candname])
	}
	stream.match(reg_notcommentstart, true);
	return 'ERROR';
}







// ------ COLLISION LAYERS -------

PuzzleScriptParser.prototype.tokenInCollisionLayersSection = function(is_start_of_line, stream)
{
	if (is_start_of_line)
	{
		const sep_match = stream.match(reg_layergroups_separator, true)
		if (sep_match !== null)
		{
			const last_group = this.collision_layer_groups[-1]
			const direction_string = sep_match[1] || '>v'
			this.collision_layer_groups.push( {
				first_layer: this.collisionLayers.length,
				horizontal_first: '<->'.includes(direction_string[0]),
				leftward: direction_string.includes('<'),
				upward: direction_string.includes('^')
			} )
			return 'COLGROUPSEP' // TODO: add CSS
		}
		this.current_expansion_context = new ExpansionContext()
		this.tokenIndex = (/->/.test(stream.string)) ? 0 : 1
	}

	if (stream.match(/->/, true) !== null)
	{
		this.tokenIndex = 1
		return 'ARROW'
	}

	// define the expansion context if possible
	// TODO: we need to make the expansion in the parser instead of the compiler, only to repport errors, but it is a costly operation that can slow down the editor a lot.
	if ( (this.tokenIndex >= 1) && (this.current_expansion_context.expansion.length == 0) )
	{
		this.current_expansion_context = this.identifiers.expansion_context(
			this.current_layer_parameters,
			this.collisionLayers.length,
			(expansion, i) => this.collisionLayers.length+i
		)
		this.current_layer_parameters = []
		// finalize the list of parameters and create the collision layers
		this.current_expansion_context.expansion.forEach( e => this.collisionLayers.push( new Set() ) )
	}

	const match_name = stream.match(reg_maptagged_name, true)

	// ignore spaces and commas in the list
	if (match_name === null)
	{
		//then strip spaces and commas
		const prepos = stream.pos;
		stream.match(reg_csv_separators, true);
		if (stream.pos == prepos)
		{
			this.logError("error detected - unexpected character " + stream.peek());
			stream.next();
		}
		return null
	}
	
	const identifier = match_name[0].trim()

	if (this.tokenIndex == 0) // in the list of expansion parameters
	{
		const identifier_index = this.identifiers.checkIdentifierIsKnownWithType(identifier, [identifier_type_property, identifier_type_tagset], false, this)
		if (identifier_index === -2) // unknown identifier
		{
			this.logError('I cannot generate collision layers for unknown tag class or object property "'+identifier.toUpperCase()+'".')
			return 'ERROR'
		}
		if (identifier_index === -1) // wrong type
		{
			this.logError('I cannot generate collision layers for "'+identifier.toUpperCase()+'" because it is not a tag class or object property.')
			return 'ERROR'
		}
		this.current_layer_parameters.push(identifier_index)
		return 'NAME'
	}

	// object name (possibly, to be expanded)
	if ( this.current_expansion_context.expansion.every( ([layer_index, expansion]) => this.addIdentifierInCollisionLayer(identifier, layer_index, this.current_expansion_context.parameters, expansion) ) )
		return 'NAME'
	return 'ERROR' // this is a semantic rather than a syntactic error
}





// ------ RULES -------

PuzzleScriptParser.prototype.tokenInRulesSection = function(is_start_of_line, stream, ch)
{
	if (is_start_of_line)
	{
		var rule = reg_notcommentstart.exec(stream.string)[0];
		this.rules.push([rule, this.lineNumber, this.mixedCase]);
		//in rules, tokenIndex records whether bracket has been found or not
	}

	if (this.tokenIndex === -4)
	{
		stream.skipToEnd();
		return 'MESSAGE';
	}
	if (stream.match(/[\p{Separator}\s]*->[\p{Separator}\s]*/u, true)) // TODO: also match the unicode arrow character
		return 'ARROW';
	if (ch === '[' || ch === '|' || ch === ']' || ch==='+')
	{
		if (ch !== '+')
		{
			this.tokenIndex = 1;
		}
		stream.next();
		stream.match(/[\p{Separator}\s]*/u, true);
		return 'BRACKET';
	}

	const m = stream.match(/[^\[\|\]\p{Separator}\s]*/u, true)[0].trim();

	if (this.tokenIndex === 0 && reg_loopmarker.exec(m))
		return 'BRACKET'; // styled as a bracket but actually a keyword
	if (this.tokenIndex === 0 && reg_ruledirectionindicators.exec(m))
	{
		stream.match(/[\p{Separator}\s]*/u, true);
		return 'DIRECTION';
	}
	if (this.tokenIndex === 1 && reg_directions.exec(m))
	{
		stream.match(/[\p{Separator}\s]*/u, true);
		return 'DIRECTION';
	}
	// TODO: checkKnownIdentifier cannot check identifiers with mappings used in tags or tag rule parameters,
	// so we need to list the rule parameters and perform some special checking here
	if ( this.identifiers.checkKnownTagClass(m) || (this.identifiers.checkKnownIdentifier(m, true, this) >= 0) )
	{
		stream.match(/[\p{Separator}\s]*/u, true);
		return 'NAME';
	}
	if (m === '...')
		return 'DIRECTION';
	if (m === 'rigid')
		return 'DIRECTION';
	if (m === 'random')
		return 'DIRECTION';
	if (CommandsSet.prototype.is_command(m))
	{
		if (m === 'message')
		{
			this.tokenIndex=-4;
		}                                	
		return 'COMMAND';
	}
	this.logError('Name "' + m + '", referred to in a rule, does not exist.');
	return 'ERROR';
}





// ------ WIN CONDITIONS -------

PuzzleScriptParser.prototype.tokenInWinconditionsSection = function(is_start_of_line, stream)
{
	if (is_start_of_line)
	{
		const tokenized = reg_notcommentstart.exec(stream.string);
		const splitted = tokenized[0].split(/[\p{Separator}\s]+/u);
		var filtered = splitted.filter( v => (v !== '') );
		filtered.push(this.lineNumber);
		
		this.winconditions.push(filtered);
		this.tokenIndex = -1;
	}
	this.tokenIndex++;

	const candword = this.parse_keyword_or_identifier(stream)
	if (candword === null)
	{
		this.logError('incorrect format of win condition.');
		stream.match(reg_notcommentstart, true);
		return 'ERROR';
	}
	switch(this.tokenIndex)
	{
		case 0: // expect a quantifier word ('all', 'any', 'some', 'no')
			return (reg_winconditionquantifiers.exec(candword)) ? 'LOGICWORD' : 'ERROR';
		case 2: // expect a 'on'
			if ( (candword != 'on') && (candword != 'in') )
			{
				logError('Expecting the words "ON" or "IN" but got "'+candword.toUpperCase()+"'.", state.lineNumber)
				return 'ERROR'
			}
			return 'LOGICWORD'
		case 1: // expect an identifier
		case 3:
			if (this.identifiers.checkKnownIdentifier(candword, true, this) < 0)
			{
				this.logError('Error in win condition: "' + candword.toUpperCase() + '" is not a valid object name.');
				return 'ERROR'
			}
			return 'NAME'
	}
}






// ------ LEVELS -------

PuzzleScriptParser.prototype.createLevelMessage = function(message_text, message_box_index)
{
	this.levels[this.levels.length-1].boxes[message_box_index].push({
		text: message_text,
		lineNumber: this.lineNumber,
	})
}

PuzzleScriptParser.prototype.createLevel = function()
{
	if (this.levels[this.levels.length-1].grid.length === 0)
	{
		this.logWarning(['no_grid_in_level'])
		return
	}

	this.levels.push({
		name: undefined,
		boxes: [ [], [], [], ],
		grid: [],
	})
}

const MAX_LEVEL_NAME_LENGTH = terminal_width - 18
PuzzleScriptParser.prototype.setLevelName = function(level_name)
{
	if ( (level_name !== undefined) && (level_name.length > MAX_LEVEL_NAME_LENGTH) )
	{
		this.logWarning(['long_level_name', MAX_LEVEL_NAME_LENGTH])
	}
	this.levels[this.levels.length-1].name = level_name
}

PuzzleScriptParser.prototype.setLevelTitle = function(title_text, title_style)
{
	title_style ||= this.metadata_values[this.metadata_keys.indexOf('level_title_style')]

	if ( (title_text.length > terminal_width) && this.metadata_keys.includes('show_level_title_in_menu') )
	{
		this.logWarning(['long_level_title'])
	}

	let current_level = this.levels[this.levels.length-1]
	current_level.title_style = title_style
	current_level.title = title_text
}

PuzzleScriptParser.prototype.createLevelIfNeeded = function(new_line_type)
{
	if (this.line_type > new_line_type)
		this.createLevel()
	this.line_type = new_line_type
}

PuzzleScriptParser.prototype.tokenInLevelsSection = function(is_start_of_line, stream, ch)
{
	// Line types:
	// 0 = level command (name)
	// 2 = title
	// 4 = level's grid
	// messages can be placed after any of the above, with index+1
	if (is_start_of_line)
	{
		const command_match = stream.match(reg_level_commands, true)
		if (command_match)
		{
			const command_arg = this.mixedCase.slice(stream.pos).trim()
			switch (command_match[0])
			{
				case 'message':
					this.line_type |= 1
					this.createLevelMessage(command_arg, (this.line_type-1)/2)
					return 'MESSAGE_VERB'
				case 'level':
					this.createLevelIfNeeded(0)
					this.setLevelName(command_arg)
					return 'LEVEL_NAME_VERB'
				case 'title':
				case 'title:noheader':
				case 'title:header':
				case 'title:none':
					this.createLevelIfNeeded(2)
					this.setLevelTitle(command_arg, command_match[2])
					return 'LEVEL_TITLE_VERB'
				default: // invalid title style
					this.createLevelIfNeeded(2)
					this.logError(['unknown_title_style', command_match[2]])
					this.setLevelTitle(command_arg)
					return 'ERROR'
			}
		}

		this.createLevelIfNeeded(4)
		const line = stream.match(reg_notcommentstart, false)[0].trim()
		const current_level = this.levels[this.levels.length-1]
		current_level.grid.push(line)

		if ( ! current_level.hasOwnProperty('lineNumber') )
		{
			current_level.lineNumber = this.lineNumber
		}

		if ( ! current_level.hasOwnProperty('width') )
		{
			current_level.width = line.length
		}
		else if (line.length != current_level.width)
		{
			this.logWarning(['non_rectangular_level'])
		}
	}
	else if (this.line_type != 4)
	{
		stream.skipToEnd()
		return [
			'LEVEL_NAME',  // 0
			'MESSAGE',     // 1
			'LEVEL_TITLE', // 2
			'MESSAGE',     // 3
			'LEVEL',       // 4
			'MESSAGE',     // 5
		][this.line_type]
	}

	if (this.line_type === 4 && !stream.eol())
	{
		const ch = stream.peek()
		stream.next()
		return (this.abbrevNames.indexOf(ch) >= 0) ? 'LEVEL' : 'ERROR'
	}
}








// ------ DISPATCH TO APPROPRIATE PARSER -------

PuzzleScriptParser.prototype.parseActualToken = function(stream, ch) // parses something that is not white space or comment
{
	const is_start_of_line = this.is_start_of_line;

	//  if (is_start_of_line)
	{

	//	MATCH '==="s AT START OF LINE
		if (is_start_of_line && stream.match(reg_equalsrow, true))
			return 'EQUALSBIT';

	//	MATCH SECTION NAME
		if (is_start_of_line && stream.match(reg_sectionNames, true))
		{
			if (this.section == '') // leaving prelude
			{
				this.finalizePreamble()
			}
			this.section = stream.string.slice(0, stream.pos).trim();
			const sectionIndex = sectionNames.indexOf(this.section);

		//	Initialize the parser state for some sections depending on what has been parsed before
			this.lastTokenIndex = 0
			this.line_type = 0
			if (this.section === 'levels')
			{
				//populate character abbreviations
				const abbrevTypes = [ identifier_type_object, identifier_type_synonym, identifier_type_aggregate ]
				this.abbrevNames = this.identifiers.names.filter(
					(identifier, i) => ( (identifier.length == 1) && abbrevTypes.includes(this.identifiers.deftype[i]) )
				)
			}
			return 'HEADER';
		}

		if (stream.eol())
		{
			return null;
		}

		switch (this.section)
		{
			case 'tags':
				return this.tokenInTagsSection(is_start_of_line, stream)
			case 'objects':
				return this.tokenInObjectsSection(is_start_of_line, stream)
			case 'legend':
				return this.tokenInLegendSection(is_start_of_line, stream)
			case 'mappings':
				return this.tokenInMappingSection(is_start_of_line, stream)
			case 'sounds':
				return this.tokenInSoundsSection(is_start_of_line, stream)
			case 'collisionlayers':
				return this.tokenInCollisionLayersSection(is_start_of_line, stream)
			case 'rules':
				return this.tokenInRulesSection(is_start_of_line, stream, ch)
			case 'winconditions':
				return this.tokenInWinconditionsSection(is_start_of_line, stream)
			case 'levels':
				return this.tokenInLevelsSection(is_start_of_line, stream, ch)
			default://if you're in the preamble
				return this.tokenInPreambleSection(is_start_of_line, stream)
		}
	}

	if (stream.eol())
		return null;
	if (!stream.eol())
	{
		stream.next();
		return null;
	}
}



PuzzleScriptParser.prototype.token = function(stream)
{
	const token_starts_line = stream.sol()
	if (token_starts_line)
	{
		this.mixedCase = stream.string+''
		stream.string = stream.string.toLowerCase()
		this.lastTokenIndex = this.tokenIndex
		this.tokenIndex = 0
		this.is_start_of_line ||= (this.commentLevel === 0)
	}

	// ignore white space
	if ( (this.commentLevel === 0) && (this.tokenIndex !== -4) && (stream.match(/[\p{Separator}\s\)]+/u, true) || stream.eol()) )
	{
		if (token_starts_line && stream.eol()) // a line that contains only white spaces and unmatched ) is considered a blank line
			return this.blankLine();
		return null; // don't color spaces and unmatched ) outside messages, and skip them
	}

	////////////////////////////////
	// COMMENT PROCESSING BEGINS
	////////////////////////////////

//	NESTED COMMENTS
	var ch = stream.peek();
	if (ch === '(' && this.tokenIndex !== -4) // tokenIndex -4 indicates message command
	{
		stream.next();
		this.commentLevel++;
	}
	if (this.commentLevel > 0)
	{
		do
		{
			stream.match(/[^\(\)]*/, true);
			
			if (stream.eol())
				break;

			ch = stream.peek();

			if (ch === '(')
			{
				this.commentLevel++;
			}
			else if (ch === ')')
			{
				this.commentLevel--;
			}
			stream.next();
		}
		while (this.commentLevel > 0);
		return 'comment';
	}

	// stream.eatWhile(/[ \t]/);

	const result = this.parseActualToken(stream, ch);
	this.is_start_of_line = false;
	return result;
}



//	======= TYPES OF IDENTIFIERS =======

// Aggregates are "obj1 and obj2" that can appear in the definition of a legend character.
// Properties are "obj1 or obj2".
// Synonyms are "new_obj = old_obj" and can therefore be used either as Properties or Aggregates.

var identifier_type_as_text = [ 'an object', 'an object synonym', 'an aggregate', 'a property', 'a tag', 'a tag class', 'a mapping' ];
const [
	identifier_type_object, identifier_type_synonym, identifier_type_aggregate, identifier_type_property,
	identifier_type_tag, identifier_type_tagset,
	identifier_type_mapping
] = identifier_type_as_text.keys();



//	======= DIRECTIONS AND DIRECTION MAPPINGS =======

const absolutedirs = ['up', 'right', 'down', 'left'];
const relativeDirs = ['^','>','v','<','parallel','perpendicular'];//used to index the following
const relativeDict = {
	'up': ['left', 'up', 'right', 'down', 'vertical', 'horizontal'],
	'right': ['up', 'right', 'down', 'left', 'horizontal', 'vertical'],
	'down': ['right', 'down', 'left', 'up', 'vertical', 'horizontal'],
	'left': ['down', 'left', 'up', 'right', 'horizontal', 'vertical']
}


// ======= CONSTRUCTORS =======

function Identifiers()
{
	this.objects = []
	this.mappings = []

//	Information about the identifiers (struct of array rather than array of struct)
	this.names = [] // all the identifiers defined in the game.
	this.deftype = [] // their type when defined
	this.comptype = [] // their type in the end (synonyms have identifier_type_synonym for deftype but the comptype of the thing they are synonym of)
	this.lineNumbers = [] // the number of the line in which the identifier is first defined
	this.implicit = [] // 0 if the identifier has been explicitely defined, 1 if defined because of the definition of a tag class, 2 if defined because used.
	this.original_case_names = [] // retains the original case of an identifier so that the editor can suggest it as autocompletion.

//	Data for specific types of identifiers
	this.object_set = [] // the objects that the identifier can represent, as a set of indexes in this.objects (or in this.identifiers, for tag sets).
	this.tag_mappings = [] // an array of positions in this.mappings (or null), one mapping for the basename (if it's declared as a mapping) and one mapping for each tag.
	                     // the structure thus also allow to iterate on tags and know their domain of possible values (as the mapping's fromset).

//	Register predefined direction tags
	for (const [i, dirname] of absolutedirs.entries())
	{
		this.registerNewIdentifier(dirname, dirname, identifier_type_tag, identifier_type_tag, new Set([i]), [], 0, -1)
	}
	this.registerNewIdentifier('horizontal', 'horizontal', identifier_type_tagset, identifier_type_tagset, new Set([1,3]), [null], 0, -1) // 4
	this.registerNewIdentifier('vertical', 'vertical', identifier_type_tagset, identifier_type_tagset, new Set([0,2]), [null], 0, -1) // 5
	this.registerNewIdentifier('directions', 'directions', identifier_type_tagset, identifier_type_tagset, new Set([0,1,2,3]), [null], 0, -1) // 6

//	Register predefined direction mappings
	// note that by doing so, we forbid the use of > < v ^ as legend characters to use in levels, which is accepted in vanilla PuzzleScript. But I
	// have no problem with that because I think the whole LEGEND section should be redesigned. The definition of properties and aggregates should have its own section
	// and the definition of legend symbols should only accept aggregates, and be case-sensitive and more unicode-friendly.
	for (const [i, dirname] of relativeDirs.entries())
	{
		this.registerNewMapping(dirname, dirname, 6, new Set(), 0, -1)
		this.mappings[i].fromset = Array.from(absolutedirs, ad => this.names.indexOf(ad) )
		this.mappings[i].toset = Array.from(absolutedirs, ad => this.names.indexOf(relativeDict[ad][i]) )
	}
	
}

Identifiers.prototype.copy = function()
{
	result = new Identifiers();

	result.objects = this.objects.map( (o) => ({
			name: o.name,
			identifier_index: o.identifier_index,
			colors: o.colors.concat([]),
			spritematrix: o.spritematrix.concat([]),
			sprite_offset: Array.from(o.sprite_offset),
			layer: o.layer
		}))
	result.mappings = Array.from(this.mappings, (m) => ({
		from: m.from,
		identifier_index: m.identifier_index,
		fromset: Array.from(m.fromset),
		toset: Array.from(m.toset)
	}));

	result.names = Array.from(this.names)
	result.deftype = Array.from(this.deftype)
	result.comptype = Array.from(this.comptype)
	result.lineNumbers = Array.from(this.lineNumbers)
	result.implicit = Array.from(this.implicit)
	result.original_case_names = Array.from(this.original_case_names)

	result.object_set = this.object_set.map( objects => new Set(objects) )
	result.tag_mappings = Array.from(this.tag_mappings, mappings => Array.from(mappings))

	return result;
}






//  ======= ACCESS THE DATA =======

// Use this when you know there is a single object associated to that identifier, or you just want the first of the objects.
Identifiers.prototype.getObjectFromIdentifier = function(identifier_index)
{
	return this.object_set[identifier_index].values().next().value;
}

Identifiers.prototype.getObjectsForIdentifier = function(identifier_index)
{
	return this.object_set[identifier_index];
}







//	======= REGISTER IDENTIFIERS =======


Identifiers.prototype.registerNewIdentifier = function(identifier, original_case, deftype, comptype, objects, tag_mappings, implicit, lineNumber)
{
	const result = this.names.length;
	this.original_case_names.push( original_case );
	this.names.push( identifier )
	this.deftype.push( deftype )
	this.comptype.push( comptype)
	this.object_set.push( objects )
	this.lineNumbers.push( lineNumber )
	this.implicit.push( implicit )
	this.tag_mappings.push( tag_mappings )
	return result;
}

Identifiers.prototype.registerNewObject = function(identifier, original_case, implicit, lineNumber)
{
	const object_id = this.objects.length
	this.objects.push( {
		name: identifier,
		identifier_index: this.names.length,
		colors: [],
		spritematrix: [],
		sprite_offset: [0, 0]
	});
	return this.registerNewIdentifier(identifier, original_case, identifier_type_object, identifier_type_object, new Set([object_id]), [], implicit, lineNumber)
}

Identifiers.prototype.registerNewSynonym = function(identifier, original_case, old_identifier_index, tag_mappings, lineNumber)
{
	return this.registerNewIdentifier(
		identifier,
		original_case,
		identifier_type_synonym,
		this.comptype[old_identifier_index],
		new Set(this.object_set[old_identifier_index]),
		tag_mappings,
		0,
		lineNumber
	);
}

Identifiers.prototype.registerNewLegend = function(new_identifier, original_case, objects, tag_mappings, type, implicit, lineNumber) // type should be identifier_type_{aggregate,property}
{
	return this.registerNewIdentifier(new_identifier, original_case, type, type, objects, tag_mappings, implicit, lineNumber);
}


Identifiers.prototype.registerNewMapping = function(identifier, original_case, fromset_identifier_index, objects, implicit, lineNumber)
{
	const mapping_index = this.mappings.length;
	result = this.registerNewIdentifier(identifier, original_case, identifier_type_mapping, identifier_type_mapping, objects, [mapping_index], implicit, lineNumber);
	this.mappings.push({
		from: fromset_identifier_index,
		identifier_index: result,
		fromset: [],
		toset: []
	});
	return result;
}






//	======= EXPAND TAGS AND VISIT EXPANDED OBJECTS ======

/* The methods in this section visit all possible ways to expand a tagged identifier when some of its tags are tag classes or tag mappings.
 * callback functions can be applied to the visited objects, but the visit itself does not check anything about the expanded tagged identifiers,
 * and notably they don't check the identifiers have been registered.
 */

// TODO: instead of having an 'accepts_mapping' parameter and check all possible values in the end set of the mapping, we should provide as argument the set of parameters
// that can be replaced. accepts_mapping is only true for checking rules and the first parameter of copy: in sprites definitions (and in win conditions, but it should not ? - and we also want it in expanded collision layer declarations). In all cases, we should know the expansion params.
// Also note that in all the cases where we know the extension parameters, the objects should not be declared implicitly (but properties defined by tag classes can). So we can use a version of this expansion that does not rely on string identifier names, and use indexes instead.

Identifiers.prototype.visitTagExpansion = function(identifier, tagged_identifier, accepts_mapping, tag_operation, identifier_operation)
{
	const tag_identifier_indexes = tagged_identifier[3];
	const tag_mapping = Array.from(
		tag_identifier_indexes.entries(),
		([i, replaced_tag_index]) => this.visitExpandedTag(replaced_tag_index, i, tagged_identifier, accepts_mapping, tag_operation, identifier_operation)
	);
	return identifier_operation(identifier, tagged_identifier, tag_mapping);
}

Identifiers.prototype.visitExpandedTag = function(tag_identifier_index, tag_position, tagged_identifier, accepts_mapping, tag_operation, identifier_operation)
{
	var mapping_startset;
	var mapping_iterationset;
	var mapping_from;
	switch (this.comptype[tag_identifier_index])
	{
		case identifier_type_tagset:
			mapping_startset = Array.from(this.object_set[tag_identifier_index])
			mapping_iterationset = mapping_startset
			mapping_from = tag_identifier_index
			break;
		case identifier_type_mapping:
			if (accepts_mapping)
			{
				const mapping = this.mappings[this.tag_mappings[tag_identifier_index][0]];
				mapping_startset = mapping.fromset
				mapping_iterationset = mapping.toset
				mapping_from = mapping.from
				break;
			}
		case identifier_type_tag:
			return null;
	}
	const mapping_endset = mapping_iterationset.map(
		replacement_tag_ii => this.replaceTag(replacement_tag_ii, tag_position, tagged_identifier, accepts_mapping, tag_operation, identifier_operation)
	)
	return tag_operation(tag_identifier_index, tag_position, tagged_identifier, mapping_from, mapping_startset, mapping_endset);
}

Identifiers.prototype.replaceTag = function(replacement_tag_identifier_index, tag_position, tagged_identifier, ...visitor_params)
{
	const [identifier_base, identifier_base_original_case, tag_identifiers, tag_identifier_indexes, lineNumber] = tagged_identifier

//	Replace the tag name
	var new_tag_identifiers = Array.from(tag_identifiers)
	new_tag_identifiers[tag_position] = this.names[replacement_tag_identifier_index]

//	Replace the identifiers
	var new_tag_identifier_indexes = Array.from(tag_identifier_indexes)
	new_tag_identifier_indexes[tag_position] = replacement_tag_identifier_index

//	Make the new tagged identifier
	const new_identifier = identifier_base+':'+new_tag_identifiers.join(':');
	const new_tagged_identifier = [identifier_base, identifier_base_original_case, new_tag_identifiers, new_tag_identifier_indexes, lineNumber]

//	Recursively call the function
	return this.visitTagExpansion(new_identifier, new_tagged_identifier, ...visitor_params);
}







//	======= CHECK IDENTIFIERS ======

// forbidden_keywords cannot be used as tags or object names
const forbidden_keywords = sectionNames.concat(['checkpoint', '...','|','[',']','late','rigid', 'no','randomdir','random', 'any', 'all', 'some', 'moving','stationary','action','message'])

Identifiers.prototype.checkIdentifierType = function(identifier_index, accepted_types, accepts_mapping)
{
	const type = this.comptype[identifier_index]
	if ( accepted_types.includes(type) )
		return true;
	if (accepts_mapping && (type === identifier_type_mapping))
		return this.mappings[this.tag_mappings[identifier_index][0]].toset.every( i => this.checkIdentifierType(i, accepted_types, true) )
	return false;
}




//	======= CHECK IDENTIFIERS FOR TAGS =======

Identifiers.prototype.checkKnownTagClass = function(identifier)
{
	const identifier_index = this.names.indexOf(identifier);
	return (identifier_index >= 0) && (this.comptype[identifier_index] == identifier_type_tagset);
}



//	======= CHECK IDENTIFIERS FOR OBJECTS =======

// checks that an object name with tags is well formed and returns its parts
Identifiers.prototype.identifierIsWellFormed = function(identifier, accepts_mapping, log)
{
//	Extract tags
	const [identifier_base, ...identifier_tags] = identifier.split(':');
	if ( (identifier_tags.length === 0) || (identifier_base.length === 0) ) // it's OK to have an identifier starting with a semicolon or being just a semicolon
		return [0, identifier_base, []];

	const tags = identifier_tags.map( tagname => [this.names.indexOf(tagname), tagname] );

//	Tags must not be empty
	if (identifier_tags.some(x => (x.length === 0)))
	{
		log.logError('Empty tag used in object name. You cannot have :: in an object name!')
		return [-1, identifier_base, tags]
	}

//	These tags must be known
	const unknown_tags = tags.filter( ([tag_index, tn]) => (tag_index < 0) );
	if ( unknown_tags.length > 0 )
	{
		const unknown_tagnames = unknown_tags.map( ([ti, tn]) => tn.toUpperCase() );
		log.logError('Unknown tag' + ((unknown_tags.length>1) ? 's ('+ unknown_tagnames.join(', ')+')' : (' '+unknown_tagnames[0])) + ' used in object name.');
		return [-1, identifier_base, tags];
	}

//	And they must be tag values or tag classes (or tag mappings)
	const invalid_tags = tags.filter(
		([tag_index, tn]) => ! this.checkIdentifierType(tag_index, [identifier_type_tag, identifier_type_tagset], accepts_mapping)
	);
	if ( invalid_tags.length > 0 )
	{
		const invalid_tagnames = invalid_tags.map( ([ti, tn]) => tn.toUpperCase() );
		log.logError('Invalid object name containing tags that have not been declared as tag values or tag sets: ' + invalid_tagnames.join(', ') + '.');
		return [-2, identifier_base, tags];
	}
	return [0, identifier_base, tags];
}

// checks that it is a name that could be used for an object, but does not check if it has already been declared (it's already done by the callers).
Identifiers.prototype.canBeAnObjectName = function(candname, log)
{
//	Warn if the name is a keyword
	if (forbidden_keywords.indexOf(candname) >= 0)
	{
		log.logWarning(['identifier_name_is_keyword', candname])
		return [0, candname, []]; // yes, this is only a warning
	}
//	Check the tags
	return this.identifierIsWellFormed(candname, false, log);
}

// Function used when declaring objects in the OBJECTS section and synonyms/properties/aggregates in the LEGEND section
Identifiers.prototype.checkIfNewIdentifierIsValid = function(candname, accept_implicit, log)
{
//	Check if this name is already used
	const identifier_index = this.names.indexOf(candname);
	if (identifier_index >= 0)
	{
		// Is it OK to redefine it if it has been implicitly defined earlier?
		if (   accept_implicit
			&& (this.implicit[identifier_index] > 0)
			&& this.checkIdentifierType(identifier_index, [identifier_type_object, identifier_type_property, identifier_type_aggregate], false)
		)
			return true;
		const type = this.deftype[identifier_index]
		const definition_string = (type !== identifier_type_object) ? ' as ' + identifier_type_as_text[type] : '';
		const l = this.lineNumbers[identifier_index];
		if (l == -1)
		{
			log.logError(['identifier_name_is_keyword', candname]) // TODO: inconsitancy: it's an error here, but a warning in canBeAnObjectName.
		}
		else
		{
			log.logError(['identifier_already_defined', candname, definition_string, l])
		}
		return false;
	}

//	Check that the name can be used
	const [error_code, identifier_base, tags] = this.canBeAnObjectName(candname, log);
	return (error_code == 0);
}

// TODO: we should log an error if the identifier is not found, instead of letting the caller do that, so that we have uniform error messages.
// also we should define error functions for logging the messages, so that the caller can change the message or do something appropriate in case of error.
Identifiers.prototype.checkIdentifierIsKnownWithType = function(identifier, accepted_types, accepts_mapping, log)
{
	const result = this.names.indexOf(identifier)
	if (result < 0)
		return -2
	if (this.checkIdentifierType(result, accepted_types, accepts_mapping))
		return result
	log.logError(['wrong_identifier_type_generic', identifier, this.comptype[result], accepted_types.map(t => identifier_type_as_text[t]).join(' or ')+(accepts_mapping ? ' or a mapping giving one.' : '.')])
	return -1
}

// check if an identifier used somewhere is a known object or property.
// This function should be used instead of this.identifiers.names.indexOf(identifier) whenever there is a possibility the identifier contains tags.
Identifiers.prototype.checkKnownIdentifier = function(identifier, accepts_mapping, log)
{
//	First, check if we have that name registered
	const result = this.checkIdentifierIsKnownWithType(identifier, [identifier_type_object, identifier_type_property, identifier_type_aggregate], accepts_mapping, log);
	if (result !== -2)
		return result; // known identifier with an appropriate type or -1

//	If not, it must contain tags
	const [error_code, identifier_base, tags] = this.identifierIsWellFormed(identifier, accepts_mapping, log);
	if (tags.length === 0)
	{
		// log.logError('Unknown object '+identifier.toUpperCase()+'.')
		return -2;
	}
	if (error_code < 0)
		return error_code - 2;

	const tagged_identifier = [identifier_base, identifier_base, tags.map( ([,tag_name]) => tag_name ), tags.map( ([tag_index,]) => tag_index ), log.lineNumber]

//	For all possible combinations of tag values in these tag classes, the corresponding object must have been defined (as an object).
	if ( ! this.visitTagExpansion(identifier, tagged_identifier, accepts_mapping, this.checkTagMapping.bind(this), this.checkImplicitObjectIdentifier.bind(this, log)) )
		return -5;

//	Register the identifier as a property to avoid redoing all this again.
	return this.visitTagExpansion(identifier, tagged_identifier, accepts_mapping, this.registerTagMapping.bind(this), this.registerImplicitObjectIdentifier.bind(this));
}



// Functions to use with visitTagExpansion to check the expansion of tags creates only registered objects
Identifiers.prototype.checkImplicitObjectIdentifier = function(log, new_identifier, tagged_identifier, tag_mapping)
{
	if (tag_mapping.every( x => (x === null) ))
	{
		// no tag class in the tags: check that the object exists
		const result = this.names.indexOf(new_identifier) >= 0;
		if ( ! result )
		{
			log.logError('Unknown combination of tags for an object: '+new_identifier.toUpperCase()+'.');
		}
		return result;
	}
	// for all tags, check that every possible replacement of a tagclass tag is valid
	return tag_mapping.every( x => ((x === null) || (x === true)) );
}
Identifiers.prototype.checkTagMapping = function(tag_identifier_index, tag_position, tagged_identifier, mapping_from, mapping_startset, mapping_endset)
{
	return mapping_endset.every( x => x ); // all posible replacements of the tagclass tag must be valid!
}




Identifiers.prototype.checkCompoundDefinition = function(identifiers, compound_name, compound_type, log)
{
	var ok = true;
	var objects = new Set()
	const forbidden_type = (compound_type == identifier_type_aggregate) ? identifier_type_property : identifier_type_aggregate;
	// TODO: change forbidden_type for accepted_type!
	for (const identifier of identifiers)
	{
		const identifier_index = this.checkKnownIdentifier(identifier, false, log);
		if (identifier_index < 0)
		{
			ok = false;
			const type_as_string = (compound_type == identifier_type_aggregate) ? 'aggregate ' : 'property ';
			log.logError('Unknown identifier "' + identifier.toUpperCase() + '" found in the definition of ' + type_as_string + compound_name.toUpperCase() + ', ignoring it.');
		}
		else
		{
			if (this.comptype[identifier_index] == forbidden_type)
			{
				if (compound_type == identifier_type_aggregate)
					log.logError("Cannot define an aggregate (using 'and') in terms of properties (something that uses 'or').");
				else
					log.logError("Cannot define a property (using 'or') in terms of aggregates (something that uses 'and').");
				ok = false;
			}
			else
			{
				this.getObjectsForIdentifier(identifier_index).forEach( o => objects.add(o) )
			}
		}
	}
	return [ok, objects];
}







//	======== REGISTER AND CHECK =======

Identifiers.prototype.checkAndRegisterNewTagValue = function(tagname, original_case, class_tagset, log)
{

//	Create a new tag if it does not already exists
	const identifier_index = this.names.indexOf(tagname);
	if (identifier_index < 0)
	{
		const new_identifier_index = this.registerNewIdentifier(tagname, original_case, identifier_type_tag, identifier_type_tag, new Set([this.names.length]), [], 0, log.lineNumber)
		class_tagset.add(new_identifier_index)
		return
	}

//	Reuse existing tag or tagset
	if ( [identifier_type_tag, identifier_type_tagset].includes(this.comptype[identifier_index]) )
	{
		this.object_set[identifier_index].forEach(x => class_tagset.add(x))
		return
	}

//	Existing identifier but not a tag!
	const l = this.lineNumbers[identifier_index]
	log.logError('You are trying to define a new tag named "'+tagname.toUpperCase()+'", but this name is already used for '+
		identifier_type_as_text[this.comptype[identifier_index]]+ ((l >= 0) ? ' defined '+makeLinkToLine(l, 'line ' + l.toString())+'.' : ' keyword.'));
}


// Functions to use with visitTagExpansion to implicitely register all the names resulting from a tag expansion
Identifiers.prototype.registerTagMapping = function(tag_identifier_index, tag_position, tagged_identifier, mapping_from, mapping_startset, mapping_endset)
{
	const result = this.mappings.length;
	this.mappings.push({
		identifier_index: tag_identifier_index,
		from: mapping_from,
		fromset: mapping_startset,
		toset: mapping_endset
	});
	return result;
}
Identifiers.prototype.registerImplicitObjectIdentifier = function(new_identifier, tagged_identifier, tag_mapping)
{
	const replaced_tags = tag_mapping.filter( x => (x !== null) )

	const [identifier_base, identifier_base_original_case, new_tag_identifiers, tag_identifier_indexes, lineNumber] = tagged_identifier
	const new_original_case = identifier_base_original_case+':'+tag_identifier_indexes.map(i => this.original_case_names[i] ).join(':');

	if (replaced_tags.length == 0) // Only tag values in the tags, no tag class => new_identifier is the name of an atomic object 
	{
		const result = this.names.indexOf(new_identifier);
		if (result >= 0) // the object been (implicitely) defined before
			return result;
		return this.registerNewObject(new_identifier, new_original_case, 1, tagged_identifier[4]); // TODO: pass the number we should use for implicit (1 or 2) as parameter?
	}

//	Compute the set objects covered by this identifier
	const objects = new Set()
	this.mappings[replaced_tags[0]].toset.forEach( ii => this.object_set[ii].forEach(oii => objects.add(oii) ) )

	if (objects.size > 1) // Register the identifier as a property to avoid redoing all this again.
		return this.registerNewLegend(new_identifier, new_original_case, objects, [null, ...tag_mapping], identifier_type_property, 1, lineNumber);

	// all tag classes have only one value => new synonym
	const old_identifier_index = this.objects[objects.values().next().value].identifier_index;
	return this.registerNewSynonym(new_identifier, new_original_case, old_identifier_index, [null, ...tag_mapping], lineNumber);
}


// function called when declaring an object in the OBJECTS section
// returns the new identifier if it was OK, -1 otherwise
Identifiers.prototype.checkAndRegisterNewObjectIdentifier = function(candname, original_case, log)
{
//	Check if this name is already used
	const identifier_index = this.names.indexOf(candname);
	if (identifier_index >= 0)
	{
	//	If it was defined implicitly, we just have to mark it as explicitely defined.
		if (this.implicit[identifier_index] > 0)
		{
			this.implicit[identifier_index] = 0
			return identifier_index;
		}
		this.checkIfNewIdentifierIsValid(candname, true, log) // just to reuse the error message that it will trigger
		return -1;
	}

//	Check that the name can be used
	const [error_code, identifier_base, tags] = this.canBeAnObjectName(candname, log);
	if (error_code < 0)
		return -1;

	if (tags.length == 0) // no tag in identifier
		return this.registerNewObject(candname, original_case, 0, log.lineNumber)

	// const tag_values = tags.map( ([tag_index,tag_name]) => this.object_set[tag_index] );
	const identifier_base_original_case = original_case.split(':')[0]

	const tag_names = tags.map( ([tag_index, tag_name]) => tag_name )
	const tag_identifier_indexes = tags.map( ([tag_index, tag_name]) => tag_index )
	const tagged_identifier = [identifier_base, identifier_base_original_case, tag_names, tag_identifier_indexes, log.lineNumber]
	// const result = this.checkAndRegisterNewImplicitObjectIdentifier(candname, tagged_identifier);
	const result = this.visitTagExpansion(candname, tagged_identifier, false, this.registerTagMapping.bind(this), this.registerImplicitObjectIdentifier.bind(this));
	this.implicit[result] = 0; // now it's explicitly defined
	return result;
}





//	====== GENERATE EXPANSIONS FROM PARAMETERS ======

function* cartesian_product(head, ...tail)
{
	const remainder = tail.length > 0 ? cartesian_product(...tail) : [[]];
	for (let r of remainder)
		for (let h of head)
			yield [h, ...r];
}

Identifiers.prototype.getExpansionForIdentifier = function(identifier_index)
{
	const objects = Array.from(this.object_set[identifier_index])
	switch (this.comptype[identifier_index])
	{
		case identifier_type_tagset:
			return objects // for tags, object_set actually contains identifiers
		default:
			console.log('WARNING! I should not get there! Trying to expand parameter ' + this.names[identifier_index] + ' that is neither a property or tag class but ' + identifier_type_as_text[this.comptype[identifier_index]])
		case identifier_type_property:
			return objects.map( object_index => this.objects[object_index].identifier_index )
	}
}

Identifiers.prototype.make_expansion_parameter = function(identifiers_indexes)
{
	return Array.from(
		identifiers_indexes,
		identifier_index => this.getExpansionForIdentifier(identifier_index)
	)
}

Identifiers.prototype.expand_parameters = function*(identifiers_indexes)
{
	for (const parameters of cartesian_product(...this.make_expansion_parameter(identifiers_indexes)))
	{
		yield parameters;
	}
}


Identifiers.prototype.has_directional_tag_mapping = function(identifier_index)
{
	return this.tag_mappings[identifier_index].slice(1).filter(x => x !== null).some(
		mapping_index => this.mappings[mapping_index].fromset.some( ii => absolutedirs.includes(this.names[ii]) )
	);
}

Identifiers.prototype.replace_directional_tag_mappings = function(direction, identifier_index)
{
//	Apply mappings appearing in the tags
	for (var tag_position=1; tag_position < this.tag_mappings[identifier_index].length; tag_position++)
	{
		const mapping_index = this.tag_mappings[identifier_index][tag_position]
		if (mapping_index === null) // no mapping in this tag
			continue;
		const mapping = this.mappings[mapping_index]

	//	Replace direction parameters only when the tag uses a directional mapping (not when the tag is 'directions' or a subset or superset of it)
		const direction_index = mapping.fromset.indexOf(this.names.indexOf(direction))
		if ( (direction_index < 0) || (mapping.identifier_index == mapping.from) ) // direction not included in tag, or not a tag mapping
			continue;
		identifier_index = mapping.toset[direction_index]
	}
	return identifier_index;
}

Identifiers.prototype.replace_parameters = function(start_identifier_index, from_identifiers_indexes, replacements_identifier_indexes)
{
	var identifier_index = start_identifier_index
//	Apply mappings appearing in the tags
	for (var tag_position=1; tag_position < this.tag_mappings[identifier_index].length; tag_position++)
	{
		const mapping_index = this.tag_mappings[identifier_index][tag_position]
		if (mapping_index === null) // no mapping in this tag
			continue;
		const mapping = this.mappings[mapping_index]

	//	Replace tag class parameters when they appear directly as a tag or as the fromset of a tag mapping
		const tagclass_parameter_index = from_identifiers_indexes.indexOf(mapping.from)
		if (tagclass_parameter_index < 0)
			continue;
		// the tag mapping is compatible with a tag class parameter
		const replaced_tag = replacements_identifier_indexes[tagclass_parameter_index]
		identifier_index = mapping.toset[ mapping.fromset.indexOf(replaced_tag) ]
	}

//	Replace property parameters and apply object mappings
	const identifier_property = (this.comptype[identifier_index] === identifier_type_mapping) ? this.mappings[this.tag_mappings[identifier_index][0]].from : identifier_index
	const property_parameter_index = from_identifiers_indexes.indexOf(identifier_property)
	if (property_parameter_index >= 0)
	{
		identifier_index = replacements_identifier_indexes[property_parameter_index]
	}
	return identifier_index;
}


Identifiers.prototype.getTagClassesInIdentifier = function(identifier_index)
{
	return Array.from( this.tag_mappings[identifier_index].filter( x => (x !== null) ), mapping_index => this.mappings[mapping_index].from)
}


// A class to ease the creation of syntaxes/features that rely on expansion.
function ExpansionContext(params = [], expansion = [])
{
	this.parameters = params
	this.expansion = expansion // an array of pairs [expansion_result, parameter_values] where expansion_result is the result of each expansion (should be copyable by the default js copy function) and parameter_values is the array of the values taken by each expansion parameter in this expansion
}

ExpansionContext.prototype.copy = function()
{
	return new ExpansionContext(
		Array.from( this.parameters ),
		Array.from( this.expansion, ([target, parameter_values]) => [target, Array.from(parameter_values)] )
	)
}

// Filters some expansions based on the given function (removes the expansion for which the function returns false)
ExpansionContext.prototype.filter = function(test_func)
{
	this.expansion = this.expansion.filter( test_func )
}

// Create an expansion context from an identifier by using each of the tag classes its name contains as an expansion parameter.
Identifiers.prototype.expansion_context_from_identifier = function(identifier_index)
{
	if (identifier_index === undefined)
		return new ExpansionContext()

	const classes = this.getTagClassesInIdentifier(identifier_index)
	if (classes.length === 0)
		return new ExpansionContext(
			[],
			[ [ this.getObjectFromIdentifier(identifier_index), [] ] ]
		)

	return new ExpansionContext(
		classes,
		Array.from(
			this.expand_parameters(classes),
			(expansion, i) => [ this.getObjectFromIdentifier(this.replace_parameters(identifier_index, classes, expansion)), expansion]
		)
	)
}

// Create an expansion context from a list of expansion parameters, using the given function to generate the object attached to each expansion
Identifiers.prototype.expansion_context = function(parameter_list, default_object, func)
{
	if (parameter_list.length === 0)
		return new ExpansionContext(
			[],
			[ [ default_object, [] ] ]
		)

	return new ExpansionContext(
		parameter_list,
		Array.from(
			this.expand_parameters(parameter_list),
			(expansion, i) => [ func(expansion, i), expansion ]
		)
	)
}


//	======= CLONING RULES =======

function deepCloneCellRow(cellrow)
{
	return cellrow.map(
		cell =>  cell.map( oc => (oc === null) ? null : ({dir: oc.dir, ii: oc.ii, no: oc.no, random: oc.random})  )
	);
}

function deepCloneHS(HS)
{
	return HS.map( deepCloneCellRow );
}

function deepCloneRule(rule)
{
	return {
		lineNumber: rule.lineNumber,
		groupNumber: rule.groupNumber,
		direction: rule.direction,
		tag_classes: rule.tag_classes,
		tag_classes_replacements: rule.tag_classes_replacements,
		parameter_properties: rule.parameter_properties,
		parameter_properties_replacements: rule.parameter_properties_replacements,
		parameter_expansion_string: rule.parameter_expansion_string,
		late: rule.late,
		rigid: rule.rigid,
		randomRule:rule.randomRule,
		lhs: deepCloneHS(rule.lhs),
		rhs: deepCloneHS(rule.rhs),
		commands: rule.commands, // should be deepCloned too?
		is_directional: rule.is_directional
	};
}



//	======= PRINTING RULES =======

function printCell(identifiers, cell)
{
	var result = '';
	for (const oc of cell)
	{
		if (oc === null)
		{
			result += '... '
		}
		else
		{
			if (oc.no)
				result += 'no '
			if (oc.random)
				result += 'random '
			result += oc.dir + ' '
			result += identifiers.names[oc.ii]+' '
		}
	}
	return result
}

function printCellRow(identifiers, cellRow)
{
	return '[ ' + cellRow.map(c => printCell(identifiers,c)).join('| ') + '] ';
}

function cacheRuleStringRep(identifiers, rule)
{
	var result='('+makeLinkToLine(rule.lineNumber)+') '+ rule.direction.toString().toUpperCase()+ ' ';
	if (rule.tag_classes.size > 0)
	{
		result += [...rule.tag_classes].map( (tc_ii, i) => (identifiers.names[tc_ii].toUpperCase()+'='+identifiers.names[rule.tag_classes_replacements[i]]) ).join(', ') + ' '
	}
	if (rule.parameter_properties.size > 0)
	{
		result += [...rule.parameter_properties].map( (pp_ii, i) => (identifiers.names[pp_ii].toUpperCase()+'='+identifiers.names[rule.parameter_properties_replacements[i]]) ).join(', ') + ' '
	}
	if (rule.rigid) {
		result = "RIGID "+result+" ";
	}
	if (rule.randomRule) {
		result = "RANDOM "+result+" ";
	}
	if (rule.late) {
		result = "LATE "+result+" ";
	}
	for (const cellRow of rule.lhs) {
		result = result + printCellRow(identifiers, cellRow);
	}
	result = result + "-> ";
	for (const cellRow of rule.rhs) {
		result = result + printCellRow(identifiers, cellRow);
	}
	result += rule.commands.get_representation()
	rule.stringRep = result
}

function cacheAllRuleNames(state)
{
	for (const rule of state.rules)
	{
		cacheRuleStringRep(state.identifiers, rule);
	}
}


var directionaggregates = {
	'horizontal' : ['left', 'right'],
	'vertical' : ['up', 'down'],
	'moving' : ['up', 'down', 'left', 'right', 'action'],
	'orthogonal' : ['up', 'down', 'left', 'right'],
	'perpendicular' : ['^','v'],
	'parallel' : ['<','>']
};

var relativeDirections = ['^', 'v', '<', '>','horizontal','vertical'];
var simpleAbsoluteDirections = ['up', 'down', 'left', 'right'];
var simpleRelativeDirections = ['^', 'v', '<', '>'];
var reg_directions_only = /^(\>|\<|\^|v|up|down|left|right|moving|stationary|no|randomdir|random|horizontal|vertical|orthogonal|perpendicular|parallel|action)$/;

function* objectConstraint_iterator(rule)
{
	for (const side of [rule.lhs, rule.rhs])
		for (const cell_row of side)
			for (const cell of cell_row)
				for (const object_constraint of cell)
					if (object_constraint !== null)
						yield object_constraint
}

function directionalRule(identifiers, rule)
{
	if ( rule.lhs.some( cellrow => (cellrow.length > 1) ) || rule.rhs.some( cellrow => (cellrow.length > 1) ) )
		return true
	for (const oc of objectConstraint_iterator(rule))
	{
		if (oc === null)
			continue
		// TODO: should'nt it also include 'perpendicular' and 'parallel' but exclude 'horizontal' and 'vertical'?
		if ( relativeDirections.includes(oc.dir) || identifiers.has_directional_tag_mapping(oc.ii) )
			return true
	}
	return false
}

function findIndexAfterToken(str, tokens, tokenIndex)
{
	str = str.toLowerCase();
	var curIndex = 0;
	for (var i=0; i<=tokenIndex; i++)
	{
		const token = tokens[i];
		curIndex = str.indexOf(token, curIndex) + token.length;
	}
	return curIndex;
}


//read initial directions
// syntax is ("+")? (!"+"|"direction"|"late"|"rigid"|"random")+  ("["), where 'direction' is itself (directionaggregate|simpleAbsoluteDirection|!simpleRelativeDirection)
// (I use the ! here to denote something that is recognized by the parser but wrong)
function parseRuleDirections(state, tokens, lineNumber)
{
	var directions = [];
	var tag_classes = new Set();
	var properties = new Set();
	var late = false;
	var rigid = false;
	var randomRule = false;
	var has_plus = false;

	for (var i = 0; i < tokens.length; i++)
	{
		const token = tokens[i];
		if (token === '+')
		{
			if (i !== 0)
			{
				if (has_plus) {
					logError('Two "+"s ("append to previous rule group" symbol) applied to the same rule.', lineNumber);
				} else {
					logError('The "+" symbol, for joining a rule with the group of the previous rule, must be the first symbol on the line ');
				}
			}
			has_plus = true;
		}
		else if (token in directionaggregates) {
			directions.push(...directionaggregates[token]);
		} else if (token === 'late') {
			late = true;
		} else if (token === 'rigid') {
			rigid = true;
		} else if (token === 'random') {
			if (has_plus)
			{
				logError(['random_on_nonfirst_group_rule'], lineNumber)
			}
			randomRule = true;
		} else if (simpleAbsoluteDirections.indexOf(token) >= 0) {
			directions.push(token);
		} else if (simpleRelativeDirections.indexOf(token) >= 0) {
			logError('You cannot use relative directions (\"^v<>\") to indicate in which direction(s) a rule applies.  Use absolute directions indicators (Up, Down, Left, Right, Horizontal, or Vertical, for instance), or, if you want the rule to apply in all four directions, do not specify directions', lineNumber);
		}
		else if (token === '[')
		{
			if (directions.length == 0) {
				directions.push(...directionaggregates['orthogonal']); // it's not actually about orthogonality, it's just that this word contains the four directions and only that
			}
			return [ directions, tag_classes, properties, late, rigid, randomRule, has_plus, i ];
		}
		else if (state.identifiers.checkIdentifierIsKnownWithType(token, [identifier_type_tagset, identifier_type_property], false, state) >= 0) // we do that last because '+' and ']' may be used as identifiers (synonyms)
		{
			const identifier_index = state.identifiers.names.indexOf(token);
			const identifier_type =  state.identifiers.comptype[identifier_index];
			switch (identifier_type)
			{
				case identifier_type_tagset:
					if (tag_classes.has(identifier_index))
					{
						logWarning('Dupplicate specification of tag class '+token.toUpperCase()+' as rule parameter.', lineNumber);
						break;
					}
					tag_classes.add(identifier_index);
					break;
				case identifier_type_property:
					if (properties.has(identifier_index))
					{
						logWarning('Dupplicate specification of property '+token.toUpperCase()+' as rule parameter.', lineNumber);
						break;
					}
					properties.add(identifier_index);
					break;
				default:
					logError('Cannot use '+token.toUpperCase()+' as a rule parameter: it is defined as '+identifier_type_as_text(identifier_type)+', but only tag classes and object properties can be used as rule parameters.', lineNumber);
			}
		}
		else
		{
			logError("The start of a rule must consist of some number of directions (possibly 0), before the first bracket, specifying in what directions to look (with no direction specified, it applies in all four directions).  It seems you've just entered \"" + token.toUpperCase() + '\".', lineNumber);
		}
	}

	// We would get there by reading the whole line without encountering a [, but we probably don't need to deal with it
	return [ directions, tag_classes, properties, late, rigid, randomRule, has_plus, tokens.length ];

}


// TODO: it should be in parser.js?
function parseRuleString(rule, state, curRules) 
{
/*
	intermediate structure
		dirs: Directions[]
		pre : CellMask[]
		post : CellMask[]

		//pre/post pairs must have same lengths
	final rule structure
		dir: Direction
		pre : CellMask[]
		post : CellMask[]
*/
	var [line, lineNumber, origLine] = rule;
	state.lineNumber = lineNumber // TODO: inelegant. Just to report errors.

//	STEP ONE, TOKENIZE
	line = line.replace(/\[/g, ' [ ').replace(/\]/g, ' ] ').replace(/\|/g, ' | ').replace(/\-\>/g, ' -> ');
	line = line.trim();
	if (line[0] === '+')
	{
		line = line.substring(0,1) + " " + line.substring(1,line.length);
	}
	var tokens = line.split(/\s/).filter(function(v) {return v !== ''});

	if (tokens.length == 0)
	{
		logError('Spooky error!  Empty line passed to rule function.', lineNumber);
	}


// STEP TWO, READ DIRECTIONS

	if (tokens.length === 1)
	{
		const bracket = ({startloop: 1, endloop: -1})[tokens[0]];
		if ( bracket !== undefined )
		{
			return {
				bracket: bracket
			}
		}
	}

	if (tokens.indexOf('->') == -1)
	{
		logError(['rule_without_arrow'], lineNumber)
	}

	const [ directions, tag_classes, properties, late, rigid, randomRule, has_plus, nb_tokens_in_rule_directions ] = parseRuleDirections(state, tokens, lineNumber);

	var groupNumber = lineNumber;
	if (has_plus)
	{
		if (curRules.length == 0)
		{
			logError('The "+" symbol, for joining a rule with the group of the previous rule, needs a previous rule to be applied to.');							
		}
		groupNumber = curRules[curRules.length-1].groupNumber; // TODO: curRules is only provided to this function for that, it would be beter to provide directly the last groupNumber.
	}

	var curcellrow = []; // [  [up, cat]  [ down, mouse ] ] -> a cell row is everything betwen [ and ], it is an array of cells
	var curcell = [] // [up, cat, down mouse] -> a cell is everything between [or| and |or], it is '...' or an array of object conditions.
	var curobjcond = { dir: null, ii: null, no: false, random: false } // -> an object condition is a sequence "direction? identifier", it is a pair [ direction or null, identifier_index ]
	var should_close_cellrow = false;
	var should_close_cell = false;
	var should_close_objcond = false;
	var cell_contains_ellipses = false;
	var should_add_ellipses = false;

	var incellrow = false;

	var rhs = false;
	var lhs_cells = [];
	var rhs_cells = [];
	var commands = new CommandsSet()

	var bracketbalance = 0;
	for (var i = nb_tokens_in_rule_directions; i < tokens.length; i++)
	{
		const token = tokens[i];

		// reading cell contents LHS
		// the syntax for the rule is: rule_directions (cellrow)+ "->" (cellrow)* commands
		// where cellrow is: "[" (cell "|")* cell "]"
		// and cell is: ( (single_direction_or_action)? identifier )* | "...", but the "..." cannot appear as a first or last cell in a cellrow
		// and commands is: ( commandword | ("message" everything_to_the_end_of_line) )*
		// but if any token that is allowed elsewhere in the rule is seen where it should not be, this is reported (with different messages depending on where it it seen)
		if (token == '[')
		{
			bracketbalance++;
			if (bracketbalance > 1) {
				logWarning(['rule_open_open_brackets'], lineNumber)
			}
			if (curcell.length > 0) { // TODO: isn't that dupplicating what the bracketbalance test does?
				logError('Error, malformed cell rule - encountered a "["" before previous bracket was closed', lineNumber);
			}
			incellrow = true;
			curcell = [];
		} else if (reg_directions_only.exec(token)) {
			if (!incellrow) {
				logWarning(['directions_outside_cellrows'], lineNumber);
			} else if (curobjcond.no || curobjcond.random) {
				// TODO: it would be nice to allow "no up crate" to match cells that have either no crate or a crate that does not move up. But it requires changes in the engine.
				logError(['no_or_random_followed_by_direction', tokens[i-1]], lineNumber)
			} else if (token === 'random') {
				if ( ! rhs )
				{
					logError(['random_in_LHS', token], rule.lineNumber)
				}
				curobjcond.random = true
			} else if (token === 'no') {
				if (curobjcond.dir !== null)
				{
					logError(['direction_NO_object'], lineNumber)
				}
				curobjcond.no = true
			} else if (late) {
				logWarning(['movements_in_laterule'], lineNumber)
			} else if (curobjcond.dir !== null) {
				// TODO: fix bug https://github.com/increpare/PuzzleScript/issues/395
				//       Basically, we need to replace directions words with 'direction' flags (including 'no' and 'random' that are not directions) and check
				//       there is no more than one direction? (relative directions should not yet be resolved, however)
				//       the idea behind the error message is that the direction words would be and-ed, which is certainly coherent with the idea that they define
				//       additional constraints on the matching but is also incompatible with the use of some words like 'parallel' that present an alternative (< or >).
				//       And we clearly want the ability to have alternatives, but it's just a shortcut to avoid making multiple rules instead.
				logError("Error, an item can only have one direction/action at a time, but you're looking for several at once!", lineNumber);
			} else if ( ! rhs && token === 'randomdir' ) {
				logError(['random_in_LHS', token], lineNumber)
			} else {
				curobjcond.dir = token
			}
		} else if (token == '|') {
			if (!incellrow) {
				logWarning('Janky syntax.  "|" should only be used inside cell rows (the square brackety bits).', lineNumber);
			} else {
				should_close_cell = true;
			}
		} else if (token === ']') {
			bracketbalance--;
			if (bracketbalance < 0) {
				logWarning(['rule_close_close_brackets'], lineNumber)
			}
			should_close_cellrow = true; // TODO: should it be "should_close_cellrow = (bracketbalance == 0)"?
		} else if (token === '->') {
			if (incellrow) {
				logError(['rule_arrow_in_cell'], lineNumber)
			} else if (rhs) {
				logError('Error, you can only use "->" once in a rule; it\'s used to separate before and after states.', lineNumber);
			} else {
				rhs = true;
			}
		} else if (state.identifiers.checkKnownIdentifier(token, true, state) >= 0) { // TODO: we need to check if it can be an object identifier without triggering errors
			                                                                 // especially, it should reject command keywords without loging an error...
			if (!incellrow) {
				logWarning("Invalid token "+token.toUpperCase() +". Object names should only be used within cells (square brackets).", lineNumber);
			}
			curobjcond.ii = state.identifiers.checkKnownIdentifier(token, true, state) // TODO: we should not search it twice...
			should_close_objcond = true;
		} else if (token === '...') {
			if (!incellrow) {
				logWarning("Invalid syntax, ellipses should only be used within cells (square brackets).", lineNumber);
			}
			else if (curcellrow.length == 0)
			{
				logError('You cannot start a cell row (the square brackety things) with ellipses.', lineNumber);
			}
			else
			{
				should_add_ellipses = true;
			}
		} else if (CommandsSet.prototype.is_command(token)) {
			if (rhs === false) {
				logError("Commands cannot appear on the left-hand side of the arrow.", lineNumber);
			}
			if (incellrow)
			{
				logError(['commands_in_cellrow'], lineNumber)
			}
			if (token === 'message')
			{
				const messageIndex = findIndexAfterToken(origLine, tokens, i)
				const message_string = origLine.substring(messageIndex).trim()
				commands.setMessage({
					text: (message_string.length > 0) ? wordwrapAndColor(message_string, state.fgcolor) : [],
				})
				i=tokens.length
			} else {
				commands.addCommand(token)
			}
		} else {
			logError('Error, malformed cell rule - was looking for cell contents, but found "' + token + '".  What am I supposed to do with this, eh, please tell me that.', lineNumber);
		}

		if (should_close_objcond || should_add_ellipses || should_close_cell || should_close_cellrow)
		{
			// close the current object condition / ellipsis
			if (curobjcond.ii === null)
			{
				if ( (curobjcond.dir) !== null || curobjcond.no || curobjcond.random )
				{
					// TODO: this error message should not be triggered when something was provided but was not a valid object name.
					// TODO: the error message is a little bit misleading as it would also be trigered by 'no' or 'random' not being followed by an identifier.
					logError('In a rule, if you specify a force, it has to act on an object.', lineNumber)
				}
			}
			else
			{
				if (curobjcond.dir === null)
					curobjcond.dir = ''
				curcell.push(curobjcond)
			}
			curobjcond = { dir: null, ii: null, no: false, random: false }
			should_close_objcond = false;
		}

		if (should_add_ellipses)
		{
			curcell.push(null)
			cell_contains_ellipses = true;
			should_add_ellipses = false;
		}

		if (should_close_cell || should_close_cellrow)
		{
			// close the current cell
			if ( cell_contains_ellipses && (curcell.length > 1) )
			{
				logError(['ellipses_not_alone'], lineNumber)
			}
			curcellrow.push(curcell);
			curcell = [];
			should_close_cell = false;
			cell_contains_ellipses = false;
		}

		if (should_close_cellrow)
		{
			if ( (curcellrow.length == 0) && (!rhs) )
			{
				logError("You have an totally empty pattern on the left-hand side.  This will match *everything*.  You certainly don't want this.");
			}
			if ( (curcellrow.length > 0) && (curcellrow[curcellrow.length - 1] === null)) {
				logError('You cannot end a bracket with ellipses.', lineNumber);
			}
			else 
			{
				(rhs ? rhs_cells : lhs_cells).push(curcellrow);
				curcellrow = [];
			}
			incellrow = false;
			should_close_cellrow = false;
		}
	}

	// Check the coherence between LHS and RHS
	if (lhs_cells.length != rhs_cells.length) {
		if ( (commands.nb_commands === 0) || (rhs_cells.length > 0) )
		{
			logError(['different_nb_cellrows'], lineNumber)
		}
	} else {
		for (const [i, lhs_cell] of lhs_cells.entries())
		{
			if (lhs_cell.length != rhs_cells[i].length)
			{
				logError(['different_nb_cells'], lineNumber)
				return null // ignoring the rule because it would cause bugs later in the code.
			}
		}
	}

	var rule_line = {
		lineNumber: lineNumber,
		groupNumber: groupNumber,
		directions: directions,
		tag_classes: tag_classes,
		parameter_properties: properties,
		late: late,
		rigid: rigid,
		randomRule: randomRule,
		lhs: lhs_cells,
		rhs: rhs_cells,
		commands: commands
	};

	rule_line.is_directional = directionalRule(state.identifiers, rule_line)
	if (rule_line.is_directional === false)
	{
		rule_line.directions = ['up'];
	}

	//next up - replace relative directions with absolute direction
	return rule_line;
}




function* generateDirections(directions)
{
	for (const dirword of directions)
	{
		for (const dir of (dirword in directionaggregates) ? directionaggregates[dirword] : [dirword])
		{
			yield dir;
		}
	}
}


function* generateRuleExpansion(identifiers, rule)
{
	const directions = new Set( generateDirections(rule.directions) );
	const parameter_sets = identifiers.make_expansion_parameter([...rule.tag_classes, ...rule.parameter_properties])
	for (const parameters of cartesian_product(directions, ...parameter_sets))
	{
		// console.log('generateRulesExpansions', rule.toString(), parameters.toString())
		yield [rule, ...parameters];
	}
}

function expandRule(identifiers, original_rule, dir, ...parameters)
{
	// console.log('expandRule', original_rule.toString(), dir.toString(), parameters.toString())
	var rule = deepCloneRule(original_rule);
	// Also clone the non-directional rule parameters (shallow copy because they should not be modified)
	rule.tag_classes = original_rule.tag_classes
	rule.parameter_properties = original_rule.parameter_properties

	rule.direction = dir; // we have rule.directions (plural) before this loop, but rule.direction (singular) after the loop.
	rule.tag_classes_replacements = parameters.slice(0, rule.tag_classes.size);
	rule.parameter_properties_replacements = parameters.slice(rule.tag_classes.size);
	const parameter_names = ( (rule.is_directional) ? [dir] : [] ).concat( parameters.map(ii => identifiers.names[ii]) )
	rule.parameter_expansion_string =  (parameter_names.length > 0) ? '(' + parameter_names.join(' ') + ')' : ''

//	Replace mappings of the parameters with what they map to, including directions
	applyRuleParametersMappings(identifiers, rule);
//	Optional: replace up/left rules with their down/right equivalents
	// rewriteUpLeftRules(rule);
//	Replace aggregates and synonyms with what they mean, replace "no [property]" with "no obj1 no obj2 etc"
	atomizeLegendObjects(identifiers, rule);
	return rule;
}

function applyRuleParametersMappings(identifiers, rule)
{
	const forward = rule.direction
	for (const objcond of objectConstraint_iterator(rule))
	{
		if (objcond === null)
			continue
		const identifier_index = objcond.ii
		const dir_index = relativeDirs.indexOf(objcond.dir)
		if (dir_index >= 0)
		{
			objcond.dir = relativeDict[forward][dir_index]
		}
		objcond.ii = identifiers.replace_parameters(
			identifiers.replace_directional_tag_mappings(forward, identifier_index),
			[...rule.tag_classes, ...rule.parameter_properties],
			[...rule.tag_classes_replacements, ...rule.parameter_properties_replacements]
		)
	}
}

function rulesToArray(state)
{
	var rules = []
	var loops = []
	for (const oldrule of state.rules)
	{
		// parse the rule
		const lineNumber = oldrule[1]
		const newrule = parseRuleString(oldrule, state, rules)
		if (newrule === null)
			continue
		if (newrule.bracket !== undefined)
		{
			loops.push( [lineNumber, newrule.bracket] )
			continue
		}

		// expand out rules with multiple directions or rule parameters
		for (const rule_expansion of generateRuleExpansion(state.identifiers, newrule) )
		{
			const expanded_rule = expandRule(state.identifiers, ...rule_expansion)
			
			// now expand ambiguous movements
			for (const concrete_moving_rule of concretizeMovingRule(expanded_rule, lineNumber) )
			{
				// now expand properties
				rules.push( ...concretizePropertyRule(state, concrete_moving_rule, lineNumber) )
			}
		}
	}
	state.loops = loops
	state.rules = rules
}

function containsEllipsis(rule)
{
	return rule.lhs.some( cellrow => cellrow.some( cell => cell[1] === '...' ) );
}

function rewriteUpLeftRules(rule)
{
	if (containsEllipsis(rule))
		return;

	if (rule.direction == 'up')
	{
		rule.direction = 'down';
	}
	else if (rule.direction == 'left')
	{
		rule.direction = 'right';
	}
	else
		return

	for (var cellrow of rule.lhs)
	{
		cellrow.reverse()
	}
	for (var cellrow of rule.rhs)
	{
		cellrow.reverse()
	}
}

function getPropertiesFromCell(identifiers, cell)
{
	var result = []
	for (const oc of cell)
	{
		if ( (oc === null) || oc.random )
			continue
		if (identifiers.comptype[oc.ii] === identifier_type_property)
		{
			result.push(oc.ii)
		}
	}
	return result
}

//returns you a list of object names in that cell that're moving -> actually, it only returns those moving with a directionaggregate...
function getMovings(cell)
{
	return cell.filter( oc => (oc !== null) && (oc.dir in directionaggregates) )
}

function concretizePropertyInCell(cell, property, concreteType)
{
	for (var objcond of cell)
	{
		if ( (objcond !== null) && (objcond.ii === property) && ( ! objcond.random ) )
		{
			objcond.ii = concreteType
		}
	}
}

function concretizeMovingInCell(cell, ambiguousMovement, idToMove, concreteDirection)
{
	for (var objcond of cell)
	{
		if ( (objcond !== null) && (objcond.dir === ambiguousMovement) && (objcond.ii === idToMove) )
		{
			objcond.dir = concreteDirection
		}
	}
}

function concretizeMovingInCellByAmbiguousMovementName(cell, ambiguousMovement, concreteDirection)
{
	for (var objcond of cell)
	{
		if ( (objcond !== null) && (objcond.dir === ambiguousMovement) )
		{
			objcond.dir = concreteDirection
		}
	}
}


// TODO: this function and concretizeMovingRule have a very similar structure and should probably be merged.
/* Expands the properties on the LHS of a rule and disambiguates those on the RHS.
 * The rules for the expansion on the LHS are:
 * - properties prefixed by "no" are replaced by the set of objects they can be, all prefixed by "no".
 *   (De Morgan's law: no (A or B or C) = (no A) and (no B) and (no C).)
 * - new rules are created for every possible object each property can be.
 *   (i.e., the cartesian product of the sets of objects for each occurance of a property).
 * The disambiguation rules are:
 * - if the property has a single occurence in the LHS, its concrete remplacement will be used for all the
 *   occurences of this property in the RHS.
 * - if a property appearing in a cell of the RHS appears also in the same cell of the LHS, then the concrete
 *   replacement of the latter will be used for the former.
 */
function concretizePropertyRule(state, rule, lineNumber)
{	
	//are there any properties we could avoid processing?
	// e.g. [> player | movable] -> [> player | > movable],
	// 		doesn't need to be split up (assuming single-layer player/block aggregates)

	// we can't manage this if they're being used to disambiguate
	var ambiguousProperties = {}; // properties that appear in the RHS but not in the same cell of the LHS.

	for (var j = 0; j < rule.rhs.length; j++)
	{
		var row_l = rule.lhs[j];
		var row_r = rule.rhs[j];
		for (var k = 0; k < row_r.length; k++)
		{
			const properties_l = getPropertiesFromCell(state.identifiers, row_l[k]);
			const properties_r = getPropertiesFromCell(state.identifiers, row_r[k]);
			for (const property of properties_r)
			{
				if (properties_l.indexOf(property) === -1)
				{
					ambiguousProperties[property] = true
				}
			}
		}
	}

	var result = [rule];

	var shouldremove;
	var modified = true;
	while (modified)
	{
		modified = false;
		for (var i = 0; i < result.length; i++)
		{
			//only need to iterate through lhs
			const cur_rule = result[i];
			shouldremove = false;
			for (var j = 0; j < cur_rule.lhs.length && !shouldremove; j++)
			{
				const cur_rulerow = cur_rule.lhs[j];
				for (var k = 0; k < cur_rulerow.length && !shouldremove; k++)
				{
					for (const property of getPropertiesFromCell(state.identifiers, cur_rulerow[k]))
					{
						// ambiguousProperties[property] !== true means that either the property does not appear on the RHS
						// or it will be disambiguated because whenever it appears in the RHS it also appears in the matching
						// cell of the RHS.
						if ( (state.single_layer_property[property] >= 0) && (ambiguousProperties[property] !== true) )
							continue; // we don't need to explode this property

						shouldremove = true;
						modified = true;

						//just do the base property, let future iterations take care of the others
						// TODO: we currently replace a property by all the objects it can be, but if instead we replaced it by the properties/objects appearing in its
						// definition, it would allow to stop the replacements when one of the replacement is a single-layer property, creating less rules.
						// an alternative would be to split each property into its single-layer subsets, but that could introduce new bugs easily. -- ClementSparrow
						const aliases = Array.from(state.identifiers.getObjectsForIdentifier(property), object_index => state.identifiers.objects[object_index].identifier_index );
						for (const concreteType of aliases)
						{
							var newrule = deepCloneRule(cur_rule);

							// also clone the propertyReplacements of the rule
							newrule.propertyReplacement = (cur_rule.propertyReplacement === undefined) ? [] : cur_rule.propertyReplacement.map( x => Array.from(x) );

							concretizePropertyInCell(newrule.lhs[j][k], property, concreteType);
							if (newrule.rhs.length > 0)
							{
								// this disambiguates the property appearing in the same cell of the RHS, if any
								concretizePropertyInCell(newrule.rhs[j][k], property, concreteType);//do for the corresponding rhs cell as well
							}
							// note that after that, the property and the concreteType can still appear in other cells
							
							if (newrule.propertyReplacement[property] === undefined)
							{
								newrule.propertyReplacement[property] = [concreteType, 1];
							}
							else
							{
								newrule.propertyReplacement[property][1] += 1;
							}

							result.push(newrule);
						}

						break;
					}
				}
			}
			if (shouldremove)
			{
				result.splice(i, 1);
				i--;
			}
		}
	}

	
	for (var cur_rule of result)
	{
		//for each rule
		if (cur_rule.propertyReplacement === undefined)
			continue;
		
		//for each property replacement in that rule
		for (const [property, propDat] of cur_rule.propertyReplacement.entries())
		{
			if (propDat !== undefined)
			{
				const [concreteType, occurrenceCount] = propDat;

				if (occurrenceCount === 1) // the property appears only once on the LHS, so it can be used to disambiguate all the occurences of the property on the RHS.
				{
					//do the replacement
					for (var cellRow_rhs of cur_rule.rhs)
					{
						for (var cell of cellRow_rhs)
						{
							concretizePropertyInCell(cell, property, concreteType);
						}
					}
					// TODO: we could also remove the property from ambiguousProperties now, since it has
					// just been disambiguated. It would allow to just test that ambiguousProperties is
					// empty instead of doing the loop below.
				}
			}
		}
		delete cur_rule.propertyReplacement; // not used anymore
	}

	// if any properties remain on the RHSes, bleep loudly
	// TODO: why only log the last one found and not all of them?
	var rhsPropertyRemains = null
	for (const cur_rule of result)
	{
		for (const cur_rulerow of cur_rule.rhs)
		{
			for (const cur_cell of cur_rulerow)
			{
				for (const prop of getPropertiesFromCell(state.identifiers, cur_cell))
				{
					if (ambiguousProperties.hasOwnProperty(prop))
					{
						rhsPropertyRemains = prop;
					}
				}
			}
		}
	}


	if (rhsPropertyRemains !== null)
	{
		logError(['ambiguous_property', state.identifiers.names[rhsPropertyRemains]], lineNumber)
	}

	return result
}


function concretizeMovingRule(rule, lineNumber) // a better name for this function would be concretizeDirectionAggregatesInRule?
{
	var result = [rule];

//	Generate rules in which "directionaggregate identifier" instances are replaced with concrete directions for all occurences of the same directionaggregate and identifier
	
	// Note that 'parallel' and 'perpendicular' have already been replaced by 'horizontal'/'vertical' in applyRuleParametersMappings,
	// so the directionaggregates here can only be 'horizontal', 'vertical', 'moving', or 'orthogonal'.
	// Similarly, identifiers that are aggregates or synonyms have already been replaced with objects in atomizeAggregatesAndSynonyms,
	// so the identifiers here can only be objects or properties.
	
	var shouldremove;
	var modified = true;
	while (modified)
	{
		modified = false;
		for (var i = 0; i < result.length; i++)
		{
			//only need to iterate through lhs
			var cur_rule = result[i];
			shouldremove = false;
			for (var j = 0; j < cur_rule.lhs.length; j++)
			{
				const cur_rulerow = cur_rule.lhs[j];
				for (var k = 0; k < cur_rulerow.length; k++)
				{
					var movings = getMovings(cur_rulerow[k]); // TODO: this seems an inneficient way to find a list of all movings just to change one...
					if (movings.length > 0)
					{
						shouldremove = true;
						modified = true;

						//just do the base directionaggregate, let future iterations take care of the others
						//(since all occurences of the base directionaggregate will be replaced by atomic directions, it will not reappear here)
						const { dir: ambiguous_dir, ii: identifier_index } = movings[0];
						for (const concreteDirection of directionaggregates[ambiguous_dir])
						{
							var newrule = deepCloneRule(cur_rule);

							// also clone the movingReplacements of the rule
							newrule.movingReplacement = (cur_rule.movingReplacement === undefined) ? [] : cur_rule.movingReplacement.map( x => Array.from(x) );

							concretizeMovingInCell(newrule.lhs[j][k], ambiguous_dir, identifier_index, concreteDirection);
							if (newrule.rhs.length > 0) // desambiguate a directionaggregate in the RHS if it also appears on the same identifier in the same LHS cell.
							{
								// note that there is no guaranty that the same [ambiguous_dir, identifier] appears in the same cell of the RHS...
								concretizeMovingInCell(newrule.rhs[j][k], ambiguous_dir, identifier_index, concreteDirection);//do for the corresponding rhs cell as well
							}
							
							if (newrule.movingReplacement[identifier_index] === undefined)
							{
								newrule.movingReplacement[identifier_index] = [concreteDirection, 1, ambiguous_dir];
							}
							else
							{
								newrule.movingReplacement[identifier_index][1] += 1; // counts how man different ambiguous_dir are used for this identifier in the rule
							}

							result.push(newrule);
						}
					}
				}
			}
			if (shouldremove)
			{
				result.splice(i, 1);
				i--;
			}
		}
	}

	for (var cur_rule of result)
	{
		//for each rule
		if (cur_rule.movingReplacement === undefined)
			continue;

		var ambiguous_movement_dict = {};
		//strict first - matches movement direction to objects
		//for each property replacement in that rule
		for (const [cand_index, movingDat] of cur_rule.movingReplacement.entries())
		{
			if (movingDat !== undefined)
			{
				const [concreteMovement, occurrenceCount, ambiguousMovement] = movingDat;

				// invalidates an ambiguous movement that appears multiple times in the LHS, whether it's used with different identifiers or multiple occurences of a same identifier.
				ambiguous_movement_dict[ambiguousMovement] = ( (ambiguousMovement in ambiguous_movement_dict) || (occurrenceCount !== 1) ) ? "INVALID" : concreteMovement;

				if (occurrenceCount === 1)
				{
					//do the replacement in the RHS
					// all the direction aggregates of the RHS with this identifier gets disambiguated.
					for (const cellRow_rhs of cur_rule.rhs)
					{
						for (var cell of cellRow_rhs)
						{
							concretizeMovingInCell(cell, ambiguousMovement, cand_index, concreteMovement);
						}
					}
				}
			}
		}
		delete cur_rule.movingReplacement; // not used anymore

		//for each ambiguous word, if there was a single occurence of it in the whole lhs, then replace it also everywhere it appears in the RHS (whatever the identifier)
		for(var ambiguousMovement in ambiguous_movement_dict)
		{
			if (ambiguous_movement_dict.hasOwnProperty(ambiguousMovement) && ambiguousMovement!=="INVALID")
			{
				const concreteMovement = ambiguous_movement_dict[ambiguousMovement];
				if (concreteMovement === "INVALID")
					continue;
				// the direction aggregate has been seen exactly once in the LHS
				for (var cellRow_rhs of cur_rule.rhs)
				{
					for (var cell of cellRow_rhs)
					{
						concretizeMovingInCellByAmbiguousMovementName(cell, ambiguousMovement, concreteMovement);
					}
				}
			}
		}
	}

	// if any direction aggregate remain on the RHSes, bleep loudly
	// TODO: why only log the last one found and not all of them? -> possibly to keep the original wording of the direction, like orthogonal instead of vertical?
	var rhsAmbiguousMovementsRemain = null
	for (const cur_rule of result)
	{
		for (const cur_rulerow of cur_rule.rhs)
		{
			for (const cur_cell of cur_rulerow)
			{
				const movings = getMovings(cur_cell);
				if (movings.length > 0)
				{
					rhsAmbiguousMovementsRemain = movings[0].dir
				}
			}
		}
	}
	if (rhsAmbiguousMovementsRemain !== null)
	{
		logError(['ambiguous_movement', rhsAmbiguousMovementsRemain], lineNumber)
	}

	return result
}

// replaces aggregates and synonyms appearing in a rule by the list of all objects they are aggregates/synonyms of, i.e. objects they must be.
// each new objects has the same motion/action words than the replaced one.
// -> a possible generalization could be to use more qualifier words beyond motion/action words, and then replace the aggregate/synonym by a list, propagating the qualifier to the objects of the list that support them.
function atomizeLegendObjects(identifiers, rule)
{
	atomizeLegendObjectsInHS(identifiers, rule.lhs, rule.lineNumber)
	atomizeLegendObjectsInHS(identifiers, rule.rhs, rule.lineNumber)
}

function atomizeLegendObjectsInHS(identifiers, hs, lineNumber)
{
	for (const cellrow of hs)
	{
		for (const cell of cellrow)
		{
			atomizeLegendObjectsInCell(identifiers, cell, lineNumber);
		}
	}
}

// TODO: do we really need to do that? Because in ruleToMask, we use the objects masks corresponding to an identifier...
// So, I think we only need this so that concretizePropertyRule can deal with properties only.
function atomizeLegendObjectsInCell(identifiers, cell, lineNumber)
{
	for (var i = 0; i < cell.length; i += 1)
	{
		const oc = cell[i]

		if (oc === null)
			continue

		const identifier_comptype = identifiers.comptype[oc.ii]
		if ( (identifier_comptype == identifier_type_property) && ( ! oc.no ) )
			continue // this case requires a rule expansion and will be dealt with in concretizePropertyRule
		if ( (identifier_comptype == identifier_type_aggregate) && oc.no )
		{
			// TODO: this error should be catched in the rule parser?
			logError("You cannot use 'no' to exclude the aggregate object " +identifiers.names[oc.ii].toUpperCase()+" (defined using 'AND'), only regular objects, or properties (objects defined using 'OR').  If you want to do this, you'll have to write it out yourself the long way.", lineNumber)
		}

		const equivs = Array.from( identifiers.getObjectsForIdentifier(oc.ii), p => ({ dir: oc.dir, ii: identifiers.objects[p].identifier_index, no: oc.no, random: oc.random }) )
		cell.splice(i, 1, ...equivs)
		i += equivs.length-1
	}
}




// TODO: the only role of this function is to convert the format for rules used during compilation into a Rule object, which has almost the same structure.
// the function could thus probably be removed if we used Rule objects sooner in the pipeline.
function collapseRules(groups)
{
	for (var rules of groups)
	{
		for (const [i, oldrule] of rules.entries())
		{
			var newrule = [0, [], oldrule.rhs.length>0, oldrule.lineNumber/*ellipses,group number,rigid,commands,randomrule,[cellrowmasks]*/]
			var ellipses = Array(oldrule.lhs.length).fill(false)

			newrule[0] = dirMasks[oldrule.direction]
			newrule[1] = Array.from(oldrule.lhs)
			for (const [j, cellrow_l] of oldrule.lhs.entries())
			{
				for (const cell of cellrow_l)
				{
					if (cell === ellipsisPattern)
					{
						if (ellipses[j])
						{
							logError(['more_than_one_ellipses_in_cellrow'], oldrule.lineNumber)
						} 
						ellipses[j] = true
					}
				}
			}
			newrule.push(ellipses, oldrule.groupNumber, oldrule.rigid, oldrule.commands, oldrule.randomRule, oldrule.parameter_expansion_string)
			rules[i] = new Rule(newrule, oldrule.stringRep)
		}
	}
	matchCache = {}; // clear match cache so we don't slowly leak memory
}

// remove from a group the rules that have a 'discard' field. We could display the error message as soon as ruleToMask, but we want to factorize the same error messages
// created by different expansions of a same original rule. Normally this is done by the console's deletion of repeated messages, but here the example can be different
// for the different expansions.
// See https://github.com/increpare/PuzzleScript/issues/512 and https://github.com/increpare/PuzzleScript/issues/605
function ruleGroupDiscardOverlappingTest(ruleGroup)
{
	var firstLineNumber = ruleGroup[0].lineNumber;
	var allbad = true;
	var example = null;
	for (var i=0; i<ruleGroup.length; i++)
	{
		const rule = ruleGroup[i]
		if (rule.hasOwnProperty('discard'))
		{
			example = rule['discard']
			ruleGroup.splice(i, 1)
			i--
		} else {
			allbad = false;
		}
	}
	if (allbad)
	{
		logError(['overlapping_objects_in_cell', ...example], firstLineNumber)
	}
}

function arrangeRulesByGroupNumberAux(target)
{
	var result = [];
	for (const groupNumber in target)
	{
		if (target.hasOwnProperty(groupNumber))
		{
			var ruleGroup = target[groupNumber];
			ruleGroupDiscardOverlappingTest(ruleGroup);
			if (ruleGroup.length > 0)
			{
				result.push(ruleGroup);
			}
		}
	}
	return result;
}

function arrangeRulesByGroupNumber(state)
{
	var aggregates = {};
	var aggregates_late = {};
	for (const rule of state.rules)
	{
		var targetArray = rule.late ? aggregates_late : aggregates;

		if (targetArray[rule.groupNumber] === undefined)
		{
			targetArray[rule.groupNumber] = []
		}
		targetArray[rule.groupNumber].push(rule);
	}

	const result = arrangeRulesByGroupNumberAux(aggregates);
	const result_late = arrangeRulesByGroupNumberAux(aggregates_late);

	state.rules = result;

	//check that there're no late movements with direction requirements on the lhs
	state.lateRules = result_late;
}

function generateRigidGroupList(state)
{
	var rigidGroupIndex_to_GroupIndex = []
	var groupIndex_to_RigidGroupIndex = []
	var groupNumber_to_GroupIndex = []
	var rigidGroups = []
	for (const [i, ruleset] of state.rules.entries())
	{
		const rigidFound = rigidGroups[i] = ruleset.some( rule => rule.isRigid )
		if ( ! rigidFound )
			continue
		const groupNumber = ruleset[0].groupNumber
		groupNumber_to_GroupIndex[groupNumber] = i
		const rigid_group_index = rigidGroupIndex_to_GroupIndex.length
		groupIndex_to_RigidGroupIndex[i] = rigid_group_index
		ruleset.forEach( rule => rule.makeRigidMask(state.collisionLayers.length, state.STRIDE_MOV, rigid_group_index + 1) ) //don't forget to -1 it when decoding :O
		rigidGroupIndex_to_GroupIndex.push(i)
	}
	if (rigidGroupIndex_to_GroupIndex.length>30)
	{
		logError("There can't be more than 30 rigid groups (rule groups containing rigid members).", rules[0][0][3]);
	}

	state.rigidGroups = rigidGroups;
	state.rigidGroupIndex_to_GroupIndex = rigidGroupIndex_to_GroupIndex;
	state.groupIndex_to_RigidGroupIndex = groupIndex_to_RigidGroupIndex;
}

function generateLoopPointsAux(loops, rules)
{
	var target = 0
	var loopPoint = {}
	var outside = true
	for (const loop of loops)
	{
		const i = rules.findIndex( ruleGroup => (ruleGroup[0].lineNumber >= loop[0]) ) // index of the first ruleGroup after the startloop/endloop instruction
		if (outside)
		{
			target = i
		}
		else if (target >= 0) // there was no rule after the startloop, which can happen for empty loops or loops that contain only late rules
		{
			loopPoint[ ((i<0) ? rules.length : i) - 1] = target
		}
		if (loop[1] === (outside ? -1 : 1) )
		{
			logError(['unbalanced_loop'])
		}
		outside = ! outside
	}
	return loopPoint
}


function generateLoopPoints(state)
{
	if (state.loops.length % 2 === 1)
	{
		logError("have to have matching number of  'startLoop' and 'endLoop' loop points.")
	}
	state.loopPoint = generateLoopPointsAux(state.loops, state.rules)
	state.lateLoopPoint = generateLoopPointsAux(state.loops, state.lateRules)
}


function rectanglify(s)
{
	const w = Math.max(...s.map(l => l.length))
	return s.map( l => l + '.'.repeat(w-l.length) )
}

function spriteMatrixTextLinesToArrays(dat)
{
	return dat.map(
		function(line)
		{
			const row = []
			for (let j = 0; j < line.length; j++)
			{
				const ch = line.charAt(j)
				row.push( (ch == '.') ? -1 : ch )
			}
			return row
		}
	)
}

function compileSprites(state)
{
	function expand(expansion_def, expansion)
	{
		if ( ! Array.isArray(expansion_def) )
			return expansion_def
		const [tag_index, fromset, toset] = expansion_def
		let tag_is_expanded_as = expansion[tag_index]
		if (tag_is_expanded_as === undefined) tag_is_expanded_as = 'right'
		return toset[fromset.indexOf(tag_is_expanded_as)]
	}
	function expand_direction(expansion_def, expansion)
	{
		return absolutedirs.indexOf(expand(expansion_def, expansion))
	}

	for (const [expansion_data, source_type, transforms] of state.sprites_to_compile)
	{
		for (const [object_index, [source_id, expansion]] of expansion_data)
		{
			let object = state.identifiers.objects[object_index]
			let sprite, offset
			switch (source_type)
			{
				case 0: // sprite in code
					sprite = state.sprites_in_code[source_id]
					offset = [0, 0]
					break
				case 1: // copy from object
					const source_object = state.identifiers.objects[source_id]
					sprite = Array.from( source_object.spritematrix )
					offset = Array.from( source_object.sprite_offset )
					break
			}
			for (const parts of transforms)
			{
				let f = (m) => m // default to identity function
				switch (parts[0])
				{
					case '|':
						{
							f = ( m => m.map( l => l.split('').reverse().join('') ) )
							sprite = rectanglify(sprite)
							break
						}
					case '-':
						{
							f = ( m => Array.from(m).reverse() )
							break
						}
					case 'shift':
						{
							if (sprite.length === 0)
								continue
							const shift_direction = expand_direction(parts[1], expansion)
							const sprite_size = shift_direction % 2 ? sprite[0].length : sprite.length
							const delta = (parts.length < 3
								? 1
								: parseInt(expand(parts[2], expansion)) % sprite_size)
							f = ([
									(m => [ ...Array.from(m.slice(delta)), ...Array.from(m.slice(0, delta)) ]), // up
									(m => Array.from(m, l => l.slice(-delta) + l.slice(0, -delta))), // right
									(m => [ ...Array.from(m.slice(-delta)), ...Array.from(m.slice(0, -delta)) ]), // down
									(m => Array.from(m, l => l.slice(delta) + l.slice(0, delta))) // left
								])[shift_direction]
							sprite = rectanglify(sprite)
						}
						break
					case 'rot':
						{
							if (sprite.length === 0)
								continue
							const ref_direction = expand_direction(parts[1], expansion)
							const to_direction = expand_direction(parts[2], expansion)
							const angle = (4 + to_direction - ref_direction) % 4 // clockwise
							f = ([
									( m => Array.from(m) ), // 0°
									( m => Array.from(m[0], (ch,col) => m.map( row => row[col] ).reverse().join('')) ), // 90°
									( m => Array.from(m, l => l.split('').reverse().join('') ).reverse() ), // 180°
									( m => Array.from(m[0], (ch,col) => m.map( row => row[col] ).join('')).reverse() ) // 270°
								])[angle]
							sprite = rectanglify(sprite)
						}
						break
					case 'translate':
						{
							const translate_direction = expand_direction(parts[1], expansion)
							const amount = parseInt(expand(parts[2], expansion))
							const v = ([
									[ 0,-1], // up
									[ 1, 0], // right
									[ 0, 1], // down
									[-1, 0] // left
								])[translate_direction]
							offset[0] += v[0]*amount
							offset[1] += v[1]*amount
						}
						break
					default:
				}
				sprite = f(sprite)
			}
			object.spritematrix = sprite
			object.sprite_offset = offset
		}
	}

//	Compile sprites for all objects
	for (const o of state.identifiers.objects)
	{
		if (o.colors.length == 0)
		{
			// TODO: since this can generate errors that could be highlighted, it should be done in the parser
			// TODO: We may want to silently use transparency in that case, considering how frequent it is to use transparent markers in PuzzleScript...
			logError(['no_palette_in_object', o.name], state.identifiers.lineNumbers[o.identifier_index])
			o.colors = ['#ff00ffff']
		}
		if (o.spritematrix.length === 0)
		{
			o.spritematrix = Array.from( {length: sprite_height}, () => (new Array(sprite_width).fill(0)) )
		}
		else
		{
			o.spritematrix = spriteMatrixTextLinesToArrays(o.spritematrix)
		}
	}
}


'use strict';

/* TODO REFACTORING
- idDict is likely not needed, unless the fact it's sorted by layers is important.
   -> it is used in debug.js where it is not important because the identifiers are then sorted by name)
      That appart, it is only used in engine_base.js/getLayersOfMask where it is used to get the object matching a given bit in the mask returned by Level.getCell,
      which is the same use as in debug.js. Indeed, level cells are created in levelFromString here, using the order of bits defined in glyphDict.
      -> for now, changed to contain identifier_indexes rather than names.
- state.glyphDict -> also, why do we have that thing contain a different kind of mask than bitvec?
                     also, we want the bits in these masks to be in the order of objects in state.objects rather than in the order of idDict?
*/


function generateExtraMembers(state)
{

	if (state.collisionLayers.length === 0)
	{
		logError(['no_collision_layers'])
	}

	// compute layer groups
	for (const [group_index, layer_group] of state.collision_layer_groups.entries())
	{
		layer_group.last_layer =
			(group_index+1 == state.collision_layer_groups.length)
			? state.collisionLayers.length - 1
			: state.collision_layer_groups[group_index+1].first_layer - 1
	}
	state.collision_layer_groups = state.collision_layer_groups.filter( g => g.last_layer >= g.first_layer )

	//annotate objects with layers
	//assign ids at the same time
	// TODO: This could be done directly in the parser -- ClementSparrow
	state.idDict = []; // TODO: this is a bad name...
	for (const layer_group of state.collision_layer_groups)
	{
		layer_group.first_id = state.idDict.length
		for (let layerIndex = layer_group.first_layer; layerIndex <= layer_group.last_layer; ++layerIndex)
		{
			for (const object_index of state.collisionLayers[layerIndex])
			{
				state.identifiers.objects[object_index].id = state.idDict.length
				state.idDict.push(object_index)
			}
		}
		layer_group.last_id = state.idDict.length - 1
	}

	//set object count
	state.objectCount = state.idDict.length;

	//calculate blank mask template
	const layerCount = state.collisionLayers.length;
	var blankMask = Array(layerCount).fill(-1)

	// how many words do our bitvecs need to hold?
	STRIDE_OBJ = Math.ceil(state.objectCount/32)|0;
	STRIDE_MOV = Math.ceil(layerCount/5)|0;
	state.STRIDE_OBJ=STRIDE_OBJ;
	state.STRIDE_MOV=STRIDE_MOV;

	throttle_movement = ('throttle_movement' in state.metadata)
	if ( ('debug' in state.metadata) || verbose_logging )
	{
		cache_console_messages = true;
	}

	//calculate glyph dictionary
	state.glyphDict = state.identifiers.names.map(
		function(identifier, identifier_index)
		{
			if ( ! [identifier_type_object, identifier_type_property, identifier_type_aggregate].includes(state.identifiers.comptype[identifier_index]) )
				return null;
			var mask = blankMask.concat([]);
			for (const object_pos of state.identifiers.getObjectsForIdentifier(identifier_index))
			{
				const o = state.identifiers.objects[object_pos];
				mask[o.layer] = o.id;
			}
			return mask;
		}
	);

	/* determine which properties specify objects all on one layer */
	state.single_layer_property = state.identifiers.comptype.map(
		function (comptype, i)
		{
			if (comptype !== identifier_type_property)
				return -1
			const layers = new Set( Array.from( state.identifiers.getObjectsForIdentifier(i), j => state.identifiers.objects[j].layer ) )
			return (layers.size === 1) ? layers.values().next().value : -1
		}
	);

	if ( (state.idDict[0] === undefined) && (state.collisionLayers.length > 0))
	{
		logError(['no_object'])
	}

	//set default background object
	const background_identifier_index = state.identifiers.names.indexOf('background');
	if (background_identifier_index < 0)
	{
		logError(['no_background'])
		state.background_index = state.idDict[0];
	}
	else if ( ! [identifier_type_object, identifier_type_property].includes(state.identifiers.comptype[background_identifier_index]) )
	{
		logError(['background_is_aggregate'])
		state.background_index = state.idDict[0];
	}
	else
	{
		state.background_index = state.identifiers.getObjectFromIdentifier(background_identifier_index);
	}
	if (state.background_index !== undefined)
	{
		state.backgroundid = state.identifiers.objects[state.background_index].id
		state.backgroundlayer = state.identifiers.objects[state.background_index].layer
	}
}


Level.prototype.calcBackgroundMask = function(state)
{
	var backgroundMask = state.layerMasks[state.backgroundlayer];
	for (var i=0; i<this.n_tiles; i++)
	{
		var cell=this.getCell(i);
		cell.iand(backgroundMask);
		if (!cell.iszero())
			return cell;
	}
	cell = new BitVec(STRIDE_OBJ);
	cell.ibitset(state.backgroundid);
	return cell;
}




function makeMaskFromGlyph(glyph)
{
	var glyphmask = new BitVec(STRIDE_OBJ);
	for (const id of glyph)
	{
		if (id >= 0)
		{
			glyphmask.ibitset(id);
		}			
	}
	return glyphmask;
}

function levelFromString(state, lvl)
{
	const backgroundLayerMask = state.layerMasks[state.backgroundlayer]
	let level = new Level(lvl.width, lvl.grid.length, new Int32Array(lvl.width * lvl.grid.length * STRIDE_OBJ))
	level.lineNumber = lvl.lineNumber // only used in the editor to load the level clicked in the level editor.
	execution_context.resetCommands()
	for (let i = 0; i < level.width; i++)
	{
		for (let j = 0; j < level.height; j++)
		{
			let ch = lvl.grid[j].charAt(i);
			if (ch.length == 0) // TODO: why is it possible to have that from the parser?
			{
				ch = lvl.grid[j].charAt(lvl.grid[j].length-1);
			}

			// TODO: this should be done in the parser
			const identifier_index = state.identifiers.checkIdentifierIsKnownWithType(ch, [identifier_type_object, identifier_type_aggregate], false,
				{
					logError: function(err_args)
					{
						logError( (err_args[2] == identifier_type_property) ? ['property_symbol_in_level', err_args[1]] : ['wrong_symbol_type_in_level', err_args[1], err_args[2]], level.lineNumber+j)
					}
				})

			if (identifier_index < 0)
			{
				if (identifier_index == -2)
				{
					logError(['unknown_symbol_in_level', ch], level.lineNumber+j)
				}
				continue
			}

			const maskint = makeMaskFromGlyph( state.glyphDict[identifier_index].concat([]) );
			for (let w = 0; w < STRIDE_OBJ; ++w)
			{
				level.objects[STRIDE_OBJ * (i * level.height + j) + w] = maskint.data[w];
			}
		}
	}

	const levelBackgroundMask = level.calcBackgroundMask(state)
	for (let i=0; i<level.n_tiles; i++)
	{
		let cell = level.getCell(i);
		if ( ! backgroundLayerMask.anyBitsInCommon(cell) )
		{
			cell.ior(levelBackgroundMask);
			level.setCell(i, cell);
		}
	}
	return level
}

//also assigns glyphDict
function levelsToArray(state)
{
	if ( (state.levels.length === 1) && (state.levels[0].grid.length === 0) )
	{	
		logError(['no_level_found'], undefined, true)
	}

	for (const [level_index, level] of state.levels.entries())
	{
		for (const message_box of level.boxes)
		{
			for (let message of message_box)
			{
				message.text = (message.text.length > 0) ? wordwrapAndColor(message.text, state.fgcolor) : []
				if (message.text.length >= terminal_height)
				{
					logWarning('Message too long to fit on screen.', message.lineNumber)
				}
			}
		}
		level.boxes.splice(2, 0, [])

		if ( ! level.hasOwnProperty('title') )
		{
			level.title = ''
		}

		const generation_cond = state.metadata.auto_level_titles
		let generate_title = (level.title.length > 0) || (generation_cond == 'always')

		level.is_named = (level.name !== undefined)
		if (level.is_named)
		{
			generate_title ||= (generation_cond == 'named')
		}
		else
		{
			level.name = 'Level ' + (level_index+1)
		}

		generate_title &&= (level.title_style != 'none')
		if (generate_title)
		{
			level.boxes[1].unshift({
				text: (level.title.length > 0)
					? (level.title_style == 'header' ? wordwrapAndColor(level.name, state.titlecolor) : []).concat(wordwrapAndColor(level.title, state.authorcolor))
					: wordwrapAndColor(level.name, level.title_style == 'header' ? state.titlecolor : state.authorcolor),
			})
		}

		level.grid = levelFromString(state, level)
	}
}

var dirMasks = {
	'up'	: parseInt('00001', 2),
	'down'	: parseInt('00010', 2),
	'left'	: parseInt('00100', 2),
	'right'	: parseInt('01000', 2),
	'moving': parseInt('01111', 2),
	'no'	: parseInt('00011', 2),
	'randomdir': parseInt('00101', 2),
	'random' : parseInt('10010',2),
	'action' : parseInt('10000', 2),
	'' : parseInt('00000',2)
};

function setPostMovement(dir, layerIndex, postMovementsLayerMask_r, movementsClear, randomDirMask_r, movementsSet)
{
	if (dir.length > 0)
	{
		postMovementsLayerMask_r.ishiftor(0x1f, 5*layerIndex);
	}

	if (dir === 'stationary')
	{
		movementsClear.ishiftor(0x1f, 5*layerIndex)
	}
	else if (dir === 'randomdir')
	{
		if (randomDirMask_r.indexOf(layerIndex) < 0)
			randomDirMask_r.push(layerIndex)
	}
	else
	{						
		movementsSet.ishiftor(dirMasks[dir], 5 * layerIndex);
	}
}


function ruleToMask(state, rule, layerTemplate, layerCount)
{
	for (var j = 0; j < rule.lhs.length; j++)
	{
		var cellrow_l = rule.lhs[j];
		var cellrow_r = rule.rhs[j];

		for (const [k, cell_l] of cellrow_l.entries())
		{

			// Left-Hand Side
			// ==============

			var layersUsed_l = Array.from(layerTemplate);
			var objectsPresent = new BitVec(STRIDE_OBJ);
			var objectsMissing = new BitVec(STRIDE_OBJ); // the objects that must not be in the cell ('no' keyword)
			var anyObjectsPresent = [];
			var movementsPresent = new BitVec(STRIDE_MOV);
			var movementsMissing = new BitVec(STRIDE_MOV);

			var objectlayers_l = new BitVec(STRIDE_MOV);

			for (const oc of cell_l)
			{
				if (oc === null)
				{
					objectsPresent = ellipsisPattern;
					if (rule.rhs.length > 0)
					{
						var rhscell = cellrow_r[k];
						if (rhscell.length !==1 || rhscell[0] !== null)
						{
							// TODO: this should be catched earlier in the compilation pipeline
							logError(['no_matching_ellipsis_in_RHS'], rule.lineNumber)
						}
					} 
					break
				}

				// the identifier may be a property on a single collision layer, in which case object_index should not be unique
				const object = (state.identifiers.object_set[oc.ii].size > 1) ? null : state.identifiers.objects[state.identifiers.object_set[oc.ii].values().next().value];

				const objectMask = state.objectMasks[oc.ii]; // only defined for objects and properties, one bit set for each object it can be
				const layerIndex = (object !== null) ? object.layer : state.single_layer_property[oc.ii];

				if (oc.no)
				{
					objectsMissing.ior(objectMask);
				}
				else if ((layerIndex === undefined) || (layerIndex < 0))
				{
					logError(['no_layer_for_object', state.identifiers.names[oc.ii]], rule.lineNumber)
				}
				else
				{
					if (layersUsed_l[layerIndex] !== null)
					{
						// TODO: don't use identifier names in rule.discard, just identifier_indexes
						rule.discard = [state.identifiers.names[oc.ii].toUpperCase(), state.identifiers.names[layersUsed_l[layerIndex]].toUpperCase()];
						// Note: this does not log an error or warning message, unlike the same test in the RHS. Indeed, it's strange that the user did that, but
						// it's not a problem for matching cells. It is a problem, however, if both identifiers matched by the same object are used differently in the RHS,
						// e.g. [ PlayerOrCrate Player ] -> [ right PlayerOrCrate left Player ]
						// or if the movements on both objects are incompatible, like in:
						// [ left PlayerOrCrate right Player ] -> [ stationary PlayerOrCrate stationary Player ]
						// (although in that case, the rule could be expanded as:
						//     [ left Player right Player ] -> [ stationary Player stationary Player ] that will never match
						//     + [ left Crate right Player ] -> [ stationary Crate stationary Player ] that is valid if Player and Crate are in different collision layers
						// and indeed, it compiles fine, producing only the second rule.
						// )
					}

					layersUsed_l[layerIndex] = oc.ii;

					if (object)
					{
						objectsPresent.ior(objectMask);
						objectlayers_l.ishiftor(0x1f, 5*layerIndex);
					}
					else
					{
						anyObjectsPresent.push(objectMask);
					}

					if (oc.dir === 'stationary')
					{
						movementsMissing.ishiftor(0x1f, 5*layerIndex);
					}
					else
					{
						movementsPresent.ishiftor(dirMasks[oc.dir], 5 * layerIndex);
					}
				}
			}

			if ( (rule.rhs.length > 0) && (cellrow_r[k][0] === null) && (cell_l[0] !== null) )
			{
				logError(['no_matching_ellipsis_in_LHS'], rule.lineNumber)
			}

			if (objectsPresent === ellipsisPattern)
			{
				cellrow_l[k] = ellipsisPattern
				continue
			}
			cellrow_l[k] = new CellPattern([objectsPresent, objectsMissing, anyObjectsPresent, movementsPresent, movementsMissing])

			// if X no X, the rule cannot match anything
			if (objectsPresent.anyBitsInCommon(objectsMissing))
			{
				logWarning(['rule_cannot_match_anything'], rule.lineNumber)
			}

			// Right-Hand Side
			// ===============

			if (rule.rhs.length === 0)
				continue

			var cell_r = cellrow_r[k];
			var layersUsed_r = layerTemplate.concat([]);
			var layersUsedRand_r = layerTemplate.concat([]);

			var objectsClear = new BitVec(STRIDE_OBJ);
			var objectsSet = new BitVec(STRIDE_OBJ);
			var movementsClear = new BitVec(STRIDE_MOV);
			var movementsSet = new BitVec(STRIDE_MOV);

			var objectlayers_r = new BitVec(STRIDE_MOV);
			var randomMask_r = new BitVec(STRIDE_OBJ);
			var postMovementsLayerMask_r = new BitVec(STRIDE_MOV); // set for the bits of layers such that a) an object in that layer appears in the (RHS) cell and has a movement direction or action (movement is set), b) an object in that layer appeared on the same cell in the LHS but no object in that layer appears in the (RHS) cell (objects deleted)
			var randomDirMask_r = []
			for (const oc of cell_r)
			{
				// the identifier may be a property on a single collision layer, in which case object_index should not be unique
				const object = state.identifiers.getObjectsForIdentifier(oc.ii).size > 1 ? null : state.identifiers.objects[state.identifiers.getObjectsForIdentifier(oc.ii).values().next().value];

				if (oc.random)
				{
					if (state.identifiers.comptype[oc.ii] === identifier_type_aggregate)
					{
						// TODO: this error should be catched earlier in the parsing piepline
						logError(['spawn_aggregate', state.identifiers.names[oc.ii]], rule.lineNumber)
						continue
					}
					randomMask_r.ior(state.objectMasks[oc.ii]);
					const values = Array.from( state.identifiers.getObjectsForIdentifier(oc.ii), p => [p, state.identifiers.objects[p]] );
					for (const [subobject_index, subobject] of values)
					{
						// TODO: it would be simpler to precompute a layer mask for each identifier, then compare this mask with objectsSet?
						// plus, this would ease the implementation of multi-layer objects if we want to go that way.
						const subobj_layerIndex = subobject.layer|0
						const existing_index = layersUsed_r[subobj_layerIndex];
						if ( (existing_index !== null) && (subobject_index !== existing_index) )
						{
							logWarning("This rule may try to spawn a "+subobject.name.toUpperCase()+" with random, but also requires a "+state.identifiers.objects[existing_index].name.toUpperCase()+" be here, which is on the same layer - they shouldn't be able to coexist!", rule.lineNumber); 									
						}

						// TODO: shouldn't we also test that layersUsedRand_r is not already set?
						layersUsedRand_r[subobj_layerIndex] = subobject.identifier_index;
						setPostMovement(oc.dir, subobj_layerIndex, postMovementsLayerMask_r, movementsClear, randomDirMask_r, movementsSet)
					}
					continue
				}

				const objectMask = state.objectMasks[oc.ii];
				const layerIndex = (object !== null) ? object.layer : state.single_layer_property[oc.ii];
				
				if (oc.no)
				{
					objectsClear.ior(objectMask);
				}
				else if ( (layerIndex === undefined) || (layerIndex < 0) )
				{
					logError(['no_layer_for_object', state.identifiers.names[oc.ii]], rule.lineNumber)
				}
				else
				{
					const existing_index = layersUsed_r[layerIndex] || layersUsedRand_r[layerIndex]

					// "discard" here indicates there is already a problem on the LHS. Is it used just to not show an error message when we know there will already be one for that rule?
					// so, here, it just prevents write/write conflicts?
					if ( (existing_index !== null) && ( ! rule.hasOwnProperty('discard') ) )
					{
						logError(['cant_overlap', state.identifiers.names[oc.ii], state.identifiers.names[existing_index]], rule.lineNumber)
					}

					layersUsed_r[layerIndex] = oc.ii;

					if (object)
					{
						objectsSet.ibitset(object.id);
						objectsClear.ior(state.layerMasks[layerIndex]); // TODO: shouldn't we clear them ONLY if they do not also appear on the LHS?
						objectlayers_r.ishiftor(0x1f, 5*layerIndex);
						// TODO: add movementsClear.ior(state.layerMasks[layerIndex]) ?
					}
					else
					{
						// shouldn't need to do anything here...
						// TODO: add movementsClear.ior(state.layerMasks[layerIndex]) ?
					}

					setPostMovement(oc.dir, layerIndex, postMovementsLayerMask_r, movementsClear, randomDirMask_r, movementsSet)
				}
			}


			// Differences between both sides
			// ==============================

			// The fix in increpare/PuzzleScript@e4d09233cd7abcb80fc9f320b5e35568dd248247 consists in setting as 'stationary' all objects (not properties) appearing in
			// the RHS without movement (including 'no' and 'random' and 'randomdir') and not appearing in the same cell of the LHS (including as a member of a single-layer property).
			//
			// But I think it should be changed into: setting as 'stationary' all objects (not properties) appearing in the RHS without movement (including 'no' and 'random'
			// and 'randomdir') and not appearing in the same cell of the LHS (excluding appearance as a member of a single-layer property) (or, then, appearing with a direction?).
			//
			// 'setting as stationary' => movementsClear.ishiftor(0x1f, 5*layerIndex)
			// 'appearing in the RHS as object' => objectlayers_r.ishiftor(0x1f, 5*layerIndex) or object bit set in objectsSet
			// 'without movement' => postMovementsLayerMask_r.ishiftor(0x1f, 5*layerIndex) is not set.
			// 'not appearing in the same cell of the LHS' => the bit for the object has not been set in objectsPresent or objectlayers_l.ishiftor(0x1f, 5*layerIndex) not set.
			//
			// TODO: it should not be necessary to clear the movement if there is only one type of object in the collision layer of the object created, or the other possible
			// object types in that layers have been 'no'-ed in the LHS.

			if ( ! rule.late )
			{
				var objectsPossiblyCreatedStationary = objectlayers_r.clone()
				objectsPossiblyCreatedStationary.iclear(objectlayers_l)
				objectsPossiblyCreatedStationary.iclear(postMovementsLayerMask_r)
				movementsClear.ior(objectsPossiblyCreatedStationary)
			}

			// TODO: shouldn't we only clear the objects (or rather, their layer masks) that are not present on the RHS? Something like objectsClear.ior(objectsPresent.clear(objectsSet))
			if ( ! objectsPresent.bitsSetInArray(objectsSet.data) ) // if there are individual objects on the LHS that are not on the RHS
			{
				objectsClear.ior(objectsPresent) // destroy them
			}
			if ( ! movementsPresent.bitsSetInArray(movementsSet.data) )
			{
				movementsClear.ior(movementsPresent); // ... and movements
			}

			for (var l = 0; l < layerCount; l++) // TODO: isn't this doing the same thing than that other line below? -> no, the difference is that the other line works only for atomic objects but this loop also works for single-layer properties.
			{
				if (layersUsed_l[l] !== null && layersUsed_r[l] === null)
				{
					// a layer matched on the lhs, but not on the rhs
					objectsClear.ior(state.layerMasks[l]);
					postMovementsLayerMask_r.ishiftor(0x1f, 5*l);
				}
			}

			objectlayers_l.iclear(objectlayers_r);
			postMovementsLayerMask_r.ior(objectlayers_l); // TODO: that other line.

			if (objectsClear || objectsSet || movementsClear || movementsSet || postMovementsLayerMask_r)
			{
				// only set a replacement if something would change
				cellrow_l[k].replacement = new CellReplacement([objectsClear, objectsSet, movementsClear, movementsSet, postMovementsLayerMask_r, randomMask_r, randomDirMask_r])
			}
		}
	}
}

function rulesToMask(state)
{
	const layerCount = state.collisionLayers.length;
	const layerTemplate = Array(layerCount).fill(null);

	for (const rule of state.rules)
	{
		ruleToMask(state, rule, layerTemplate, layerCount)
	}
}


function makeMaskFromObjectSet(identifiers, objects)
{
	return makeMaskFromGlyph( Array.from( objects, object_pos => identifiers.objects[object_pos].id ) );
}


/* Computes new attributes for the state: playerMask, layerMasks, objectMask. */
function generateMasks(state)
{
	const player_identifier_index = state.identifiers.names.indexOf('player');
	if (player_identifier_index < 0)
	{
		logError(['no_player_defined'])
		state.playerMask = new BitVec(STRIDE_OBJ);
	}
	else
	{
		state.playerMask = makeMaskFromObjectSet(state.identifiers, state.identifiers.getObjectsForIdentifier(player_identifier_index));
	}

	state.layerMasks = state.collisionLayers.map( layer => makeMaskFromObjectSet(state.identifiers, layer) )

//	Compute state.objectMasks

	var objectMask = state.identifiers.comptype.map(
		(type, identifier_index) => ([identifier_type_object, identifier_type_property].includes(type)) ? makeMaskFromObjectSet(state.identifiers, state.identifiers.getObjectsForIdentifier(identifier_index)) : null
	);

	var all_obj = new BitVec(STRIDE_OBJ);
	all_obj.inot();
	objectMask.all = all_obj;

	state.objectMasks = objectMask;
}

function twiddleMetaData(state)
{
	let newmetadata = {}
	state.metadata_keys.forEach( function(key, i) { newmetadata[key] = state.metadata_values[i] } )

	if (newmetadata.flickscreen !== undefined)
	{
		const coords = newmetadata.flickscreen.split('x')
		newmetadata.flickscreen = [parseInt(coords[0]), parseInt(coords[1])]
	}
	if (newmetadata.zoomscreen !== undefined)
	{
		const coords = newmetadata.zoomscreen.split('x')
		newmetadata.zoomscreen = [parseInt(coords[0]), parseInt(coords[1])]
	}
	;[ sprite_width, sprite_height ] = newmetadata['sprite_size']

	state.metadata = newmetadata


	// get color palette from its name
	state.game_palette = colorPalettes[state.metadata.color_palette]

	const color_metadata = [
		[ 'background_color', 'bgcolor', '#000000FF' ],
		[ 'text_color', 'fgcolor', '#FFFFFFFF'],
		[ 'title_color', 'titlecolor', undefined],
		[ 'author_color', 'authorcolor', undefined],
		[ 'keyhint_color', 'keyhintcolor', undefined],
	]
	for (const [metadata_key, state_key, default_color] of color_metadata)
	{
		const color = (metadata_key in state.metadata) ? colorToHex(state.game_palette, state.metadata[metadata_key]) : (default_color || state.fgcolor)
		if ( isColor(color) )
		{
			state[state_key] = color
		}
		else
		{
			const final_color = (default_color || state.fgcolor)
			logError(metadata_key + ' in incorrect format - found '+color+", but I expect a color name (like 'pink') or hex-formatted color (like '#1412FA').  Defaulting to "+final_color+'.')
			state[state_key] = final_color
		}
	}
}


function tokenizeWinConditionIdentifier(state, n, lineNumber)
{
	const identifier_index = state.identifiers.checkKnownIdentifier(n, false, state);
	if (identifier_index < 0)
	{
		logError(['unknown_object_in_wincondition', n], lineNumber)
		return null
	}
	const identifier_comptype = state.identifiers.comptype[identifier_index];
	if ( (identifier_comptype != identifier_type_property) && (identifier_comptype != identifier_type_object) ) // not a property, not an object
	{
		logError(['invalid_object_in_wincondition', n, identifier_type_as_text[identifier_comptype]], lineNumber)
		return null
	}
	return state.objectMasks[identifier_index];
}

function processWinConditions(state)
{
//	[-1/0/1 (no,some,all),ob1,ob2] (ob2 is background by default)
	var newconditions = []; 
	for (const wincondition of state.winconditions)
	{
		if (wincondition.length == 0)
			return;

		const num = ({some:0, any:0, no:-1, all:1})[wincondition[0]]; // TODO: this tokenisation should be done in the parser, not here.

		const lineNumber = wincondition[wincondition.length-1];

		const mask1 = tokenizeWinConditionIdentifier( state, wincondition[1], lineNumber)
		const mask2 = (wincondition.length == 5) ? tokenizeWinConditionIdentifier( state, wincondition[3], lineNumber) : state.objectMasks.all;

		newconditions.push( [num, mask1, mask2, lineNumber] );
	}
	state.winconditions = newconditions;
}

function removeDuplicateRules(state)
{
	var record = {};
	var newrules = [];
	var lastgroupnumber = -1;
	for (var i=state.rules.length-1; i>=0; i--)
	{
		var r = state.rules[i];
		var groupnumber = r.groupNumber;
		if (groupnumber !== lastgroupnumber)
		{
			record = {};
		}
		var r_string = r.stringRep;
		if (record.hasOwnProperty(r_string))
		{
			state.rules.splice(i,1);
		} else {
			record[r_string] = true;
		}
		lastgroupnumber=groupnumber;
	}
}




//	======= SOUNDS =======

var soundEvents = ["titlescreen", 'gamescreen', 'pausescreen', "startgame", "cancel", "endgame", "startlevel","undo","restart","endlevel","showmessage","closemessage","sfx0","sfx1","sfx2","sfx3","sfx4","sfx5","sfx6","sfx7","sfx8","sfx9","sfx10"];
var soundMaskedEvents =["create","destroy","move","cantmove","action"];
var soundVerbs = soundEvents.concat(soundMaskedEvents);


function validSeed(seed, lineNumber)
{
	const match = /^\s*\d+(?::(\d\d?))?\s*$/.exec(seed)
	if (match === null)
	{
		logError(['bad_seed', seed], lineNumber)
		return false
	}
	if (match[1])
	{
		const volume = parseInt(match[1])
		if (volume == 0)
		{
			logError(['null_seed', seed], lineNumber)
			return false
		}
		if (volume > MAX_SOUND_VOL)
		{
			logError(['too_loud', seed, MAX_SOUND_VOL], lineNumber)
			return false
		}
	}
	return true
}


var soundDirectionIndicatorMasks = {
	'up'			: parseInt('00001', 2),
	'down'			: parseInt('00010', 2),
	'left'			: parseInt('00100', 2),
	'right'			: parseInt('01000', 2),
	'horizontal'	: parseInt('01100', 2),
	'vertical'		: parseInt('00011', 2),
	'orthogonal'	: parseInt('01111', 2),
	'___action____'		: parseInt('10000', 2)
};

var soundDirectionIndicators = ["up","down","left","right","horizontal","vertical","orthogonal","___action____"];


function generateSoundData(state)
{
	var sfx_Events = {};
	var sfx_CreationMasks = [];
	var sfx_DestructionMasks = [];
	var sfx_MovementMasks = Array.from(state.collisionLayers, cl => [])
	var sfx_MovementFailureMasks = Array.from(state.collisionLayers, cl => [])

	for (var sound of state.sounds)
	{
		if (sound.length <= 1)
			continue;

		var lineNumber = sound[sound.length-1];

		if (sound.length === 2)
		{
			logError(['incorrect_sound_declaration'], lineNumber)
			continue;
		}

		if (soundEvents.indexOf(sound[0]) >= 0)
		{
			if (sound.length > 4)
			{
				logError("too much stuff to define a sound event.", lineNumber);
			}
			var seed = sound[1];
			if (validSeed(seed, lineNumber))
			{
				const sound_names = (sound[0] === 'titlescreen') ? [ 'gamescreen', 'pausescreen' ] : [ sound[0] ]
				for (const sound_name of sound_names)
				{
					if (sfx_Events[sound_name] !== undefined) {
						logWarning(sound_name.toUpperCase()+" already declared.", lineNumber);
					} 
					sfx_Events[sound_name] = sound[1]
				}
			}
		}
		else
		{
			var target = sound[0].trim();
			var verb = sound[1].trim();
			var directions = sound.slice(2, sound.length-2);
			if (directions.length > 0 && (verb !== 'move' && verb !== 'cantmove'))
			{
				logError(['incorrect_sound_declaration'], lineNumber)
			}

			if (verb === 'action')
			{
				verb = 'move';
				directions = ['___action____'];
			}

			if (directions.length == 0)
			{
				directions = ["orthogonal"];
			}
			var seed = sound[sound.length-2];

			const target_index = state.identifiers.checkKnownIdentifier(target, false, state);
			if (target_index<0)
			{
				// TODO: we have already checked in the parser that it is a known identifier, but we added the sound anyway.
				logError('Object "'+ target+'" not found.', lineNumber);
				continue;
			}
			if (state.identifiers.comptype[target_index] == identifier_type_aggregate)
			{
				logError('cannot assign sound events to aggregate objects (declared with "and"), only to regular objects, or properties, things defined in terms of "or" ("'+target+'").', lineNumber);
				continue;
			}
			if ( [identifier_type_tag, identifier_type_tagset].includes(state.identifiers.comptype[target_index]) )
			{
				logError('cannot assign sound events to tags, only to regular objects, or properties, things defined in terms of "or" ("'+target+'").', lineNumber);
				continue;
			}

			var objectMask = state.objectMasks[target_index];

			var directionMask = 0;
			for (var j=0; j<directions.length; j++)
			{
				directions[j] = directions[j].trim();
				var direction = directions[j];
				if (soundDirectionIndicators.indexOf(direction) === -1) {
					logError('Was expecting a direction, instead found "'+direction+'".', lineNumber);
				} else {
					var soundDirectionMask = soundDirectionIndicatorMasks[direction];
					directionMask |= soundDirectionMask;
				}
			}

			if (verb === 'move' || verb === 'cantmove')
			{
				for (const [layer, array] of (verb === 'move' ? sfx_MovementMasks : sfx_MovementFailureMasks).entries() )
				{
					var objectsInLayerMask = objectMask.clone()
					objectsInLayerMask.iand(state.layerMasks[layer])
					if ( ! objectsInLayerMask.iszero() )
					{
						array.push({
							objectMask: objectsInLayerMask,
							directionMask: directionMask,
							seed: seed
						})
					}
				}
			}


			if ( ! validSeed(seed, lineNumber) )
			{ }

			switch (verb)
			{
				case "create": {
					sfx_CreationMasks.push({
						objectMask: objectMask,
						seed: seed
					});
					break;
				}
				case "destroy": {
					sfx_DestructionMasks.push({
						objectMask: objectMask,
						seed: seed
					});
					break;
				}
			}
		}
	}

	state.sfx_Events = sfx_Events;
	state.sfx_CreationMasks = sfx_CreationMasks;
	state.sfx_DestructionMasks = sfx_DestructionMasks;
	state.sfx_MovementMasks = sfx_MovementMasks
	state.sfx_MovementFailureMasks = sfx_MovementFailureMasks;
}





//	======= COMPILE =======

function formatHomePage(state)
{
	if (canSetHTMLColors) {
		
		if ('background_color' in state.metadata)  {
			document.body.style.backgroundColor=state.bgcolor;
		}
		
		if ('text_color' in state.metadata) {
			var separator = document.getElementById("separator");
			if (separator!=null) {
			   separator.style.color = state.fgcolor;
			}
			
			var h1Elements = document.getElementsByTagName("a");
			for(var i = 0; i < h1Elements.length; i++) {
			   h1Elements[i].style.color = state.fgcolor;
			}

			var h1Elements = document.getElementsByTagName("h1");
			for(var i = 0; i < h1Elements.length; i++) {
			   h1Elements[i].style.color = state.fgcolor;
			}
		}
	}

	if ('homepage' in state.metadata) {
		var url = state.metadata['homepage'];
		url=url.replace("http://","");
		url=url.replace("https://","");
		state.metadata['homepage']=url;
	}
}

const MAX_ERRORS=5;
function compileTextCode(str)
{

//	Parse the file	
	var state = new PuzzleScriptParser([], [])

	const lines = str.split('\n');
	for (const [i, line] of lines.entries())
	{
	//	Parse the line
		state.lineNumber = i + 1;
		var ss = new CodeMirrorStringStream(line, 4); // note that we use the CodeMirror API to parse the file, here, but we don't have to
		do
		{
			if (line.length > 0)
				state.token(ss)
			else
				state.blankLine()

			if (errorStrings.length > MAX_ERRORS)
			{
				consolePrint("too many errors, aborting compilation");
				return;
			}
		}		
		while (ss.eol() === false);
	}

	delete state.lineNumber;

	twiddleMetaData(state)

	compileSprites(state)

	generateExtraMembers(state);
	generateMasks(state);
	levelsToArray(state);
	rulesToArray(state);

	cacheAllRuleNames(state);

	removeDuplicateRules(state);

	rulesToMask(state);

	arrangeRulesByGroupNumber(state);
	collapseRules(state.rules);
	collapseRules(state.lateRules);

	generateRigidGroupList(state);

	processWinConditions(state);
	// checkObjectsAreLayered(state.identifiers);

	generateLoopPoints(state);

	generateSoundData(state);

	formatHomePage(state);

	delete state.commentLevel;
	// delete state.abbrevNames; // we keep them for the level editor only
	delete state.current_identifier_index;
	delete state.line_type
	delete state.objects_spritematrix;
	delete state.section;
	delete state.tokenIndex;
	// delete state.visitedSections;
	delete state.loops;
	/*
	var lines = stripComments(str);
	window.console.log(lines);
	var sections = generateSections(lines);
	window.console.log(sections);
	var sss = generateSemiStructuredSections(sections);*/
	return state;
}

// This function is misnammed as the compilation is actually done in compileTextCode, called
// by this function, which principal job is to reinitialize the game and editor states.
function compile(level, text, randomseed) // level = null means restart, level = undefined means rebuild
{
	matchCache = {}
	lastDownTarget = screen_layout.canvas

	if (text === undefined)
	{
		text = window.form1.code.editorreference.getValue() + '\n'
	}
	if (canDump === true)
	{
		compiledText = text
	}

	compiling = true
	errorStrings = []
	warningStrings = []
	consolePrint('=================================')
	try
	{
		var state = compileTextCode(text)
	} finally {
		compiling = false
	}

	if (errorStrings.length > MAX_ERRORS)
		return

	if (errorStrings.length > 0)
	{
		consoleError('<span class="systemMessage">Errors detected during compilation; the game may not work correctly.</span>')
	}
	else {
		var ruleCount = 0
		for (const rule of state.rules) {
			ruleCount += rule.length
		}
		for (const rule of state.lateRules) {
			ruleCount += rule.length
		}
		consolePrint('<span class="systemMessage">Successful ' + ((level === undefined) ? 'live re' : '') + 'compilation, generated '+ruleCount+' instructions.</span>')
	}

	setGameState(state, level, randomseed)
	forceRegenImages()

	clearInputHistory()

	consoleCacheDump()
}



function qualifyURL(url)
{
	var a = document.createElement('a');
	a.href = url;
	return a.href;
}


var keyRepeatTimer=0;
var keyRepeatIndex=0;
var input_throttle_timer=0.0;
var lastinput=-100;

var dragging=false;
var rightdragging=false;




// GENERIC EVENT HANDLER
// =====================

var lastDownTarget;

function onMouseDown(event)
{
	if (event.handled)
		return;

	ULBS();
	
	var lmb = event.button===0;
	var rmb = event.button===2 ;
	if (event.type=="touchstart")
	{
		lmb=true;
	}
	if (lmb && (event.ctrlKey||event.metaKey))
	{
		lmb=false;
		rmb=true;
	}
	
	if (lmb)
	{
        lastDownTarget = event.target;
        keybuffer=[];
        if (event.target===screen_layout.canvas || event.target.className==="tapFocusIndicator")
        {
        	if (screen_layout.leftMouseClick(event))
        		return;
        }
        dragging=false;
        rightdragging=false; 
    }
    else if (rmb)
    {
    	if (event.target===screen_layout.canvas || event.target.className==="tapFocusIndicator")
    	{
		    dragging=false;
		    rightdragging=true;
		    if (screen_layout.rightMouseClick(event))
		    	return;
        }
	}
	
	event.handled=true;
}

function rightClickCanvas(event) {
    return prevent(event);
}

function onMouseUp(event) {
	if (event.handled){
		return;
	}

	dragging=false;
	rightdragging=false;
	
	event.handled=true;
}

function onKeyDown(event)
{
	ULBS()

    event = event || window.event

	// Prevent arrows/space from scrolling page
	if ( ( ! IDE ) && ([32, 37, 38, 39, 40]).includes(event.keyCode) )
	{
		if ( event && (event.ctrlKey || event.metaKey) )
		{
		}
		else
		{
			prevent(event)
		}
	}

	if ( ( ! IDE) && (event.keyCode === 77) ) // M
	{
		toggleMute()
	}

    if (keybuffer.includes(event.keyCode))
    	return

    if( (lastDownTarget === screen_layout.canvas) || (window.Mobile && (lastDownTarget === window.Mobile.focusIndicator) ) )
    {
    	if ( ! keybuffer.includes(event.keyCode) )
    	{
    		if ( event && (event.ctrlKey || event.metaKey || event.repeat) )
    		{
		    } else
		    {
    		    keybuffer.splice(keyRepeatIndex, 0, event.keyCode)
	    	    keyRepeatTimer = 0
	    	    checkKey(event, true)
		    }
		}
	}


    if (canDump===true) {
        if (event.keyCode===74 && (event.ctrlKey||event.metaKey)) {//ctrl+j
            dumpTestCase();
            prevent(event);
        } else if (event.keyCode===75 && (event.ctrlKey||event.metaKey)) {//ctrl+k
            makeGIF();
            prevent(event);
        }  else if (event.keyCode===83 && (event.ctrlKey||event.metaKey)) {//ctrl+s
            saveClick();
            prevent(event);
        } else if (event.keyCode===13 && (event.ctrlKey||event.metaKey)){//ctrl+enter
			screen_layout.canvas.focus();
			editor.display.input.blur();
            if (event.shiftKey) {
				runClick()
			} else {
				rebuildClick()
			}
            prevent(event)
		}
	}
}

function onKeyUp(event)
{
	event = event || window.event
	var index = keybuffer.indexOf(event.keyCode)
	if (index >= 0)
	{
		keybuffer.splice(index, 1)
		if (keyRepeatIndex >= index)
		{
			keyRepeatIndex--
		}
    }
}

function onMyFocus(event)
{
	keybuffer = []
	keyRepeatIndex = 0
	keyRepeatTimer = 0
}

function onMyBlur(event)
{
	keybuffer = []
	keyRepeatIndex = 0
	keyRepeatTimer = 0
}

function mouseMove(event)
{	
	if (event.handled)
		return

	screen_layout.mouseMove(event)

	event.handled = true
    //window.console.log("showcoord ("+ canvas.width+","+canvas.height+") ("+x+","+y+")");
}

function mouseOut() {
//  window.console.log("clear");
}

document.addEventListener('touchstart', onMouseDown, false);
document.addEventListener('touchmove', mouseMove, false);
document.addEventListener('touchend', onMouseUp, false);

document.addEventListener('mousedown', onMouseDown, false);
document.addEventListener('mouseup', onMouseUp, false);

document.addEventListener('keydown', onKeyDown, false);
document.addEventListener('keyup', onKeyUp, false);

window.addEventListener('focus', onMyFocus, false);
window.addEventListener('blur', onMyBlur, false);


function prevent(e) {
    if (e.preventDefault) e.preventDefault();
    if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    if (e.stopPropagation) e.stopPropagation();
    e.returnValue=false;
    return false;
}

function checkKey(e, justPressed)
{
	ULBS()
	
    if (winning) {
    	return;
	}
	if (e&&(e.ctrlKey || e.metaKey|| e.altKey)){
		return;
	}
	
    var inputdir=-1;
    switch(e.keyCode)
    {
        case 65://a
        case 37: //left
        {
            inputdir=1;
	        break
        }
        case 38: //up
        case 87: //w
        {
            inputdir=0;
	        break
        }
        case 68://d
        case 39: //right
        {
            inputdir=3;
	        break
        }
        case 83://s
        case 40: //down
        {
            inputdir=2;
	        break
        }
        case 80://p
        {
			level.printToConsole()
        	break
        }
        case 13://enter
        case 32://space
        case 67://c
        case 88://x
        {
			if ( justPressed || (norepeat_action === false) )
			{
				inputdir = 4
				break
            }
			return
        }
		case 27://escape
		{
			if (screen_layout.content instanceof MenuScreen)
			{
				screen_layout.content.closeMenu()
			}
			else
			{
				pause_menu_screen.makePauseMenu()
				pause_menu_screen.openMenu()
			}
			return prevent(e)
			break
		}
        case 69: {//e
        	if (typeof level_editor_screen !== 'undefined') // can open editor
        	{
        		if (justPressed)
        		{
					level_editor_screen.toggle()
        		}
        		return prevent(e);
        	}
            break;
		}
    }
	// prevent repetition of direction keys before the throttle_movement time
    if ( throttle_movement && (inputdir >= 0) && (inputdir <= 3) )
    {
    	if ( (lastinput == inputdir) && (input_throttle_timer < repeatinterval) )
    		return;
		lastinput = inputdir;
		input_throttle_timer = 0;
    }
	if (justPressed && screen_layout.checkKey(e, inputdir))
		return prevent(e);
	if (screen_layout.checkRepeatableKey(e, inputdir))
		return prevent(e);
}

TextModeScreen.prototype.checkKey = function(e, inputdir)
{
	if ( (inputdir != 4) || (state.levels.length === 0) )
		return false

	if (unitTesting)
	{
		nextLevel()
		return
	}

	if (this.done === false)
	{
		timer = 0
		this.done = true
		tryPlaySimpleSound('closemessage')
		this.doMessage(curlevel.getMessage())
		keybuffer = []
	}
	return false
}

MenuScreen.prototype.checkKey = function(e, inputdir)
{
	if ( (inputdir != 4) || this.done || (state.levels.length === 0) )
		return false

	if (this.select_soundname !== undefined)
	{
		tryPlaySimpleSound(this.select_soundname)
	}
	timer = 0
	this.done = true
	this.updateMenuItems()
	keybuffer = []
	if (this.menu_entries.length === 1)
	{
		canvasResize()
	}
	else
	{
		redraw()
	}
	return false
}


MenuScreen.prototype.checkRepeatableKey = function(e, inputdir)
{
	if ( this.done || (state.levels.length === 0) )
		return false

	if ( (inputdir === 0) || (inputdir === 2) )
	{
		this.item = clamp(0, this.item + ((inputdir === 0) ? -1 : 1), this.menu_entries.length - 1)
		this.updateMenuItems()
		redraw()
	}
	return false
}



LevelScreen.prototype.checkKey = function(e, inputdir)
{
	if (e.keyCode === 82) // R
	{
		pushInput('restart')
		DoRestart()
		canvasResize() // calls redraw
		return true;
	}
	return false;
}

LevelScreen.prototype.checkRepeatableKey = function(e, inputdir)
{
	if ( (e.keyCode == 85) || (e.keyCode == 90) ) // U or Z
	{
		//undo
		pushInput('undo')
		execution_context.doUndo()
		canvasResize() // calls redraw
		return true;
	}

	if ( againing || (inputdir < 0) )
		return false;

	if ( (inputdir === 4) && ('noaction' in state.metadata) )
		return true;

	pushInput(inputdir)
	if ( processInput(inputdir) )
	{
		redraw()
	}
	return true;
}

function update(timestamp)
{
	const deltatime = (update.previous_timestamp !== undefined) ? timestamp - update.previous_timestamp : 0
    update.previous_timestamp = timestamp

    timer += deltatime
    input_throttle_timer += deltatime
	if ( (screen_layout.content instanceof MenuScreen) && screen_layout.content.done && (timer/1000>0.3) )
	{
		screen_layout.content.doSelectedFunction()
	}
    if ( againing && (timer > againinterval) && (execution_context.commandQueue.message === null) && processInput(processing_causes.again_frame) )
    {
		redraw()
		keyRepeatTimer = 0
		autotick = 0
    }
    if ( msg_screen.done && (timer/1000 > 0.15) )
    {
    	closeMessageScreen()
    }
    if (winning) {
        if (timer/1000>0.5) {
            winning=false;
            nextLevel();
        }
    }
    if (keybuffer.length > 0)
    {
	    keyRepeatTimer += deltatime
	    var ticklength = throttle_movement ? repeatinterval : repeatinterval/(Math.sqrt(keybuffer.length))
	    if (keyRepeatTimer > ticklength)
		{
			keyRepeatTimer = 0	
			keyRepeatIndex = (keyRepeatIndex+1) % keybuffer.length
			checkKey( { keyCode: keybuffer[keyRepeatIndex] }, false )
		}
	}

    if ( ! ( (autotickinterval <= 0) || screen_layout.noAutoTick() || againing || winning ) )
    {
        autotick += deltatime;
        if (autotick > autotickinterval)
        {
            autotick = 0;
            pushInput("tick");
            if (processInput(processing_causes.autotick))
            {
                redraw();
            }
        }
    }
	update.request = window.requestAnimationFrame(update)
}

function updateUpdate()
{
	if (document.visibilityState == 'visible')
	{
		update.request ||= window.requestAnimationFrame(update)
		return
	}
	update.request = window.cancelAnimationFrame(update.request)
	update.previous_timestamp = undefined
}
document.addEventListener('visibilitychange', updateUpdate)
updateUpdate()

/*
 * Add gesture support for mobile devices.
 */

window.Mobile = {};

//stolen from https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
Mobile.hasTouch = function() {
    var bool;
    if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch)     {
      bool = true;
    } else {
      /*
      //don't know what's happening with this, so commented it out
      var query = ['@media (',prefixes.join('touch-enabled),    ('),'heartz',')','{#modernizr{top:9px;position:absolute}}'].join('');
      testStyles(query, function( node ) {
        bool = node.offsetTop === 9;
      });*/
    }
    return bool;
}

Mobile.enable = function (force) {
    if (force || Mobile.hasTouch() && !Mobile._instance) {
        Mobile._instance = new Mobile.GestureHandler();
        Mobile._instance.bindEvents();
        Mobile._instance.bootstrap();
    }
    return Mobile._instance;
};

window.Mobile.GestureHandler = function () {
    this.initialize.apply(this, arguments);
};

Mobile.log = function (message) {
    var h1;
    h1 = document.getElementsByTagName('h1')[0];
    h1.innerHTML = "" + Math.random().toString().substring(4, 1) + "-" + message;
};

// Mobile.debugDot = function (event)
// {
// 	var dot = document.createElement('div');
// 	dot.setAttribute('style', 'border-radius:50px;width:5px;height:5px;background:red;position:absolute;left:' + event.touches[0].clientX + 'px;top: ' + event.touches[0].clientY + 'px;')
// 	document.getElementsByTagName('body')[0].appendChild(dot);
// }

(function (proto) {
    'use strict';

    // Minimum range to begin looking at the swipe direction, in pixels
    const SWIPE_THRESHOLD = 10;
    // Distance in pixels required to complete a swipe gesture.
    const SWIPE_DISTANCE = 50;
    // Time in milliseconds to complete the gesture.
    const SWIPE_TIMEOUT = 1000;
    // Time in milliseconds to repeat a motion if still holding down,
    // ... and not specified in state.metadata.key_repeat_interval.
    const DEFAULT_REPEAT_INTERVAL = 150;

    // Lookup table mapping action to keyCode.
    var CODE = {
        action:  88, // x
        left:    37, // left arrow
        right:   39, // right arrow
        up:      38, // up arrow
        down:    40, // down arrow
        undo:    85, // u
        restart: 82, // r
        quit:    27 // escape
    }

    const TAB_STRING = [
        '<div class="tab">',
        '  <div class="tab-affordance"></div>',
        '  <div class="tab-icon">',
        '    <div class="slice"></div>',
        '    <div class="slice"></div>',
        '  </div>',
        '</div>'
    ].join("\n");

    /** Bootstrap Methods **/

    proto.initialize = function () {
        this.firstPos = { x: 0, y: 0 };
        this.setTabAnimationRatio = this.setTabAnimationRatio.bind(this);
        this.setMenuAnimationRatio = this.setMenuAnimationRatio.bind(this);
        this.repeatTick = this.repeatTick.bind(this);
        this.isFocused = true;
    };

    // assign the element that will allow tapping to toggle focus.
    proto.setFocusElement = function (focusElement) {
        this.focusElement = focusElement;
        this.isFocused = false;
        this.buildFocusIndicator();
    };

    proto.bindEvents = function () {
        window.addEventListener('touchstart', this.onTouchStart.bind(this));
        window.addEventListener('touchend', this.onTouchEnd.bind(this));
        window.addEventListener('touchmove', this.onTouchMove.bind(this));
    };

    proto.bootstrap = function () {
        this.showTab();
        this.disableScrolling();
        if (!this.isAudioSupported()) {
            this.disableAudio();
        }
        this.disableSelection();
    };

    /** Event Handlers **/

    proto.onTouchStart = function (event) {
        if (this.isTouching) {
            return;
        }

        // Handle focus changes used in editor.
        this.handleFocusChange(event);
        if (!this.isFocused) {
            return;
        }

        if (event.target.tagName.toUpperCase() === 'A') {
            return;
        }
        this.isTouching = true;

        this.mayBeSwiping = true;
        this.gestured = false;

        this.swipeDirection = undefined;
        this.swipeDistance = 0;
        this.startTime = new Date().getTime();

        this.firstPos.x = event.touches[0].clientX;
        this.firstPos.y = event.touches[0].clientY;
    };

    proto.onTouchEnd = function (event) {
        if (!this.isFocused) {
            return;
        }
        if (!this.isTouching) {
            // If we're here, the menu event handlers had probably
            // canceled the touchstart event.
            return;
        }
        if (!this.gestured) {
            if (event.touches.length === 0) {
                this.handleTap();
            }
        }

        // The last finger to be removed from the screen lets us know
        // we aren't tracking anything.
        if (event.touches.length === 0) {
            this.isTouching = false;
            this.endRepeatWatcher();
        }
    };

    proto.onTouchMove = function (event)
    {
        if (!this.isFocused)
            return;
        if (screen_layout.noSwipe())
            return;
        if (this.isSuccessfulSwipe()) {
            this.handleSwipe(this.swipeDirection, this.touchCount);
            this.gestured = true;
            this.mayBeSwiping = false;
            this.beginRepeatWatcher(event);
        } else if (this.mayBeSwiping) {
            this.swipeStep(event);
        } else if (this.isRepeating) {
            this.repeatStep(event);
        }

        prevent(event);
        return false;
    };

    proto.handleFocusChange = function (event) {
        if (!this.focusElement) {
            return;
        }

        this.isFocused = this.isTouchInsideFocusElement(event);
        this.setFocusIndicatorVisibility(this.isFocused);
        
        canvas.focus();
        editor.display.input.blur();
    };

    proto.isTouchInsideFocusElement = function (event) {
        var canvasPosition;

        if (!event.touches || !event.touches[0]) {
            return false;
        }
        canvasPosition = this.absoluteElementPosition(this.focusElement);

        if (event.touches[0].clientX < canvasPosition.left ||
            event.touches[0].clientY < canvasPosition.top) {
            return false;
        }

        if (event.touches[0].clientX > canvasPosition.left + this.focusElement.clientWidth ||
            event.touches[0].clientY > canvasPosition.top + this.focusElement.clientHeight) {
            return false;
        }

        return true;
    };

    proto.setFocusIndicatorVisibility = function (isVisible) {
        var visibility;

        visibility = 'visible';
        if (!isVisible) {
            visibility = 'hidden';
        }
        // this.focusIndicator.setAttribute('style', 'visibility: ' + visibility + ';');
    };

    proto.absoluteElementPosition = function (element) {
        var position, body;

        position = {
            top: element.offsetTop || 0,
            left: element.offsetLeft || 0
        };
        body = document.getElementsByTagName('body')[0];
        position.top -= body.scrollTop || 0;

        while (true) {
            element = element.offsetParent;
            if (!element) {
                break;
            }
            position.top += element.offsetTop || 0;
            position.left += element.offsetLeft || 0;
        }

        return position;
    };

    proto.beginRepeatWatcher = function (event) {
        var repeatIntervalMilliseconds;
        if (this.repeatInterval) {
            return;
        }
        this.isRepeating = true;
        repeatIntervalMilliseconds = state.metadata.key_repeat_interval * 1000;
        if (isNaN(repeatIntervalMilliseconds) || !repeatIntervalMilliseconds) {
            repeatIntervalMilliseconds = DEFAULT_REPEAT_INTERVAL;
        }
        this.repeatInterval = setInterval(this.repeatTick, repeatIntervalMilliseconds);
        this.recenter(event);
    };

    proto.endRepeatWatcher = function () {
        if (this.repeatInterval) {
            clearInterval(this.repeatInterval);
            delete this.repeatInterval;
            this.isRepeating = false;
        }
    };

    proto.repeatTick = function () {
        if (this.isTouching) {
            this.handleSwipe(this.direction, this.touchCount);
        }
    };

    // Capture the location to consider the gamepad center.
    proto.recenter = function (event) {
        this.firstPos.x = event.touches[0].clientX;
        this.firstPos.y = event.touches[0].clientY;
    }

    /** Detection Helper Methods **/

    proto.isSuccessfulSwipe = function () {
        var isSuccessful;

        if (this.mayBeSwiping &&
            this.swipeDirection !== undefined &&
            this.swipeDistance >= SWIPE_DISTANCE) {
            isSuccessful = true;
        }

        return isSuccessful;
    };

    // Examine the current state to see what direction they're swiping and
    // if the gesture can still be considered a swipe.
    proto.swipeStep = function (event) {
        var currentPos, distance, currentTime;
        var touchCount;

        if (!this.mayBeSwiping) {
            return;
        }

        currentPos = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };
        currentTime = new Date().getTime();
        touchCount = event.touches.length;

        this.swipeDistance = this.cardinalDistance(this.firstPos, currentPos);
        if (!this.swipeDirection) {
            if (this.swipeDistance > SWIPE_THRESHOLD) {
                // We've swiped far enough to decide what direction we're swiping in.
                this.swipeDirection = this.dominantDirection(this.firstPos, currentPos);
                this.touchCount = touchCount;
            }
        } else if (distance < SWIPE_DISTANCE) {
            // Now that they've committed to the swipe, look for misfires...

            direction = this.dominantDirection(this.firstPos, currentPos);
            // Cancel the swipe if the direction changes.
            if (direction !== this.swipeDirection) {
                this.mayBeSwiping = false;
            }
            // If they're changing touch count at this point, it's a misfire.
            if (touchCount < this.touchCount) {
                this.mayBeSwiping = false;
            }
        } else if (currentTime - this.startTime > SWIPE_TIMEOUT) {
            // Cancel the swipe if they took too long to finish.
            this.mayBeSwiping = false;
        }
    };

    proto.repeatStep = function (event) {
        var currentPos, distance, currentTime;
        var newDistance, direction;

        currentPos = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };

        newDistance = this.cardinalDistance(this.firstPos, currentPos);

        if (newDistance >= SWIPE_DISTANCE) {
            this.swipeDirection = this.dominantDirection(this.firstPos, currentPos);
            this.recenter(event);
        }
    };

    // Find the distance traveled by the swipe along compass directions.
    proto.cardinalDistance = function (firstPos, currentPos) {
        var xDist, yDist;

        xDist = Math.abs(firstPos.x - currentPos.x);
        yDist = Math.abs(firstPos.y - currentPos.y);

        return Math.max(xDist, yDist);
    };

    // Decide which direction the touch has moved farthest.
    proto.dominantDirection = function (firstPos, currentPos) {
        var dx, dy;
        var dominantAxis, dominantDirection;

        dx = currentPos.x - firstPos.x;
        dy = currentPos.y - firstPos.y;

        dominantAxis = 'x';
        if (Math.abs(dy) > Math.abs(dx)) {
            dominantAxis = 'y';
        }

        if (dominantAxis === 'x') {
            if (dx > 0) {
                dominantDirection = 'right';
            } else {
                dominantDirection = 'left';
            }
        } else {
            if (dy > 0) {
                dominantDirection = 'down';
            } else {
                dominantDirection = 'up';
            }
        }

        return dominantDirection;
    };

    /** Action Methods **/

    // Method to be called when we've detected a swipe and some action
    // is called for.
    proto.handleSwipe = function (direction, touchCount) {
        if (touchCount === 1) {
            this.emitKeydown(this.swipeDirection);
        } else if (touchCount > 1) {
            // Since this was a multitouch gesture, open the menu.
            this.toggleMenu();
        }
    };

    proto.handleTap = function () {
        this.emitKeydown('action');
    };

    // Fake out keypresses to acheive the desired effect.
    proto.emitKeydown = function (input) {
        var event;

        event = { keyCode: CODE[input] };

        this.fakeCanvasFocus();
        // Press, then release key.
        onKeyDown(event);
        onKeyUp(event);
    };

    proto.fakeCanvasFocus = function () {
        var canvas;

        canvas = document.getElementById('gameCanvas');
        onMouseDown({
            button: 0,
            target: canvas
        });
    };

    proto.toggleMenu = function () {
        if (this.isMenuVisible) {
            this.hideMenu();
        } else {
            this.showMenu();
        }
    };

    proto.showMenu = function () {
        if (!this.menuElem) {
            this.buildMenu();
        }
        this.getAnimatables().menu.animateUp();
        this.isMenuVisible = true;
        this.hideTab();
    };

    proto.hideMenu = function () {
        if (this.menuElem) {
            this.getAnimatables().menu.animateDown();
        }
        this.isMenuVisible = false;
        this.showTab();
    };

    proto.getAnimatables = function () {
        var self = this;
        if (!this._animatables) {
            this._animatables = {
                tab: Animatable('tab', 0.1, self.setTabAnimationRatio),
                menu: Animatable('menu', 0.1, self.setMenuAnimationRatio)
            }
        }
        return this._animatables;
    };

    proto.showTab = function () {
        if (!this.tabElem) {
            this.buildTab();
        }
        this.getAnimatables().tab.animateDown();
    };

    proto.hideTab = function () {
        if (this.tabElem) {
            this.tabElem.setAttribute('style', 'display: none;');
        }
        this.getAnimatables().tab.animateUp();
    };

    proto.buildTab = function () {
        var self = this;
        var tempElem, body;
        var openCallback;
        var tabElem;
        var assemblyElem;

        tempElem = document.createElement('div');
        tempElem.innerHTML = TAB_STRING;
        assemblyElem = tempElem.children[0];

        openCallback = function (event) {
            event.stopPropagation();
            self.showMenu();
        };
        this.tabAffordance = assemblyElem.getElementsByClassName('tab-affordance')[0];
        this.tabElem = assemblyElem.getElementsByClassName('tab-icon')[0];

        this.tabAffordance.addEventListener('touchstart', openCallback);
        this.tabElem.addEventListener('touchstart', openCallback);

        body = document.getElementsByTagName('body')[0];
        body.appendChild(assemblyElem);
    };

    proto.buildMenu = function () {
        var self = this;
        var tempElem, body;
        var undo, restart, quit;
        var closeTab;
        var closeCallback;

        tempElem = document.createElement('div');
        tempElem.innerHTML = this.buildMenuString(state);
        this.menuElem = tempElem.children[0];
        this.closeElem = this.menuElem.getElementsByClassName('close')[0];

        closeCallback = function (event) {
            event.stopPropagation();
            self.hideMenu();
        };
        this.closeAffordance = this.menuElem.getElementsByClassName('close-affordance')[0];
        closeTab = this.menuElem.getElementsByClassName('close')[0];
        this.closeAffordance.addEventListener('touchstart', closeCallback);
        closeTab.addEventListener('touchstart', closeCallback);

        undo = this.menuElem.getElementsByClassName('undo')[0];
        if (undo) {
            undo.addEventListener('touchstart', function (event) {
                event.stopPropagation();
                self.emitKeydown('undo');
            });
        }
        restart = this.menuElem.getElementsByClassName('restart')[0];
        if (restart) {
            restart.addEventListener('touchstart', function (event) {
                event.stopPropagation();
                self.emitKeydown('restart');
            });
        }

        quit = this.menuElem.getElementsByClassName('quit')[0];
        quit.addEventListener('touchstart', function (event) {
            event.stopPropagation();
            self.emitKeydown('quit');
        });

        body = document.getElementsByTagName('body')[0];
        body.appendChild(this.menuElem);
    };

    proto.buildMenuString = function (state) {
    // Template for the menu.
        var itemCount, menuLines;
        var noUndo, noRestart;

        noUndo = state.metadata.noundo;
        noRestart = state.metadata.norestart;

        itemCount = 3;
        if (noUndo) {
            itemCount -= 1;
        }
        if (noRestart) {
            itemCount -= 1;
        }

        menuLines = [
            '<div class="mobile-menu item-count-' + itemCount + '">',
            '  <div class="close-affordance"></div>',
            '  <div class="close">',
            '    <div class="slice"></div>',
            '    <div class="slice"></div>',
            '  </div>'
        ];

        if (!noUndo) {
            menuLines.push('  <div class="undo button">Undo</div>');
        }
        if (!noRestart) {
            menuLines.push('  <div class="restart button">Restart</div>');
        }
        menuLines = menuLines.concat([
            '  <div class="quit button">Quit to Menu</div>',
            '  <div class="clear"></div>',
            '</div>'
        ]);

        return menuLines.join("\n");
    };

    proto.buildFocusIndicator = function () {
        var focusElementParent;
        this.focusIndicator = document.createElement('DIV');
        this.focusIndicator.setAttribute('class', 'tapFocusIndicator');
        this.focusIndicator.setAttribute('style', 'visibility: hidden;');

        focusElementParent = this.focusElement.parentNode;
        focusElementParent.appendChild(this.focusIndicator);
    };

    proto.setTabAnimationRatio = function (ratio) {
        var LEFT = 18;
        var RIGHT = 48 + 18;
        var size, opacityString;
        var style;

        // Round away any exponents that might appear.
        ratio = Math.round((ratio) * 1000) / 1000;
        if (ratio >= 0.999) {
            this.tabAffordance.setAttribute('style', 'display: none;');
        } else {
            this.tabAffordance.setAttribute('style', 'display: block;');
        }
        size = RIGHT * ratio + LEFT * (1 - ratio);
        opacityString = 'opacity: ' + (1 - ratio) + ';';
        style = opacityString + ' ' +
            'width: ' + size + 'px;';
        this.tabElem.setAttribute('style', style);
    };

    proto.setMenuAnimationRatio = function (ratio) {
        var LEFT = -48 - 18;
        var RIGHT = -18;
        var size, opacityString;
        var style;

        // Round away any exponents that might appear.
        ratio = Math.round((ratio) * 1000) / 1000;

        size = RIGHT * ratio + LEFT * (1 - ratio);
        opacityString = 'opacity: ' + ratio + ';';
        style = 'left: ' + (size - 4) + 'px; ' +
            opacityString + ' ' +
            'width: ' + (-size) + 'px;';
        ratio = Math.round((ratio) * 1000) / 1000;

        if (ratio <= 0.001) {
            this.closeAffordance.setAttribute('style', 'display: none;');
            opacityString="display:none;"
        } else {
            this.closeAffordance.setAttribute('style', 'display: block;');
        }

        this.closeElem.setAttribute('style', style);

        this.menuElem.setAttribute('style', opacityString);
    };

    proto.disableScrolling = function() {
        var style = {
            height: "100%",
            overflow: "hidden",
            position: "fixed",
            width: "100%"
        }
        
        var styleString = "";
        for (var key in style) {
            styleString += key + ": " + style[key] + "; ";
        }

        document.body.setAttribute('style', styleString)
    }

    /** Audio Methods **/

    proto.disableAudio = function () {
        // Overwrite the playseed function to disable it.
        window.playSeed = function () {};
    };

    proto.isAudioSupported = function () {
        var isAudioSupported = true;

        if (typeof webkitAudioContext !== 'undefined') {
            // We may be on Mobile Safari, which throws up
            // 'Operation not Supported' alerts when we attempt to
            // play Audio elements with "data:audio/wav;base64"
            // encoded HTML5 Audio elements.
            //
            // Switching to MP3 encoded audio may be the way we have
            // to go to get Audio working on mobile devices.
            //
            // e.g. https://github.com/rioleo/webaudio-api-synthesizer
            isAudioSupported = false;
        }

        return isAudioSupported;
    };

    /** Other HTML5 Stuff **/

    proto.disableSelection = function () {
        var body;
        body = document.getElementsByTagName('body')[0];
        body.setAttribute('class', body.getAttribute('class') + ' disable-select');
    };

}(window.Mobile.GestureHandler.prototype));

window.Animator = function () {
    this.initialize.apply(this, arguments);
};

(function (proto) {
    proto.initialize = function () {
        this._animations = {};
        this.tick = this.tick.bind(this);
    };

    proto.animate = function (key, tick) {
        this._animations[key] = tick;
        this.wakeup();
    };

    proto.wakeup = function () {
        if (this._isAnimating) {
            return;
        }
        this._isAnimating = true;
        this.tick();
    };

    proto.tick = function () {
        var key;
        var isFinished, allFinished;
        var toRemove, index;

        toRemove = [];
        allFinished = true;
        for (key in this._animations) {
            if (!this._animations.hasOwnProperty(key)) {
                return;
            }
            isFinished = this._animations[key]();
            if (!isFinished) {
                allFinished = false;
            } else {
                toRemove.push(key);
            }
        }

        if (!allFinished) {
            requestAnimationFrame(this.tick);
        } else {
            for (index = 0; index < toRemove.length; toRemove++) {
                delete this._isAnimating[toRemove[index]];
            }
            this._isAnimating = false;
        }
    };

}(window.Animator.prototype));

window.Animator.getInstance = function () {
    if (!window.Animator._instance) {
        window.Animator._instance = new window.Animator();
    }
    return window.Animator._instance;
};

function Animatable(key, increment, update) {
    var ratio;
    var handles;

    handles = {
        animateUp: function () {
            Animator.getInstance().animate(key, tickUp);
        },
        animateDown: function () {
            Animator.getInstance().animate(key, tickDown);
        }
    };

    ratio = 0;

    function tickUp () {
        var isFinished;
        ratio += increment;
        if (ratio >= 1.0) {
            isFinished = true;
            ratio = 1;
        }
        update(ratio);
        return isFinished;
    };

    function tickDown () {
        var isFinished;
        ratio -= increment;
        if (ratio <= 0.0) {
            isFinished = true;
            ratio = 0;
        }
        update(ratio);
        return isFinished;
    };

    return handles;
};


// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function() {
    'use strict';

    var VENDORS = ['ms', 'moz', 'webkit', 'o'];
    var index, lastTime;

    for (index = 0; index < VENDORS.length && !window.requestAnimationFrame; index++) {
        window.requestAnimationFrame = window[VENDORS[index] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[VENDORS[index] + 'CancelAnimationFrame'];
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = window[VENDORS[index] + 'CancelRequestAnimationFrame'];
        }
    }

    if (!window.requestAnimationFrame) {
        lastTime = 0;
        window.requestAnimationFrame = function(callback, element) {
            var currTime, timeToCall, id;

            currTime = new Date().getTime();
            timeToCall = Math.max(0, 16 - (currTime - lastTime));
            id = window.setTimeout(function() {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;

            return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
    }

    Mobile.enable();
}());

compile(-1, "title Chroma Key\nauthor Zachary Barbanell\n\nrequire_player_movement\nrun_rules_on_level_start\n\ncolor_palette 14\n\nagain_interval 0.2\n\nnoaction\n\n=====\nTAGS\n=====\n\nColor = R O Y G B P\n\n=========\nMAPPINGS\n=========\n\nColor => Next\nR O Y G B P -> O Y G B P R\n\nColor => Nex2\nR O Y G B P -> Y G B P R O\n\n========\nOBJECTS\n========\n\nBackground \nlightgray\n\nWall \ndarkgray\n\nPlayer:R\nred\n.000.\n.000.\n00000\n.000.\n.0.0.\n\nPlayer:O\norange\ncopy: Player:R\n\nPlayer:Y\nyellow\ncopy: Player:R\n\nPlayer:G\ngreen\ncopy: Player:R\n\nPlayer:B\nblue\ncopy: Player:R\n\nPlayer:P\npurple\ncopy: Player:R\n\nLock:R\nred\n\nLock:O\norange\n\nLock:Y\nyellow\n\nLock:G\ngreen\n\nLock:B\nblue\n\nLock:P\npurple\n\ninset:Color\ndarkgray\n00.00\n0...0\n.....\n0...0\n00.00\n\nHighlight\nlightgray\n..00000..\n.00...00.\n00.....00\n0.......0\n0.......0\n0.......0\n00.....00\n.00...00.\n..00000..\ntranslate:left:2\ntranslate:down:2\n\n=======\nLEGEND\n=======\n\n. = Background\n# = Wall\n@ = Player:R\n\n1 = Lock:R\n2 = Lock:O\n3 = Lock:Y\n4 = Lock:G\n5 = Lock:B\n6 = Lock:P\n\nα = 1 and inset:R\nβ = 2 and inset:O\nγ = 3 and inset:Y\nδ = 4 and inset:G\nε = 5 and inset:B\nζ = 6 and inset:P\n\nPlayer = Player:Color\nLock = Lock:Color\n\n=======\nSOUNDS\n=======\n\nPlayer move 51102607\nLock:Color destroy 25707508\ncancel 5920304\nendlevel 52105900\n\n(old lock open sound 52105900)\n\n================\nCOLLISIONLAYERS\n================\n\nBackground\nLock:Color\nInset:Color\nWall, Player:Color\n--\nHighlight\n\n\n\n\n======\nRULES     \n======     \n\nColor [Player Lock:Color] -> [Player:Color]\n\n[Highlight] -> []\n\nColor [Player:Color] [Inset:Next] -> [Player:Color] [Inset:Next Highlight]\nColor [Player:Color] [Inset:Nex2] -> [Player:Color] [Inset:Nex2 Highlight]\n\nColor [> Player:Color | Lock no Lock:Next no Lock:Nex2] -> cancel\n\nlate [Player Lock:Color] -> again\n\nlate [Highlight no Inset:Color] -> [ ]\n\n==============\nWINCONDITIONS\n==============\n\nall Lock:Color on Inset:Color\n\n=======     \nLEVELS\n=======\n\n###############\n#......#......#\n#.@....1......#\n#......#......#\n#...#######...#\n#...##β#γ##...#\n#...#######...#\n##2##α###δ#6#4#\n#...#######...#\n#...##ζ#ε##...#\n#...#######...#\n#......3......#\n#......#......#\n#......4......#\n###############\n\n###################\n###################\n#...#...#...#.....#\n#...#...4...3..@..#\n#...#...#...#.....#\n##3###6###5####1###\n#...#...#...###2###\n#...#...2...###3###\n#...#...#...###4###\n##6#######5####5###\n#...#...#...###6###\n#...1...5...#######\n#...#...#...#######\n##########2###β#γ##\n#...#...#...#######\n#...2...1...#α###δ#\n#...#...#...#######\n##############ζ#ε##\n###################\n\n###############\n##β#γ##5##2##4#\n#######.##.##.#\n#α###δ#5##6##2#\n#######.##.##.#\n##ζ#ε##6..4..1#\n##########.####\n#2.6.4#.......#\n#####.#.......#\n#####.#..333..#\n#1.6.5...3@3..#\n#####.#..333..#\n#####.#.......#\n#4.1.2#.......#\n###############\n\n#############\n#...........#\n#.....@.....#\n#...........#\n##5##β#γ##2##\n#...#####...#\n#...α###δ...#\n#...#####...#\n##4##ζ#ε#####\n#.....#.....#\n#.....3.....1\n#.....#.....#\n#############\n\nmessage Thanks for Playing!\n\n")
</script>

</body>
</html>
